{"pageProps":{"postData":{"id":"proxy-to-built-in-objects","contentHtml":"<h2>I. 문제상황</h2>\n<p>Map에 아이템을 추가하는 시점에 추가적인 다른 액션을 하고 싶은 니즈가 있었다.\n그래서 Proxy객체를 이용하여 아래와 같이 하면 되지 않을까 생각하여 아래와 같이 선언하였다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();\n<span class=\"hljs-keyword\">const</span> proxifiedMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(map, {\n  <span class=\"hljs-attr\">set</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">target, key, value, receiver</span>) =></span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"[proxifiedMap]\"</span>, { key, value });\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">set</span>(target, key, value, receiver);\n  },\n});\n</code></pre>\n<p>그 다음 선언한 <code>proxifiedMap을</code> 이용해서 아이템을 추가하면, console.log가 찍히기는 커녕 아래와 같은 타입에러가 발생하였다.</p>\n<pre><code class=\"hljs language-js\">proxifiedMap.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">\"test-key\"</span>, <span class=\"hljs-number\">123</span>);\n\n<span class=\"hljs-comment\">/**\n * Uncaught TypeError: Method Map.prototype.set called on incompatible receiver #&#x3C;Map>\n *     at Proxy.set (&#x3C;anonymous>)\n *    at &#x3C;anonymous>:1:14\n */</span>\n</code></pre>\n<h2>II. 발생원인</h2>\n<p>Map과 같은 빌트인 객체는 아이템을 다루기 위해 internal slot 을 사용한다. internal slot이란, ECMAScript 스펙에서 사용되는 개념으로 빌트인 객체의 목적을 달성하기 위해 내부적인 용도로 사용되는 빌트인 객체의 속성이라고 볼 수 있다. 흔히 스펙에서 <code>[[internal slot]]</code>과 같이 대괄호(<code>[]</code>) 두 개로 감싸서 표시된다. internal slot은 스펙상으로만 존재하고 외부로 구현이 노출되지 않아, 실제 런타임에서는 어떤 방법으로든 접근할 수 없다.</p>\n<p>Map에 아이템을 추가하는 것은 <code>[[Set]</code>이 아니라 <code>[[MapData]]</code>라는 internal slot을 이용해서 요소들을 저장하고 직접 접근하기 때문에, proxy의 set trap을 이용하여 아이템 추가 시점을 가로챌 수 없다.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-title class_\">Uncaught</span> <span class=\"hljs-title class_\">TypeError</span>: <span class=\"hljs-title class_\">Method</span> <span class=\"hljs-title class_\">Map</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">set</span> called on incompatible receiver #&#x3C;<span class=\"hljs-title class_\">Map</span>>\n</code></pre>\n<p>위의 에러에서 보는것과 같이 <code>proxifiedMap.set</code> 을 호출하면 <code>Map.prototype.set</code> 이 호출되며, <code>Map.prototype.set</code> 은 <code>this.[[MapData]]</code>에 접근하려고 하나, 이 때의 <code>this</code> 값은 Map의 인스턴스가 아니라 Proxy의 인스턴스이므로 <code>[[MapData]]</code> 이 존재하지 않아 에러가 발생하는 것이다.</p>\n<h2>III. 해결방법</h2>\n<p>Map 도 객체이므로 <code>set, get, entries</code>등 프로토타입 메소드에 접근하는 것을 get trap으로 인터셉트 할 수 있다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();\n<span class=\"hljs-keyword\">const</span> proxifiedMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(map, {\n  <span class=\"hljs-attr\">get</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">target, key, receiver</span>) =></span> {\n    <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">get</span>(target, key, receiver);\n\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"[proxifiedMap]\"</span>, { key, value });\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> value === <span class=\"hljs-string\">\"function\"</span> ? value.<span class=\"hljs-title function_\">bind</span>(target) : value;\n  },\n});\n</code></pre>\n<ol>\n<li>get handler의 key값에 <code>set, get, entries</code> 와 같은 프로토타입 메소드명이 할당된다.</li>\n<li><code>Reflect.get</code> 을 이용하여 <code>Map.prototype</code> 의 메소드를 가지고 와 <code>value</code>에 할당한다.</li>\n<li><code>value</code>에 Map 객체 <code>target</code>을 바인딩한다. 이로써 실제 <code>Map.prototype.set</code> 이 호출될 때 Map 객체가 바인딩되어 있으므로 <code>this.[[MapData]]</code>에 접근할 수 있다.</li>\n</ol>\n<p>최종적으로 Map에 아이템을 추가하였을 때 추가적인 액션을 하고 싶다면 아래와 같이 작성하면 된다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();\n<span class=\"hljs-keyword\">const</span> proxifiedMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(map, {\n  <span class=\"hljs-attr\">get</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">target, key, receiver</span>) =></span> {\n    <span class=\"hljs-keyword\">if</span> (key === <span class=\"hljs-string\">\"set\"</span>) {\n      <span class=\"hljs-comment\">// 추가적인 액션!!</span>\n    }\n    <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">get</span>(target, key, receiver);\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> value === <span class=\"hljs-string\">\"function\"</span> ? value.<span class=\"hljs-title function_\">bind</span>(target) : value;\n  },\n});\n</code></pre>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://javascript.info/proxy#proxy-limitations\">https://javascript.info/proxy#proxy-limitations</a></li>\n<li><a href=\"https://tc39.es/ecma262/#sec-map-iterable\">https://tc39.es/ecma262/#sec-map-iterable</a></li>\n</ul>","title":"JS 내장 객체에 Proxy 객체를 적용하는 방법","date":"2023-06-25T00:00:00.000Z","description":"Proxy 객체를 이용해서 JS 내장 객체의 행동을 가로채는 방법","keywords":["Proxy"," Map"," built-in object"," 내장 객체"," internal slot"," Reflect"," 트랩 설정"," 내부 슬롯"," set trap"]},"_superjson":{"values":{"postData.date":["Date"]}}},"__N_SSG":true}