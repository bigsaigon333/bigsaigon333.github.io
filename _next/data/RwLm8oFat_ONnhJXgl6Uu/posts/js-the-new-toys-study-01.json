{"pageProps":{"postData":{"id":"js-the-new-toys-study-01","contentHtml":"<ul>\n<li>1주차 / 2022-12-27 화 22:00 ~ 24:00</li>\n<li>범위: 2장 블록 스코프 선언: let과 const</li>\n</ul>\n<h2>책 내용 정리</h2>\n<h3>선언, 할당</h3>\n<p><code>var</code>와 <code>let</code>은 변수의 선언에 사용된다.</p>\n<p>변수는 선언과 값의 할당을 분리할 수 있다.</p>\n<p>선언과 동시에 값을 할당하지 않는다면 <code>undefined</code>가 할당된다.</p>\n<p><code>const</code>는 상수의 선언에 사용된다.</p>\n<p>상수는 값을 변경할 수 없다. 따라서 선언과 값의 할당이 동시에 일어나야 한다.</p>\n<p>선언과 동시에 값을 할당하는 것을 초기화라고 한다.</p>\n<p><code>const</code>로 선언한 상수에 새 값을 할당하려고 하면 오류가 발생한다.</p>\n<h3>스코프</h3>\n<p><code>var</code>는 함수 스코프이다. 블록 내에서 선언하더라도 같은 함수 내 블록 외부에서 접근이 가능하다.</p>\n<p><code>let</code>과 <code>const</code>는 선언된 블록 내에서만 존재한다.</p>\n<h3>반복된 선언</h3>\n<ul>\n<li><code>var</code>는 같은 스코프내에서 동일한 변수명으로 여러번 선언할 수 있다.</li>\n<li><code>let</code>과 <code>const</code>는 동일한 스코프내에서 동일한 변수명으로 여러번 선언할 수 없다.\n<ul>\n<li>코드가 구문 분석될 때 오류가 발생한다.</li>\n</ul>\n</li>\n</ul>\n<h3>호이스팅과 TDZ</h3>\n<ul>\n<li><code>var</code> 변수의 선언은 함수 내 최상단으로 끌어올려진다(호이스팅된다)</li>\n<li>다만 값의 할당까지 끌어올려지지 않는다. 따라서 <code>var</code> 변수를 선언되기 전에 접근하면 undefined가 할당되어 있다.</li>\n<li><code>let</code>과 <code>const</code> 변수 또한 함수 내 최상단으로 끌어올려지지만(호이스팅되지만), <code>let</code>, <code>const</code> 변수/상수에 선언전에 접근할 수 없으며, 이때 <code>let</code>,<code>const</code> 변수/상수는 TDZ에 있다고 한다. 즉, TDZ에 있는 변수/상수에는 접근할 수 없다.</li>\n<li>TDZ는 공간적이 아니라 시간적인 개념이다. 식별자를 사용할 수 없는 범위가 아니라 식별자를 사용할 수 없는 기간이다.</li>\n<li>외부 스코프와 내부 스코프에 동일한 변수명을 가진 변수 x가 있을 때, 내부 스코프의 변수 x가 TDZ에 있을 때에 외부 스코프의 변수 x에 접근할 수 없다.</li>\n</ul>\n<h3>전역 속성</h3>\n<ul>\n<li><code>var</code>를 사용하여 변수를 선언하면 전역 객체(<code>globalThis</code>)의 속성이 된다.</li>\n<li><code>let</code>과 <code>const</code>는 전역 객체의 속성이 되지 않는다.</li>\n</ul>\n<hr>\n<h2>스터디 내용 정리</h2>\n<h3>JS spec 보다는 사용법에 초점을</h3>\n<p>매년 JS spec이 엄청나게 바뀌기 때문에, JS 엔진 제작자가 아닌 이상 spec을 너무 깊게 파고드는 건 낭비이다. JS의 문법적 의미 및 JS를 어떻게 사용해야하는지에 초점을 맞추는게 더 낫다.</p>\n<p>예를 들어, 클래스에 private field가 추가되면서 클래스 스펙이 전반적으로 많이 바뀌었다. 따라서 기존에 알고 있던 JS spec 은 현시점에서는 이미 잘못된 내용일 가능성이 높다.</p>\n<h3>알고리즘이란</h3>\n<p>제어와 상태를 이용해서 문제를 해결하는 것이다.</p>\n<ul>\n<li>제어: for, if 문 등</li>\n<li>상태: 변수</li>\n</ul>\n<h3>JS에서 코드 실행 시점 제어 방법</h3>\n<p>아래와 같은 코드는 동기화 코드이다.</p>\n<p>동기화 코드는 동기적으로 실행된다: 쌓아놓은 코드가 무조건 전부 한번에 실행되고 그 사이에 개입할 수 없음을 의미한다.</p>\n<pre><code class=\"hljs language-jsx\">a;\nb;\nc;\n</code></pre>\n<h4>1. 제어문: 동기실행을 제어하는 특수한 구문</h4>\n<p><code>if if-else switch while for</code> 등이 있다.</p>\n<pre><code class=\"hljs language-jsx\">a;\n<span class=\"hljs-keyword\">if</span> () b;\n<span class=\"hljs-keyword\">else</span> c;\n\n<span class=\"hljs-comment\">// a b 또는 a c</span>\n</code></pre>\n<h4>2. 논리 연산자</h4>\n<p><code>&#x26;&#x26;, ||</code> 등</p>\n<pre><code class=\"hljs language-jsx\">(<span class=\"hljs-title function_\">f</span>() &#x26;&#x26; <span class=\"hljs-title function_\">b</span>()) || (<span class=\"hljs-title function_\">c</span>() &#x26;&#x26; <span class=\"hljs-title function_\">d</span>());\n\n<span class=\"hljs-comment\">// f b 또는 f c 또는 f c d</span>\n</code></pre>\n<h4>3. 함수</h4>\n<p>JS엔진은 함수를 lazy하게 평가한다. 선언할 때 평가하는게 아니라 실행할 때 평가한다.</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) {\n  b;\n  c;\n}\n\na;\nd;\n<span class=\"hljs-title function_\">f</span>();\n\n<span class=\"hljs-comment\">// a d b c</span>\n</code></pre>\n<h3>실행 컨텍스트는 코드가 실행되는 시점에 생성된다</h3>\n<h4>1. 문제 없음</h4>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">temporalExample</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">f</span> = (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);\n  };\n  <span class=\"hljs-keyword\">let</span> value = <span class=\"hljs-number\">42</span>;\n  <span class=\"hljs-title function_\">f</span>();\n}\n<span class=\"hljs-title function_\">temporalExample</span>();\n</code></pre>\n<h4>2. 문제 있음</h4>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">temporalExample</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">f</span> = (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);\n  };\n  <span class=\"hljs-title function_\">f</span>();\n  <span class=\"hljs-keyword\">let</span> value = <span class=\"hljs-number\">42</span>;\n}\n<span class=\"hljs-title function_\">temporalExample</span>();\n</code></pre>\n<h4>3. 문제 없음: 지연 실행으로 인한 JS의 특징</h4>\n<p>코드 실행 시점에 구문 분석이 실행되기 때문이다.</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">temporalExample</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">f</span> = (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);\n  };\n\n  <span class=\"hljs-title function_\">f</span>();\n  <span class=\"hljs-keyword\">let</span> value = <span class=\"hljs-number\">42</span>;\n}\n<span class=\"hljs-comment\">// temporalExample();</span>\n</code></pre>\n<h4>⇒ Best Practice</h4>\n<p>외부 스코프의 변수에 의존하지 않는 것</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">f</span> = (<span class=\"hljs-params\">value</span>) => <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);\n<span class=\"hljs-keyword\">let</span> value = <span class=\"hljs-number\">42</span>;\n<span class=\"hljs-title function_\">f</span>(value);\n</code></pre>\n<h3>섀도잉 절대 금지</h3>\n<p>섀도잉이란 외부 스코프에 선언된 변수명을 내부 스코프의 변수 선언에 중복해서 사용하는 것을 의미한다.</p>\n<p>중첩 스코프는 안쓰는게 베스트다. 일반적인 개발자는 감당할 수 없다.</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-comment\">// 섀도잉</span>\n<span class=\"hljs-keyword\">let</span> member\n<span class=\"hljs-keyword\">if</span> () {\n  <span class=\"hljs-keyword\">let</span> member\n}\n</code></pre>\n<p>코드를 짜는 흐름 때문에 2. 로 섀도잉을 피하는게 일반적이나, 1. 도 나쁘지 않다.</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-comment\">// 섀도잉을 해결을 위한 두가지 방법</span>\n\n<span class=\"hljs-comment\">// 1.</span>\n<span class=\"hljs-keyword\">let</span> baseMember\n<span class=\"hljs-keyword\">if</span>(){\n  <span class=\"hljs-keyword\">let</span> member\n}\n\n<span class=\"hljs-comment\">// 2.</span>\n<span class=\"hljs-keyword\">let</span> member\n<span class=\"hljs-keyword\">if</span>(){\n  <span class=\"hljs-keyword\">let</span> vipMember\n}\n</code></pre>\n<h3>루프 내 클로저 성능 영향</h3>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">let</span> n;\n<span class=\"hljs-keyword\">for</span>(n,,,)\n\nvs\n\n<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> n ...)\n</code></pre>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> n){\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">f</span> = (<span class=\"hljs-params\"></span>) => n\n} <span class=\"hljs-comment\">// 매 순회마다 n에 대한 어휘 환경을 만들기 때문에 성능에 영향을 줌</span>\n\n<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> n){\n <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(n)\n} <span class=\"hljs-comment\">// JS엔진이 최적화를 하기 때문에 성능에 영향 없음</span>\n</code></pre>\n<h3>for vs while</h3>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i) {\n}\n\n<span class=\"hljs-comment\">// for 문 밖에서 i를 쓸 수 없다.</span>\n</code></pre>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">let</span> i\n<span class=\"hljs-keyword\">while</span>(바깥에 있는 변수) {\n}\n\n<span class=\"hljs-keyword\">let</span> a\n<span class=\"hljs-keyword\">while</span>(a, ~~b~~){ <span class=\"hljs-comment\">// 외부 스코프에 있는 a는 사용 가능하나, 내부 스코프에 있는 b는 사용할 수 없다.</span>\n <span class=\"hljs-keyword\">let</span> b\n}\n</code></pre>\n<aside>\n💡 while 과 do-while 은 모던 언어에서 차이가 거의 없다. 코틀린은 차이가 있음.\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-comment\">// 코틀린은 됨</span>\n<span class=\"hljs-keyword\">do</span>{\n  <span class=\"hljs-keyword\">let</span> a\n} <span class=\"hljs-keyword\">while</span>(a)\n\n<span class=\"hljs-keyword\">do</span>{\n내가 뭔가 했어\n}\n<span class=\"hljs-keyword\">while</span>(잘안되었냐) 가 일반적이라서... 많은 언어에서 도입하려고 함\n</code></pre>\n</aside>\n<h3>JS의 단점: 함수의 매개변수가 let이다</h3>\n<h4>권장 프랙티스</h4>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">let</span>으로 난리칠곳\n<span class=\"hljs-keyword\">const</span>로 정리\n<span class=\"hljs-keyword\">const</span>에만 의존하는 알고리즘\n</code></pre>\n<p>코드가 상수에 의존하게끔 빨리 바꿔라. 리팩토링을 거대하게 하려고 하지 마라.</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-comment\">// AS-IS</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">a</span>){\n  a = <span class=\"hljs-number\">45</span> <span class=\"hljs-comment\">// Nooooo!</span>\n}\n\n<span class=\"hljs-comment\">// TO-BE</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">a</span>){\n  <span class=\"hljs-keyword\">const</span> A = a\n  A에 의존\n}\n</code></pre>\n<h4>예제</h4>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">let</span> resut;\n<span class=\"hljs-keyword\">if</span>() result = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">else</span> result = <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-comment\">// result = 3  Error를 내고 싶다!</span>\n</code></pre>\n<p>빨리 할 수 있는 조치</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">let</span> resut;\n<span class=\"hljs-keyword\">if</span>() result = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">else</span> result = <span class=\"hljs-number\">2</span>;\n\n<span class=\"hljs-keyword\">const</span> resultConfirmed = result;\n<span class=\"hljs-comment\">// resultConfirmed에 의존적인 코드들 ...</span>\nresult = <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// 아무영향도 없음</span>\n</code></pre>\n<p>⇒ JS는 린트가 필수!</p>","title":"웹 개발자를 위한 자바스크립트의 모든 것 스터디 1주차","date":"2022-12-28"}},"__N_SSG":true}