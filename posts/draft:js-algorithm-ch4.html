<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta name="next-head-count" content="2"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c0319daaf0c38f70.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-bd0fea9977d95d65.js" defer=""></script><script src="/_next/static/Yp9dDFoGJHjN8zU7XV6TC/_buildManifest.js" defer=""></script><script src="/_next/static/Yp9dDFoGJHjN8zU7XV6TC/_ssgManifest.js" defer=""></script><script src="/_next/static/Yp9dDFoGJHjN8zU7XV6TC/_middlewareManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.3">*,::before,::after{box-sizing:border-box;}/*!sc*/
[hidden]{display:none;}/*!sc*/
h1{margin:0.67em 0;font-size:2rem;}/*!sc*/
h2{font-size:1.5rem;}/*!sc*/
h3{font-size:1.17rem;}/*!sc*/
h4{font-size:1rem;}/*!sc*/
h5{font-size:0.83rem;}/*!sc*/
h6{font-size:0.67rem;}/*!sc*/
pre{white-space:pre-wrap;}/*!sc*/
hr{border-style:solid;border-width:1px 0 0;color:inherit;height:0;overflow:visible;}/*!sc*/
img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle;max-width:100%;}/*!sc*/
picture{display:contents;}/*!sc*/
source{display:none;}/*!sc*/
img,svg,video,canvas{height:auto;}/*!sc*/
audio{width:100%;}/*!sc*/
audio:not([controls]){display:none;}/*!sc*/
img{border-style:none;}/*!sc*/
svg{overflow:hidden;}/*!sc*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block;}/*!sc*/
[type="checkbox"],[type="radio"]{box-sizing:border-box;padding:0;}/*!sc*/
html,body{padding:0;margin:0;font-family:-apple-system,BlinkMacSystemFont,"Apple SD Gothic Neo","Malgun Gothic","맑은 고딕","나눔고딕","Nanum Gothic","Noto Sans KR","Noto Sans CJK KR",arial,"돋움",Dotum,Tahoma,Geneva,"Helvetica Neue",sans-serif;}/*!sc*/
a{color:inherit;-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g1[id="sc-global-crMvLC1"]{content:"sc-global-crMvLC1,"}/*!sc*/
.gOdiQq{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;width:100%;}/*!sc*/
data-styled.g2[id="sc-d7fdb9d7-0"]{content:"gOdiQq,"}/*!sc*/
.kKdabY{margin:0;line-height:1.25;width:100%;font-size:3.6rem;text-align:center;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-column-gap:2rem;column-gap:2rem;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;font-weight:800;}/*!sc*/
@media (max-width:767px){.kKdabY{font-size:7.5vw;-webkit-column-gap:1rem;column-gap:1rem;}}/*!sc*/
data-styled.g3[id="sc-d7fdb9d7-1"]{content:"kKdabY,"}/*!sc*/
.hfKWMb{position:relative;overflow:hidden;border-radius:35%;width:25%;padding-bottom:25%;}/*!sc*/
@media (max-width:600px){.hfKWMb{width:20%;padding-bottom:20%;}}/*!sc*/
data-styled.g4[id="sc-d7fdb9d7-2"]{content:"hfKWMb,"}/*!sc*/
.caTBeP{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;}/*!sc*/
data-styled.g5[id="sc-d7fdb9d7-3"]{content:"caTBeP,"}/*!sc*/
.BgALf{min-height:100vh;padding:3rem 2rem 0;-webkit-flex:1;-ms-flex:1;flex:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:flex-start;-webkit-box-align:flex-start;-ms-flex-align:flex-start;align-items:flex-start;row-gap:2rem;max-width:768px;margin:auto;}/*!sc*/
@media (max-width:600px){.BgALf{padding:2rem 1rem 0;}}/*!sc*/
data-styled.g9[id="sc-a364bef7-0"]{content:"BgALf,"}/*!sc*/
.hfGxXL{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;width:calc(100vw - 3rem);padding:2rem 0 1rem;border-top:1px solid #eaeaea;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}/*!sc*/
data-styled.g10[id="sc-a364bef7-1"]{content:"hfGxXL,"}/*!sc*/
.kLhcQd h2{font-size:2.5rem;margin:0 0 0.5rem;font-weight:800;}/*!sc*/
@media (max-width:600px){.kLhcQd h2{font-size:2rem;}}/*!sc*/
@media (max-width:375px){.kLhcQd h2{font-size:1.5rem;}}/*!sc*/
.kLhcQd time{font-size:1rem;}/*!sc*/
.kLhcQd p{font-size:1.25rem;line-height:1.75rem;}/*!sc*/
data-styled.g12[id="sc-564a7b06-1"]{content:"kLhcQd,"}/*!sc*/
.gffvJe{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}/*!sc*/
data-styled.g13[id="sc-5d513e51-0"]{content:"gffvJe,"}/*!sc*/
</style></head><body><div id="__next" data-reactroot=""><div class="sc-a364bef7-0 BgALf"><header class="sc-d7fdb9d7-0 gOdiQq"><h1 class="sc-d7fdb9d7-1 kKdabY"><div class="sc-d7fdb9d7-2 hfKWMb"><img src="/profile.jpg" alt="프로필" class="sc-d7fdb9d7-3 caTBeP"/></div><span>프론트엔드 개발자<br/>김동희입니다</span></h1></header><article class="sc-564a7b06-1 kLhcQd"><h2>Ch04. 해시테이블</h2><time>2020-03-13</time></article><main class="sc-5d513e51-0 gffvJe"><p>배열에서는 특정 값을 탐색하기 위해서는 O(N)이 소요되었다.
데이터를 O(1) 만에 탐색할 수 있는 해시 테이블이라는 특수한 자료 구조의 사용법에 대해서 알아보자.</p>
<h2>4-1. 해시테이블이란?</h2>
<p>해시테이블은 키와 값의 쌍으로 이루어진 리스트이다. 해시테이블은 다양한 프로그래밍 언어에서 서로 다른 이름으로 불린다. 해시, 맵, 해시 맵, 딕셔너리, 연관 배열 등</p>
<p>해시테이블은 키를 알고 있다면 O(1)으로 해당하는 값에 접근할 수 있다는 특징이 있다.</p>
<pre><code>{
  pencil: 1000,
  pen: 1500,
  eraser: 500,
  ruler: 1200,
  note: 2000
}
</code></pre>
<p>pencil 이라는 키를 알고 있다면 pencil의 가격인 1000원을 바로 알 수 있다.</p>
<p>어떻게 가능한 것일까?
배열은 인덱스 값을 알고 있다면 인덱스에 위치한 값을 O(1)으로 접근할 수 있다.</p>
<p>따라서 각각의 키를 일정한 규칙에 따라 고유한 인덱스로 변환시킨 후 이를 배열에 저장하는 방식으로 구현할 수 있다.</p>
<p>입력값인 키를 유일한 인덱스로 변환하는 함수를 해시 함수라고 부른다.
해시 함수에는 다양한 방법이 존재할 수 있다.</p>
<p>예를 들어, a = 1, b = 2, c = 3 ... 으로 설정한 후 문자를 숫자로 바꾼 후 각각을 더한 값을 한다.
pen 은 p = 16 e = 5 n = 14 = > 16 + 5 + 14 = 35 이다</p>
<p>매우 큰 배열에 인덱스가 35인 위치에 값을 1500으로 한다.</p>
<p>hash['pen'] => hash[35] => 1500</p>
<p>이렇게 접근할 수 있을 것이다.</p>
<p>눈치가 빠르신 분들은 이미 아셨겠지만, 각 자리수의 합이 35가 나올 수 있는 경우는 매우 많다.</p>
<p>예를 들면 'algo' 또한 35이다.</p>
<p>이렇게 키를 해싱한 값이 중복되는 경우를 충돌(Collision)이라고 한다.</p>
<p>해시 함수가 유효하려면 딱 한 가지 기준을 충족해야 하는데, 동일한 문자열을 해시 함수에 적용할 때마다 항상 동일한 숫자로 변환해야 한다.</p>
<p>난수나 현재 시간을 계산에 넣어서 사용하는 해시 함수는 유효하지 않다.</p>
<p>'pen'을 언제 몇번을 넣더라도 항상 35로 변환되어야 한다는 뜻이다.</p>
<h3>충돌 해결</h3>
<p>충돌을 해결하기 위한 방법이 많이 있다. 고전적인 방법인 분리 연결법, 개방 주소법 등등.</p>
<p>다만, 대부분의 프로그래밍 언어에서 해시 테이블을 구현할 때 이를 대신 처리한다. 가장 최선의 방법으로 해결해놓았다. 코딩테스트를 푸는 입장에서는 어떻게 이러한 해시테이블을 사용할지에 조금더 초점을 맞추겠다. 어떤 충돌해결방법이 있는지는 기본적인 컴퓨터 지식이므로 각자 공부하셔야 한다. 면접 때 당연히 물어볼 수 있다. 프론트엔드에서는 잘 안물어보긴 하더라...</p>
<h3>단방향 룩업</h3>
<p>해시 테이블에서 한 단계만에 값을 찾는 기능은 그 값의 키를 알 때만 가능하다.
키를 모른 채 값을 찾으려면 해시 테이블 내 모든 키/값 쌍을 검색하는 수밖에 없고 이는 O(N)이다.
키를 사용해 값을 찾을 때만 O(1) 룩업이 가능하고, 거꾸로 값을 이용해 연관된 키를 찾을 때는 해시 테이블의 빠른 룩업 기능을 활용할 수 없다.</p>
<p>각 키는 해시 테이블에 딱 하나만 존재할 수 있으나 동일한 값은 여러개 존재할 수 있다.</p>
<p>pencil의 가격은 유일하게 1500원이지만, 1500원짜리인 사무용품은 pencil외에도 있을 수 있다.</p>
<p>대부분의 언어에서 이미 존재하는 키에 키/값 쌍을 저장하려 하면 키는 그대로 두고 기존 값만 덮어쓴다.</p>
<h2>4-2. 자바스크립트에서의 해시 테이블</h2>
<p>해시 테이블의 구현체로 가장 단순한 것이 <strong>객체</strong>입니다.</p>
<p>자바스크립트의 참조타입인 객체는 키와 값의 쌍으로 구성된 프로퍼티의 컬렉션입니다.</p>
<p>프로퍼티 키를 알고 있다면 값에 O(1)으로 접근이 가능합니다.</p>
<pre><code>const officeSupplies = {
  pencil: 1000,
  pen: 1500,
  eraser: 500,
  ruler: 1200,
  note: 2000,
};
</code></pre>
<h3>키 값을 통해 값에 접근하는 방법</h3>
<ol>
<li>dot notation(점 표기법)</li>
<li>bracket notation(대괄호 표기법)</li>
</ol>
<h4>점 표기법</h4>
<pre><code>const officeSupplies = {
  pencil: 1000,
  pen: 1500,
  eraser: 500,
  ruler: 1200,
  note: 2000,
};

officeSupplies.pencil; // 1000
officeSupplies.pen; // 1500
officeSupplies.water; // undefined
</code></pre>
<p>존재하지 않는 키로 접근하면 undefined 가 반환됩니다.</p>
<h4>대괄호 표기법</h4>
<pre><code>const officeSupplies = {
  pencil: 1000,
  pen: 1500,
  eraser: 500,
  ruler: 1200,
  note: 2000,
};

officeSupplies["pencil"]; // 1000
officeSupplies["pen"]; // 1500

const name = "note";
officeSupplies[name]; // 2000

officeSupplies["ru" + "ler"]; // 1200
officeSupplies["-"]; // undefined
</code></pre>
<p>대괄호 안에는 어떠한 표현식도 올 수 있습니다. 따라서 변수도 사용할 수 있습니다. "-" 와 같은 일부 기호는 자바스크립트에서 유효한 식별자가 아니기 때문에 점 표기법으로는 나타낼 수 없습니다. 그럴 때는 반드시 대괄호 연산자를 사용하여야 합니다.</p>
<h3>객체에 해당 키가 존재하는지 확인하는 방법</h3>
<p>많은 분들이 해당 키의 값이 undefined 인지 확인하는 방법을 쓰곤 합니다.</p>
<pre><code>const officeSupplies = {
  pencil: 1000,
  pen: 1500,
  eraser: 500,
  ruler: 1200,
  note: 2000,
};

officeSupplies.apple; // undefined
</code></pre>
<p>그런데 만약에 "apple"의 값이 undefined 이면 어떨까요?</p>
<pre><code>const officeSupplies = {
  pencil: 1000,
  pen: 1500,
  eraser: 500,
  ruler: 1200,
  note: 2000,
  apple: undefined,
};

officeSupplies.apple; // undefined
</code></pre>
<p>값이 undefined 인 경우와 키가 존재하는지는 다른 경우이지만, 이렇게 확인하는 경우 정확하게 구분할 수가 없습니다.</p>
<p>또는 이를 boolean context에 사용하는 경우가 있습니다.</p>
<pre><code>if (!officeSupplies.coffee) {
  // 사무용품에 커피가 없다면...

  console.log("커피도 판매해주세요");
}
</code></pre>
<p>그런데 coffee의 가격이 0원이었다면?
즉, 0이라는 값이 암묵적으로 false로 변환되고 ! 연산자로 인해 true로 변환되어...</p>
<p>의외로 많이 발생하는 케이스입니다.
0, "", NaN 은 암묵적으로 false로 변환됩니다.</p>
<p>코딩테스트에서는 주로 문자열과 숫자를 다루는데, 0과 "" 이 값인 경우에 어떻게 처리할 것인지를 명확하게 나누지 않고 암묵적 형변환을 하면 이런 상황에서 디버깅이 까다로워질 수 있습니다.</p>
<pre><code>if (officeSupplies.coffee === undefined) {
}
</code></pre>
<h4><code>in</code> 연사자를 사용하는 방법</h4>
<p>in 연산자는 객체에 키가 존재하는지를 true/false로 반환합니다.</p>
<pre><code>const officeSupplies = {
  pencil: 1000,
  pen: 1500,
  eraser: 500,
  ruler: 1200,
  note: 2000,
  apple: undefined,
};

"pen" in officeSupplies; // true
"apple" in officeSupplies; // true
"banana" in officeSupplies; // false
</code></pre>
<h3>객체의 모든 키를 반환</h3>
<p>Object.prototype.keys</p>
<h3>객체의 모든 값을 반환</h3>
<p>Object.prototype.values</p>
<h3>객체의 모든 키와 값을 반환</h3>
<p>Object.prototype.entries</p>
<h3>cf. 엔트리로 객체를 구성</h3>
<p>Object.fromEntries</p>
<h4>객체는 해시테이블용으로 만들어진게 아니다</h4>
<p>객체는 해시테이블을 위해서 구현된 것이 아닙니다.
일반적인 객체 리터럴으로 객체를 생성한 경우 생성자인 Object의 prototype 객체를 프로토타입 객체로 하기 때문에, Object.prototype의 메서드에 해당하는 키와 값이 모두 존재합니다.</p>
<pre><code>"hasOwnProperty" in {}; // true

({}["isPrototypeOf"]); // [Function: isPrototypeOf]
</code></pre>
<p>즉, 제가 추가하지 않은 키와 값이 이미 추가되어 있다는 것입니다.</p>
<p>이를 해결하기 위해서 프로토타입 객체를 null 로 하여서 객체를 생성할 수 있습니다.</p>
<pre><code>
const obj = Object.create(null);

"hasOwnProperty" in obj; // false

obj.["isPrototypeOf"]; // undefined

</code></pre>
<p>하지만 번거롭지 않나요?</p>
<p>해시테이블용으로 만들어진 구현체가 있습니다.</p>
<h3>Map</h3>
<ol>
<li>
<p>Map은 어떠한 키와 값도 기본적으로 추가되어 있지 않다.</p>
</li>
<li>
<p>객체는 키값으로 문자열만 올 수 있으나 Map은 모든 타입이 다 올 수 있다. 참조타입이 오는 경우에는 참조값이 같은 경우에 같은 키로 취급한다.</p>
</li>
<li>
<p>객체는 키의 순서가 보장되지 않으나 Map은 추가한 순으로 키가 나열되는 것이 보장된다.</p>
</li>
<li>
<p>iterable-iterator protocol을 준수하기 때문에 순회가 수월하다.</p>
</li>
<li>
<p>Map은 키의 개수를 O(1)으로 알 수 있으나 객체는 O(N) 이다.</p>
</li>
<li>
<p>Map은 성능면에서도 최적화되어 있다.</p>
</li>
</ol>
<h4>사용법</h4>
<p>get
set
has
forEach
values
entries</p>
<h2>4-3. 문제풀이</h2>
<p>~~### https://www.acmicpc.net/problem/2480~~</p>
<p>~~카운트~~</p>
<h3>https://www.acmicpc.net/problem/10809</h3>
<ul>
<li>
<p>Map</p>
</li>
<li>
<p>has ? get : default vs get() || default</p>
</li>
</ul>
<h3>https://www.acmicpc.net/problem/1157</h3>
<ul>
<li>Map.prototype.values</li>
</ul>
<h3>https://www.acmicpc.net/problem/5622</h3>
<ul>
<li>객체</li>
</ul>
<h2>4-4. Set</h2>
<p>고유한 값을 저장하기 위한 자료구조</p>
<p>중복된 값을 허용하지 않는다.</p>
<p>고유한 값 => 해시 테이블의 키 를 떠올리게 된다.</p>
<p>그래서 고유한 값을 만들기 위해서 객체 또는 Map을 활용할 수 있다.</p>
<p>https://www.acmicpc.net/problem/3052</p>
<p>예시로 알아보는...</p>
<p>get
add
has
forEach
values
entries</p>
<p>https://www.acmicpc.net/problem/1316</p>
<ul>
<li>정규표현식, Set size 비교로 배열의 요소가 모두 고유한지 파악</li>
</ul>
<p>https://www.acmicpc.net/problem/3273</p>
<ul>
<li>집합. 문제를 제대로 읽기</li>
</ul>
</main><footer class="sc-a364bef7-1 hfGxXL">Copyright© 2022 All right reserved</footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"draft:js-algorithm-ch4","contentHtml":"\u003cp\u003e배열에서는 특정 값을 탐색하기 위해서는 O(N)이 소요되었다.\n데이터를 O(1) 만에 탐색할 수 있는 해시 테이블이라는 특수한 자료 구조의 사용법에 대해서 알아보자.\u003c/p\u003e\n\u003ch2\u003e4-1. 해시테이블이란?\u003c/h2\u003e\n\u003cp\u003e해시테이블은 키와 값의 쌍으로 이루어진 리스트이다. 해시테이블은 다양한 프로그래밍 언어에서 서로 다른 이름으로 불린다. 해시, 맵, 해시 맵, 딕셔너리, 연관 배열 등\u003c/p\u003e\n\u003cp\u003e해시테이블은 키를 알고 있다면 O(1)으로 해당하는 값에 접근할 수 있다는 특징이 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{\n  pencil: 1000,\n  pen: 1500,\n  eraser: 500,\n  ruler: 1200,\n  note: 2000\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003epencil 이라는 키를 알고 있다면 pencil의 가격인 1000원을 바로 알 수 있다.\u003c/p\u003e\n\u003cp\u003e어떻게 가능한 것일까?\n배열은 인덱스 값을 알고 있다면 인덱스에 위치한 값을 O(1)으로 접근할 수 있다.\u003c/p\u003e\n\u003cp\u003e따라서 각각의 키를 일정한 규칙에 따라 고유한 인덱스로 변환시킨 후 이를 배열에 저장하는 방식으로 구현할 수 있다.\u003c/p\u003e\n\u003cp\u003e입력값인 키를 유일한 인덱스로 변환하는 함수를 해시 함수라고 부른다.\n해시 함수에는 다양한 방법이 존재할 수 있다.\u003c/p\u003e\n\u003cp\u003e예를 들어, a = 1, b = 2, c = 3 ... 으로 설정한 후 문자를 숫자로 바꾼 후 각각을 더한 값을 한다.\npen 은 p = 16 e = 5 n = 14 = \u003e 16 + 5 + 14 = 35 이다\u003c/p\u003e\n\u003cp\u003e매우 큰 배열에 인덱스가 35인 위치에 값을 1500으로 한다.\u003c/p\u003e\n\u003cp\u003ehash['pen'] =\u003e hash[35] =\u003e 1500\u003c/p\u003e\n\u003cp\u003e이렇게 접근할 수 있을 것이다.\u003c/p\u003e\n\u003cp\u003e눈치가 빠르신 분들은 이미 아셨겠지만, 각 자리수의 합이 35가 나올 수 있는 경우는 매우 많다.\u003c/p\u003e\n\u003cp\u003e예를 들면 'algo' 또한 35이다.\u003c/p\u003e\n\u003cp\u003e이렇게 키를 해싱한 값이 중복되는 경우를 충돌(Collision)이라고 한다.\u003c/p\u003e\n\u003cp\u003e해시 함수가 유효하려면 딱 한 가지 기준을 충족해야 하는데, 동일한 문자열을 해시 함수에 적용할 때마다 항상 동일한 숫자로 변환해야 한다.\u003c/p\u003e\n\u003cp\u003e난수나 현재 시간을 계산에 넣어서 사용하는 해시 함수는 유효하지 않다.\u003c/p\u003e\n\u003cp\u003e'pen'을 언제 몇번을 넣더라도 항상 35로 변환되어야 한다는 뜻이다.\u003c/p\u003e\n\u003ch3\u003e충돌 해결\u003c/h3\u003e\n\u003cp\u003e충돌을 해결하기 위한 방법이 많이 있다. 고전적인 방법인 분리 연결법, 개방 주소법 등등.\u003c/p\u003e\n\u003cp\u003e다만, 대부분의 프로그래밍 언어에서 해시 테이블을 구현할 때 이를 대신 처리한다. 가장 최선의 방법으로 해결해놓았다. 코딩테스트를 푸는 입장에서는 어떻게 이러한 해시테이블을 사용할지에 조금더 초점을 맞추겠다. 어떤 충돌해결방법이 있는지는 기본적인 컴퓨터 지식이므로 각자 공부하셔야 한다. 면접 때 당연히 물어볼 수 있다. 프론트엔드에서는 잘 안물어보긴 하더라...\u003c/p\u003e\n\u003ch3\u003e단방향 룩업\u003c/h3\u003e\n\u003cp\u003e해시 테이블에서 한 단계만에 값을 찾는 기능은 그 값의 키를 알 때만 가능하다.\n키를 모른 채 값을 찾으려면 해시 테이블 내 모든 키/값 쌍을 검색하는 수밖에 없고 이는 O(N)이다.\n키를 사용해 값을 찾을 때만 O(1) 룩업이 가능하고, 거꾸로 값을 이용해 연관된 키를 찾을 때는 해시 테이블의 빠른 룩업 기능을 활용할 수 없다.\u003c/p\u003e\n\u003cp\u003e각 키는 해시 테이블에 딱 하나만 존재할 수 있으나 동일한 값은 여러개 존재할 수 있다.\u003c/p\u003e\n\u003cp\u003epencil의 가격은 유일하게 1500원이지만, 1500원짜리인 사무용품은 pencil외에도 있을 수 있다.\u003c/p\u003e\n\u003cp\u003e대부분의 언어에서 이미 존재하는 키에 키/값 쌍을 저장하려 하면 키는 그대로 두고 기존 값만 덮어쓴다.\u003c/p\u003e\n\u003ch2\u003e4-2. 자바스크립트에서의 해시 테이블\u003c/h2\u003e\n\u003cp\u003e해시 테이블의 구현체로 가장 단순한 것이 \u003cstrong\u003e객체\u003c/strong\u003e입니다.\u003c/p\u003e\n\u003cp\u003e자바스크립트의 참조타입인 객체는 키와 값의 쌍으로 구성된 프로퍼티의 컬렉션입니다.\u003c/p\u003e\n\u003cp\u003e프로퍼티 키를 알고 있다면 값에 O(1)으로 접근이 가능합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst officeSupplies = {\n  pencil: 1000,\n  pen: 1500,\n  eraser: 500,\n  ruler: 1200,\n  note: 2000,\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e키 값을 통해 값에 접근하는 방법\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003edot notation(점 표기법)\u003c/li\u003e\n\u003cli\u003ebracket notation(대괄호 표기법)\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4\u003e점 표기법\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003econst officeSupplies = {\n  pencil: 1000,\n  pen: 1500,\n  eraser: 500,\n  ruler: 1200,\n  note: 2000,\n};\n\nofficeSupplies.pencil; // 1000\nofficeSupplies.pen; // 1500\nofficeSupplies.water; // undefined\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e존재하지 않는 키로 접근하면 undefined 가 반환됩니다.\u003c/p\u003e\n\u003ch4\u003e대괄호 표기법\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003econst officeSupplies = {\n  pencil: 1000,\n  pen: 1500,\n  eraser: 500,\n  ruler: 1200,\n  note: 2000,\n};\n\nofficeSupplies[\"pencil\"]; // 1000\nofficeSupplies[\"pen\"]; // 1500\n\nconst name = \"note\";\nofficeSupplies[name]; // 2000\n\nofficeSupplies[\"ru\" + \"ler\"]; // 1200\nofficeSupplies[\"-\"]; // undefined\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e대괄호 안에는 어떠한 표현식도 올 수 있습니다. 따라서 변수도 사용할 수 있습니다. \"-\" 와 같은 일부 기호는 자바스크립트에서 유효한 식별자가 아니기 때문에 점 표기법으로는 나타낼 수 없습니다. 그럴 때는 반드시 대괄호 연산자를 사용하여야 합니다.\u003c/p\u003e\n\u003ch3\u003e객체에 해당 키가 존재하는지 확인하는 방법\u003c/h3\u003e\n\u003cp\u003e많은 분들이 해당 키의 값이 undefined 인지 확인하는 방법을 쓰곤 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst officeSupplies = {\n  pencil: 1000,\n  pen: 1500,\n  eraser: 500,\n  ruler: 1200,\n  note: 2000,\n};\n\nofficeSupplies.apple; // undefined\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런데 만약에 \"apple\"의 값이 undefined 이면 어떨까요?\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst officeSupplies = {\n  pencil: 1000,\n  pen: 1500,\n  eraser: 500,\n  ruler: 1200,\n  note: 2000,\n  apple: undefined,\n};\n\nofficeSupplies.apple; // undefined\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e값이 undefined 인 경우와 키가 존재하는지는 다른 경우이지만, 이렇게 확인하는 경우 정확하게 구분할 수가 없습니다.\u003c/p\u003e\n\u003cp\u003e또는 이를 boolean context에 사용하는 경우가 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif (!officeSupplies.coffee) {\n  // 사무용품에 커피가 없다면...\n\n  console.log(\"커피도 판매해주세요\");\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런데 coffee의 가격이 0원이었다면?\n즉, 0이라는 값이 암묵적으로 false로 변환되고 ! 연산자로 인해 true로 변환되어...\u003c/p\u003e\n\u003cp\u003e의외로 많이 발생하는 케이스입니다.\n0, \"\", NaN 은 암묵적으로 false로 변환됩니다.\u003c/p\u003e\n\u003cp\u003e코딩테스트에서는 주로 문자열과 숫자를 다루는데, 0과 \"\" 이 값인 경우에 어떻게 처리할 것인지를 명확하게 나누지 않고 암묵적 형변환을 하면 이런 상황에서 디버깅이 까다로워질 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif (officeSupplies.coffee === undefined) {\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003ccode\u003ein\u003c/code\u003e 연사자를 사용하는 방법\u003c/h4\u003e\n\u003cp\u003ein 연산자는 객체에 키가 존재하는지를 true/false로 반환합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst officeSupplies = {\n  pencil: 1000,\n  pen: 1500,\n  eraser: 500,\n  ruler: 1200,\n  note: 2000,\n  apple: undefined,\n};\n\n\"pen\" in officeSupplies; // true\n\"apple\" in officeSupplies; // true\n\"banana\" in officeSupplies; // false\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e객체의 모든 키를 반환\u003c/h3\u003e\n\u003cp\u003eObject.prototype.keys\u003c/p\u003e\n\u003ch3\u003e객체의 모든 값을 반환\u003c/h3\u003e\n\u003cp\u003eObject.prototype.values\u003c/p\u003e\n\u003ch3\u003e객체의 모든 키와 값을 반환\u003c/h3\u003e\n\u003cp\u003eObject.prototype.entries\u003c/p\u003e\n\u003ch3\u003ecf. 엔트리로 객체를 구성\u003c/h3\u003e\n\u003cp\u003eObject.fromEntries\u003c/p\u003e\n\u003ch4\u003e객체는 해시테이블용으로 만들어진게 아니다\u003c/h4\u003e\n\u003cp\u003e객체는 해시테이블을 위해서 구현된 것이 아닙니다.\n일반적인 객체 리터럴으로 객체를 생성한 경우 생성자인 Object의 prototype 객체를 프로토타입 객체로 하기 때문에, Object.prototype의 메서드에 해당하는 키와 값이 모두 존재합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\"hasOwnProperty\" in {}; // true\n\n({}[\"isPrototypeOf\"]); // [Function: isPrototypeOf]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e즉, 제가 추가하지 않은 키와 값이 이미 추가되어 있다는 것입니다.\u003c/p\u003e\n\u003cp\u003e이를 해결하기 위해서 프로토타입 객체를 null 로 하여서 객체를 생성할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\nconst obj = Object.create(null);\n\n\"hasOwnProperty\" in obj; // false\n\nobj.[\"isPrototypeOf\"]; // undefined\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e하지만 번거롭지 않나요?\u003c/p\u003e\n\u003cp\u003e해시테이블용으로 만들어진 구현체가 있습니다.\u003c/p\u003e\n\u003ch3\u003eMap\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eMap은 어떠한 키와 값도 기본적으로 추가되어 있지 않다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e객체는 키값으로 문자열만 올 수 있으나 Map은 모든 타입이 다 올 수 있다. 참조타입이 오는 경우에는 참조값이 같은 경우에 같은 키로 취급한다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e객체는 키의 순서가 보장되지 않으나 Map은 추가한 순으로 키가 나열되는 것이 보장된다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eiterable-iterator protocol을 준수하기 때문에 순회가 수월하다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMap은 키의 개수를 O(1)으로 알 수 있으나 객체는 O(N) 이다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMap은 성능면에서도 최적화되어 있다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4\u003e사용법\u003c/h4\u003e\n\u003cp\u003eget\nset\nhas\nforEach\nvalues\nentries\u003c/p\u003e\n\u003ch2\u003e4-3. 문제풀이\u003c/h2\u003e\n\u003cp\u003e~~### https://www.acmicpc.net/problem/2480~~\u003c/p\u003e\n\u003cp\u003e~~카운트~~\u003c/p\u003e\n\u003ch3\u003ehttps://www.acmicpc.net/problem/10809\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eMap\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ehas ? get : default vs get() || default\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003ehttps://www.acmicpc.net/problem/1157\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMap.prototype.values\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003ehttps://www.acmicpc.net/problem/5622\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e객체\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e4-4. Set\u003c/h2\u003e\n\u003cp\u003e고유한 값을 저장하기 위한 자료구조\u003c/p\u003e\n\u003cp\u003e중복된 값을 허용하지 않는다.\u003c/p\u003e\n\u003cp\u003e고유한 값 =\u003e 해시 테이블의 키 를 떠올리게 된다.\u003c/p\u003e\n\u003cp\u003e그래서 고유한 값을 만들기 위해서 객체 또는 Map을 활용할 수 있다.\u003c/p\u003e\n\u003cp\u003ehttps://www.acmicpc.net/problem/3052\u003c/p\u003e\n\u003cp\u003e예시로 알아보는...\u003c/p\u003e\n\u003cp\u003eget\nadd\nhas\nforEach\nvalues\nentries\u003c/p\u003e\n\u003cp\u003ehttps://www.acmicpc.net/problem/1316\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e정규표현식, Set size 비교로 배열의 요소가 모두 고유한지 파악\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ehttps://www.acmicpc.net/problem/3273\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e집합. 문제를 제대로 읽기\u003c/li\u003e\n\u003c/ul\u003e\n","title":"Ch04. 해시테이블","date":"2020-03-13","summary":"해시테이블: 객체, Map, Set"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"draft:js-algorithm-ch4"},"buildId":"Yp9dDFoGJHjN8zU7XV6TC","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>