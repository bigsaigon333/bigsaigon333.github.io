<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><title>Ch04. 해시테이블</title><meta name="next-head-count" content="3"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/_next/static/css/9d33c709da292899.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d33c709da292899.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f8a3b6767a48f6a5.js" defer=""></script><script src="/_next/static/chunks/641-91ae8bb3644174ea.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-3df0fe811b81fef9.js" defer=""></script><script src="/_next/static/ixvRORGkhpVcTgFEK-o9r/_buildManifest.js" defer=""></script><script src="/_next/static/ixvRORGkhpVcTgFEK-o9r/_ssgManifest.js" defer=""></script><script src="/_next/static/ixvRORGkhpVcTgFEK-o9r/_middlewareManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.3">*,::before,::after{box-sizing:border-box;}/*!sc*/
[hidden]{display:none;}/*!sc*/
h1{margin:0.67em 0;font-size:2rem;}/*!sc*/
h2{font-size:1.5rem;}/*!sc*/
h3{font-size:1.17rem;}/*!sc*/
h4{font-size:1rem;}/*!sc*/
h5{font-size:0.83rem;}/*!sc*/
h6{font-size:0.67rem;}/*!sc*/
pre{white-space:pre-wrap;}/*!sc*/
hr{border-style:solid;border-width:1px 0 0;color:inherit;height:0;overflow:visible;}/*!sc*/
img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle;max-width:100%;}/*!sc*/
picture{display:contents;}/*!sc*/
source{display:none;}/*!sc*/
img,svg,video,canvas{height:auto;}/*!sc*/
audio{width:100%;}/*!sc*/
audio:not([controls]){display:none;}/*!sc*/
img{border-style:none;}/*!sc*/
svg{overflow:hidden;}/*!sc*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block;}/*!sc*/
[type="checkbox"],[type="radio"]{box-sizing:border-box;padding:0;}/*!sc*/
html,body{padding:0;margin:0;font-family:-apple-system,BlinkMacSystemFont,"Apple SD Gothic Neo","Malgun Gothic","맑은 고딕","나눔고딕","Nanum Gothic","Noto Sans KR","Noto Sans CJK KR",arial,"돋움",Dotum,Tahoma,Geneva,"Helvetica Neue",sans-serif;}/*!sc*/
a{color:inherit;-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
code[class*=language-],pre[class*=language-]{font-family:"Source Code Pro",Consolas,Menlo,Monaco,Courier New,monospace;font-size:0.825rem;}/*!sc*/
data-styled.g1[id="sc-global-jkJdhN1"]{content:"sc-global-jkJdhN1,"}/*!sc*/
.jzwiwO{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;width:100%;}/*!sc*/
data-styled.g2[id="sc-6d17420c-0"]{content:"jzwiwO,"}/*!sc*/
.hCxheK{margin:0;line-height:1.25;width:100%;font-weight:800;}/*!sc*/
data-styled.g3[id="sc-6d17420c-1"]{content:"hCxheK,"}/*!sc*/
.deSAmu{width:100%;font-size:3.6rem;text-align:center;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-column-gap:2rem;column-gap:2rem;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}/*!sc*/
.deSAmu:hover p span{box-shadow:0 0.25rem 0 0 black;}/*!sc*/
@media (max-width:767px){.deSAmu{font-size:9vw;-webkit-column-gap:1rem;column-gap:1rem;}}/*!sc*/
data-styled.g4[id="sc-6d17420c-2"]{content:"deSAmu,"}/*!sc*/
.iMxutK{position:relative;overflow:hidden;border-radius:35%;width:25%;padding-bottom:25%;}/*!sc*/
@media (max-width:600px){.iMxutK{width:20%;padding-bottom:20%;}}/*!sc*/
data-styled.g5[id="sc-6d17420c-3"]{content:"iMxutK,"}/*!sc*/
.hunNUo{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;}/*!sc*/
data-styled.g6[id="sc-6d17420c-4"]{content:"hunNUo,"}/*!sc*/
.jzrTAN{min-height:100vh;padding:3rem 2rem 0;-webkit-flex:1;-ms-flex:1;flex:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:flex-start;-webkit-box-align:flex-start;-ms-flex-align:flex-start;align-items:flex-start;row-gap:2rem;max-width:768px;margin:auto;}/*!sc*/
@media (max-width:600px){.jzrTAN{padding:2rem 1rem 0;}}/*!sc*/
data-styled.g10[id="sc-436a7e6d-0"]{content:"jzrTAN,"}/*!sc*/
.fCWfQB{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;width:100%;padding:2rem 0 1rem;border-top:1px solid #eaeaea;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}/*!sc*/
data-styled.g11[id="sc-436a7e6d-1"]{content:"fCWfQB,"}/*!sc*/
.kLhcQd h2{font-size:2.5rem;margin:0 0 0.5rem;font-weight:800;}/*!sc*/
@media (max-width:600px){.kLhcQd h2{font-size:2rem;}}/*!sc*/
@media (max-width:375px){.kLhcQd h2{font-size:1.5rem;}}/*!sc*/
.kLhcQd time{font-size:1rem;}/*!sc*/
.kLhcQd p{font-size:1.25rem;line-height:1.75rem;}/*!sc*/
data-styled.g13[id="sc-564a7b06-1"]{content:"kLhcQd,"}/*!sc*/
.lmqIuX{width:100%;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;line-height:1.75;}/*!sc*/
.lmqIuX a{word-break:break-word;}/*!sc*/
.lmqIuX a:hover{box-shadow:0 0.125rem 0 0 black;}/*!sc*/
.lmqIuX ul{margin:0;padding-inline-start:20px;}/*!sc*/
.lmqIuX :not(pre) > code{border-radius:0.3em;background:rgb(255 229 100 / 20%);color:#1a1a1a;padding:0.15em 0.2em 0.05em;white-space:normal;}/*!sc*/
.lmqIuX details > summary{cursor:pointer;}/*!sc*/
.lmqIuX blockquote{margin:0 1.75rem 1.75rem -1.75rem;padding:0 0 0 1.25rem;font-size:1.25rem;line-height:1.75rem;color:inherit;font-style:italic;border-left:0.3281rem solid hsl(0deg 0% 0% / 90%);border-left-color:inherit;opacity:0.8;}/*!sc*/
.lmqIuX table{display:block;width:100%;width:-webkit-max-content;width:-moz-max-content;width:max-content;max-width:100%;overflow:auto;margin-top:0;margin-bottom:1rem;border-spacing:0;border-collapse:collapse;}/*!sc*/
.lmqIuX table tr{border-top:1px solid hsl(210deg 18% 87% / 100%);}/*!sc*/
.lmqIuX table tr:nth-child(2n){background-color:#f6f8fa;}/*!sc*/
.lmqIuX table th{font-weight:600;}/*!sc*/
.lmqIuX table th,.lmqIuX table td{padding:6px 13px;border:1px solid #d0d7de;}/*!sc*/
data-styled.g14[id="sc-863196f3-0"]{content:"lmqIuX,"}/*!sc*/
</style><style data-href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap">@font-face{font-family:'Source Code Pro';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/sourcecodepro/v21/HI_diYsKILxRpg3hIP6sJ7fM7PqPMcMnZFqUwX28DMyQhM0.woff) format('woff')}@font-face{font-family:'Source Code Pro';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/sourcecodepro/v21/HI_diYsKILxRpg3hIP6sJ7fM7PqPMcMnZFqUwX28DMyQtMRrSlcZZJmOpwVS.woff) format('woff');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Source Code Pro';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/sourcecodepro/v21/HI_diYsKILxRpg3hIP6sJ7fM7PqPMcMnZFqUwX28DMyQtM1rSlcZZJmOpwVS.woff) format('woff');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Source Code Pro';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/sourcecodepro/v21/HI_diYsKILxRpg3hIP6sJ7fM7PqPMcMnZFqUwX28DMyQtMVrSlcZZJmOpwVS.woff) format('woff');unicode-range:U+1F00-1FFF}@font-face{font-family:'Source Code Pro';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/sourcecodepro/v21/HI_diYsKILxRpg3hIP6sJ7fM7PqPMcMnZFqUwX28DMyQtMprSlcZZJmOpwVS.woff) format('woff');unicode-range:U+0370-03FF}@font-face{font-family:'Source Code Pro';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/sourcecodepro/v21/HI_diYsKILxRpg3hIP6sJ7fM7PqPMcMnZFqUwX28DMyQtMZrSlcZZJmOpwVS.woff) format('woff');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Source Code Pro';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/sourcecodepro/v21/HI_diYsKILxRpg3hIP6sJ7fM7PqPMcMnZFqUwX28DMyQtMdrSlcZZJmOpwVS.woff) format('woff');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Source Code Pro';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/sourcecodepro/v21/HI_diYsKILxRpg3hIP6sJ7fM7PqPMcMnZFqUwX28DMyQtMlrSlcZZJmOpw.woff) format('woff');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next" data-reactroot=""><div class="sc-436a7e6d-0 jzrTAN"><header class="sc-6d17420c-0 jzwiwO"><h1 class="sc-6d17420c-1 hCxheK"><a href="/" class="sc-6d17420c-2 deSAmu"><div class="sc-6d17420c-3 iMxutK"><picture><source srcSet="/profile.webp" type="image/webp"/><img src="/profile.jpg" alt="프로필" class="sc-6d17420c-4 hunNUo"/></picture></div><div><span>프론트엔드 개발자</span><br/><span>김동희입니다</span></div></a></h1></header><article class="sc-564a7b06-1 kLhcQd"><h2>Ch04. 해시테이블</h2><time>2020-03-13</time></article><main class="sc-863196f3-0 lmqIuX"><p>배열에서는 특정 값을 탐색하기 위해서는 O(N)이 소요되었다.
데이터를 O(1) 만에 탐색할 수 있는 해시 테이블이라는 특수한 자료 구조의 사용법에 대해서 알아보자.</p>
<h2>4-1. 해시테이블이란?</h2>
<p>해시테이블은 키와 값의 쌍으로 이루어진 리스트이다. 해시테이블은 다양한 프로그래밍 언어에서 서로 다른 이름으로 불린다. 해시, 맵, 해시 맵, 딕셔너리, 연관 배열 등</p>
<p>해시테이블은 키를 알고 있다면 O(1)으로 해당하는 값에 접근할 수 있다는 특징이 있다.</p>
<pre><code class="hljs language-js">{
  <span class="hljs-attr">pencil</span>: <span class="hljs-number">1000</span>,
  <span class="hljs-attr">pen</span>: <span class="hljs-number">1500</span>,
  <span class="hljs-attr">eraser</span>: <span class="hljs-number">500</span>,
  <span class="hljs-attr">ruler</span>: <span class="hljs-number">1200</span>,
  <span class="hljs-attr">note</span>: <span class="hljs-number">2000</span>
}
</code></pre>
<p>pencil 이라는 키를 알고 있다면 pencil의 가격인 1000원을 바로 알 수 있다.</p>
<p>어떻게 가능한 것일까?
배열은 인덱스 값을 알고 있다면 인덱스에 위치한 값을 O(1)으로 접근할 수 있다.</p>
<p>따라서 각각의 키를 일정한 규칙에 따라 고유한 인덱스로 변환시킨 후 이를 배열에 저장하는 방식으로 구현할 수 있다.</p>
<p>입력값인 키를 유일한 인덱스로 변환하는 함수를 해시 함수라고 부른다.
해시 함수에는 다양한 방법이 존재할 수 있다.</p>
<p>예를 들어, a = 1, b = 2, c = 3 ... 으로 설정한 후 문자를 숫자로 바꾼 후 각각을 더한 값을 한다.
pen 은 p = 16 e = 5 n = 14 = > 16 + 5 + 14 = 35 이다</p>
<p>매우 큰 배열에 인덱스가 35인 위치에 값을 1500으로 한다.</p>
<p>hash['pen'] => hash[35] => 1500</p>
<p>이렇게 접근할 수 있을 것이다.</p>
<p>눈치가 빠르신 분들은 이미 아셨겠지만, 각 자리수의 합이 35가 나올 수 있는 경우는 매우 많다.</p>
<p>예를 들면 'algo' 또한 35이다.</p>
<p>이렇게 키를 해싱한 값이 중복되는 경우를 충돌(Collision)이라고 한다.</p>
<p>해시 함수가 유효하려면 딱 한 가지 기준을 충족해야 하는데, 동일한 문자열을 해시 함수에 적용할 때마다 항상 동일한 숫자로 변환해야 한다.</p>
<p>난수나 현재 시간을 계산에 넣어서 사용하는 해시 함수는 유효하지 않다.</p>
<p>'pen'을 언제 몇번을 넣더라도 항상 35로 변환되어야 한다는 뜻이다.</p>
<h3>충돌 해결</h3>
<p>충돌을 해결하기 위한 방법이 많이 있다. 고전적인 방법인 분리 연결법, 개방 주소법 등등.</p>
<p>다만, 대부분의 프로그래밍 언어에서 해시 테이블을 구현할 때 이를 대신 처리한다. 가장 최선의 방법으로 해결해놓았다. 코딩테스트를 푸는 입장에서는 어떻게 이러한 해시테이블을 사용할지에 조금더 초점을 맞추겠다. 어떤 충돌해결방법이 있는지는 기본적인 컴퓨터 지식이므로 각자 공부하셔야 한다. 면접 때 당연히 물어볼 수 있다. 프론트엔드에서는 잘 안물어보긴 하더라...</p>
<h3>단방향 룩업</h3>
<p>해시 테이블에서 한 단계만에 값을 찾는 기능은 그 값의 키를 알 때만 가능하다.
키를 모른 채 값을 찾으려면 해시 테이블 내 모든 키/값 쌍을 검색하는 수밖에 없고 이는 O(N)이다.
키를 사용해 값을 찾을 때만 O(1) 룩업이 가능하고, 거꾸로 값을 이용해 연관된 키를 찾을 때는 해시 테이블의 빠른 룩업 기능을 활용할 수 없다.</p>
<p>각 키는 해시 테이블에 딱 하나만 존재할 수 있으나 동일한 값은 여러개 존재할 수 있다.</p>
<p>pencil의 가격은 유일하게 1500원이지만, 1500원짜리인 사무용품은 pencil외에도 있을 수 있다.</p>
<p>대부분의 언어에서 이미 존재하는 키에 키/값 쌍을 저장하려 하면 키는 그대로 두고 기존 값만 덮어쓴다.</p>
<h2>4-2. 자바스크립트에서의 해시 테이블</h2>
<p>해시 테이블의 구현체로 가장 단순한 것이 <strong>객체</strong>입니다.</p>
<p>자바스크립트의 참조타입인 객체는 키와 값의 쌍으로 구성된 프로퍼티의 컬렉션입니다.</p>
<p>프로퍼티 키를 알고 있다면 값에 O(1)으로 접근이 가능합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> officeSupplies = {
  <span class="hljs-attr">pencil</span>: <span class="hljs-number">1000</span>,
  <span class="hljs-attr">pen</span>: <span class="hljs-number">1500</span>,
  <span class="hljs-attr">eraser</span>: <span class="hljs-number">500</span>,
  <span class="hljs-attr">ruler</span>: <span class="hljs-number">1200</span>,
  <span class="hljs-attr">note</span>: <span class="hljs-number">2000</span>,
};
</code></pre>
<h3>키 값을 통해 값에 접근하는 방법</h3>
<ol>
<li>dot notation(점 표기법)</li>
<li>bracket notation(대괄호 표기법)</li>
</ol>
<h4>점 표기법</h4>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> officeSupplies = {
  <span class="hljs-attr">pencil</span>: <span class="hljs-number">1000</span>,
  <span class="hljs-attr">pen</span>: <span class="hljs-number">1500</span>,
  <span class="hljs-attr">eraser</span>: <span class="hljs-number">500</span>,
  <span class="hljs-attr">ruler</span>: <span class="hljs-number">1200</span>,
  <span class="hljs-attr">note</span>: <span class="hljs-number">2000</span>,
};

officeSupplies.<span class="hljs-property">pencil</span>; <span class="hljs-comment">// 1000</span>
officeSupplies.<span class="hljs-property">pen</span>; <span class="hljs-comment">// 1500</span>
officeSupplies.<span class="hljs-property">water</span>; <span class="hljs-comment">// undefined</span>
</code></pre>
<p>존재하지 않는 키로 접근하면 undefined 가 반환됩니다.</p>
<h4>대괄호 표기법</h4>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> officeSupplies = {
  <span class="hljs-attr">pencil</span>: <span class="hljs-number">1000</span>,
  <span class="hljs-attr">pen</span>: <span class="hljs-number">1500</span>,
  <span class="hljs-attr">eraser</span>: <span class="hljs-number">500</span>,
  <span class="hljs-attr">ruler</span>: <span class="hljs-number">1200</span>,
  <span class="hljs-attr">note</span>: <span class="hljs-number">2000</span>,
};

officeSupplies[<span class="hljs-string">"pencil"</span>]; <span class="hljs-comment">// 1000</span>
officeSupplies[<span class="hljs-string">"pen"</span>]; <span class="hljs-comment">// 1500</span>

<span class="hljs-keyword">const</span> name = <span class="hljs-string">"note"</span>;
officeSupplies[name]; <span class="hljs-comment">// 2000</span>

officeSupplies[<span class="hljs-string">"ru"</span> + <span class="hljs-string">"ler"</span>]; <span class="hljs-comment">// 1200</span>
officeSupplies[<span class="hljs-string">"-"</span>]; <span class="hljs-comment">// undefined</span>
</code></pre>
<p>대괄호 안에는 어떠한 표현식도 올 수 있습니다. 따라서 변수도 사용할 수 있습니다. "-" 와 같은 일부 기호는 자바스크립트에서 유효한 식별자가 아니기 때문에 점 표기법으로는 나타낼 수 없습니다. 그럴 때는 반드시 대괄호 연산자를 사용하여야 합니다.</p>
<h3>객체에 해당 키가 존재하는지 확인하는 방법</h3>
<p>많은 분들이 해당 키의 값이 undefined 인지 확인하는 방법을 쓰곤 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> officeSupplies = {
  <span class="hljs-attr">pencil</span>: <span class="hljs-number">1000</span>,
  <span class="hljs-attr">pen</span>: <span class="hljs-number">1500</span>,
  <span class="hljs-attr">eraser</span>: <span class="hljs-number">500</span>,
  <span class="hljs-attr">ruler</span>: <span class="hljs-number">1200</span>,
  <span class="hljs-attr">note</span>: <span class="hljs-number">2000</span>,
};

officeSupplies.<span class="hljs-property">apple</span>; <span class="hljs-comment">// undefined</span>
</code></pre>
<p>그런데 만약에 "apple"의 값이 undefined 이면 어떨까요?</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> officeSupplies = {
  <span class="hljs-attr">pencil</span>: <span class="hljs-number">1000</span>,
  <span class="hljs-attr">pen</span>: <span class="hljs-number">1500</span>,
  <span class="hljs-attr">eraser</span>: <span class="hljs-number">500</span>,
  <span class="hljs-attr">ruler</span>: <span class="hljs-number">1200</span>,
  <span class="hljs-attr">note</span>: <span class="hljs-number">2000</span>,
  <span class="hljs-attr">apple</span>: <span class="hljs-literal">undefined</span>,
};

officeSupplies.<span class="hljs-property">apple</span>; <span class="hljs-comment">// undefined</span>
</code></pre>
<p>값이 undefined 인 경우와 키가 존재하는지는 다른 경우이지만, 이렇게 확인하는 경우 정확하게 구분할 수가 없습니다.</p>
<p>또는 이를 boolean context에 사용하는 경우가 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (!officeSupplies.<span class="hljs-property">coffee</span>) {
  <span class="hljs-comment">// 사무용품에 커피가 없다면...</span>

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"커피도 판매해주세요"</span>);
}
</code></pre>
<p>그런데 coffee의 가격이 0원이었다면?
즉, 0이라는 값이 암묵적으로 false로 변환되고 ! 연산자로 인해 true로 변환되어...</p>
<p>의외로 많이 발생하는 케이스입니다.
0, "", NaN 은 암묵적으로 false로 변환됩니다.</p>
<p>코딩테스트에서는 주로 문자열과 숫자를 다루는데, 0과 "" 이 값인 경우에 어떻게 처리할 것인지를 명확하게 나누지 않고 암묵적 형변환을 하면 이런 상황에서 디버깅이 까다로워질 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (officeSupplies.<span class="hljs-property">coffee</span> === <span class="hljs-literal">undefined</span>) {
}
</code></pre>
<h4><code>in</code> 연사자를 사용하는 방법</h4>
<p>in 연산자는 객체에 키가 존재하는지를 true/false로 반환합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> officeSupplies = {
  <span class="hljs-attr">pencil</span>: <span class="hljs-number">1000</span>,
  <span class="hljs-attr">pen</span>: <span class="hljs-number">1500</span>,
  <span class="hljs-attr">eraser</span>: <span class="hljs-number">500</span>,
  <span class="hljs-attr">ruler</span>: <span class="hljs-number">1200</span>,
  <span class="hljs-attr">note</span>: <span class="hljs-number">2000</span>,
  <span class="hljs-attr">apple</span>: <span class="hljs-literal">undefined</span>,
};

<span class="hljs-string">"pen"</span> <span class="hljs-keyword">in</span> officeSupplies; <span class="hljs-comment">// true</span>
<span class="hljs-string">"apple"</span> <span class="hljs-keyword">in</span> officeSupplies; <span class="hljs-comment">// true</span>
<span class="hljs-string">"banana"</span> <span class="hljs-keyword">in</span> officeSupplies; <span class="hljs-comment">// false</span>
</code></pre>
<h3>객체의 모든 키를 반환</h3>
<p>Object.prototype.keys</p>
<h3>객체의 모든 값을 반환</h3>
<p>Object.prototype.values</p>
<h3>객체의 모든 키와 값을 반환</h3>
<p>Object.prototype.entries</p>
<h3>cf. 엔트리로 객체를 구성</h3>
<p>Object.fromEntries</p>
<h4>객체는 해시테이블용으로 만들어진게 아니다</h4>
<p>객체는 해시테이블을 위해서 구현된 것이 아닙니다.
일반적인 객체 리터럴으로 객체를 생성한 경우 생성자인 Object의 prototype 객체를 프로토타입 객체로 하기 때문에, Object.prototype의 메서드에 해당하는 키와 값이 모두 존재합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-string">"hasOwnProperty"</span> <span class="hljs-keyword">in</span> {}; <span class="hljs-comment">// true</span>

({}[<span class="hljs-string">"isPrototypeOf"</span>]); <span class="hljs-comment">// [Function: isPrototypeOf]</span>
</code></pre>
<p>즉, 제가 추가하지 않은 키와 값이 이미 추가되어 있다는 것입니다.</p>
<p>이를 해결하기 위해서 프로토타입 객체를 null 로 하여서 객체를 생성할 수 있습니다.</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);

<span class="hljs-string">"hasOwnProperty"</span> <span class="hljs-keyword">in</span> obj; <span class="hljs-comment">// false</span>

obj.[<span class="hljs-string">"isPrototypeOf"</span>]; <span class="hljs-comment">// undefined</span>

</code></pre>
<p>하지만 번거롭지 않나요?</p>
<p>해시테이블용으로 만들어진 구현체가 있습니다.</p>
<h3>Map</h3>
<ol>
<li>
<p>Map은 어떠한 키와 값도 기본적으로 추가되어 있지 않다.</p>
</li>
<li>
<p>객체는 키값으로 문자열만 올 수 있으나 Map은 모든 타입이 다 올 수 있다. 참조타입이 오는 경우에는 참조값이 같은 경우에 같은 키로 취급한다.</p>
</li>
<li>
<p>객체는 키의 순서가 보장되지 않으나 Map은 추가한 순으로 키가 나열되는 것이 보장된다.</p>
</li>
<li>
<p>iterable-iterator protocol을 준수하기 때문에 순회가 수월하다.</p>
</li>
<li>
<p>Map은 키의 개수를 O(1)으로 알 수 있으나 객체는 O(N) 이다.</p>
</li>
<li>
<p>Map은 성능면에서도 최적화되어 있다.</p>
</li>
</ol>
<h4>사용법</h4>
<p>get
set
has
forEach
values
entries</p>
<h2>4-3. 문제풀이</h2>
<p><del>### <a href="https://www.acmicpc.net/problem/2480">https://www.acmicpc.net/problem/2480</a></del></p>
<p><del>카운트</del></p>
<h3><a href="https://www.acmicpc.net/problem/10809">https://www.acmicpc.net/problem/10809</a></h3>
<ul>
<li>
<p>Map</p>
</li>
<li>
<p>has ? get : default vs get() || default</p>
</li>
</ul>
<h3><a href="https://www.acmicpc.net/problem/1157">https://www.acmicpc.net/problem/1157</a></h3>
<ul>
<li>Map.prototype.values</li>
</ul>
<h3><a href="https://www.acmicpc.net/problem/5622">https://www.acmicpc.net/problem/5622</a></h3>
<ul>
<li>객체</li>
</ul>
<h2>4-4. Set</h2>
<p>고유한 값을 저장하기 위한 자료구조</p>
<p>중복된 값을 허용하지 않는다.</p>
<p>고유한 값 => 해시 테이블의 키 를 떠올리게 된다.</p>
<p>그래서 고유한 값을 만들기 위해서 객체 또는 Map을 활용할 수 있다.</p>
<p><a href="https://www.acmicpc.net/problem/3052">https://www.acmicpc.net/problem/3052</a></p>
<p>예시로 알아보는...</p>
<p>get
add
has
forEach
values
entries</p>
<p><a href="https://www.acmicpc.net/problem/1316">https://www.acmicpc.net/problem/1316</a></p>
<ul>
<li>정규표현식, Set size 비교로 배열의 요소가 모두 고유한지 파악</li>
</ul>
<p><a href="https://www.acmicpc.net/problem/3273">https://www.acmicpc.net/problem/3273</a></p>
<ul>
<li>집합. 문제를 제대로 읽기</li>
</ul></main><div></div><footer class="sc-436a7e6d-1 fCWfQB">Copyright© 2022 All right reserved</footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"draft:js-algorithm-ch4","contentHtml":"\u003cp\u003e배열에서는 특정 값을 탐색하기 위해서는 O(N)이 소요되었다.\n데이터를 O(1) 만에 탐색할 수 있는 해시 테이블이라는 특수한 자료 구조의 사용법에 대해서 알아보자.\u003c/p\u003e\n\u003ch2\u003e4-1. 해시테이블이란?\u003c/h2\u003e\n\u003cp\u003e해시테이블은 키와 값의 쌍으로 이루어진 리스트이다. 해시테이블은 다양한 프로그래밍 언어에서 서로 다른 이름으로 불린다. 해시, 맵, 해시 맵, 딕셔너리, 연관 배열 등\u003c/p\u003e\n\u003cp\u003e해시테이블은 키를 알고 있다면 O(1)으로 해당하는 값에 접근할 수 있다는 특징이 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\n  \u003cspan class=\"hljs-attr\"\u003epencil\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003epen\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1500\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eeraser\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eruler\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1200\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003enote\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003epencil 이라는 키를 알고 있다면 pencil의 가격인 1000원을 바로 알 수 있다.\u003c/p\u003e\n\u003cp\u003e어떻게 가능한 것일까?\n배열은 인덱스 값을 알고 있다면 인덱스에 위치한 값을 O(1)으로 접근할 수 있다.\u003c/p\u003e\n\u003cp\u003e따라서 각각의 키를 일정한 규칙에 따라 고유한 인덱스로 변환시킨 후 이를 배열에 저장하는 방식으로 구현할 수 있다.\u003c/p\u003e\n\u003cp\u003e입력값인 키를 유일한 인덱스로 변환하는 함수를 해시 함수라고 부른다.\n해시 함수에는 다양한 방법이 존재할 수 있다.\u003c/p\u003e\n\u003cp\u003e예를 들어, a = 1, b = 2, c = 3 ... 으로 설정한 후 문자를 숫자로 바꾼 후 각각을 더한 값을 한다.\npen 은 p = 16 e = 5 n = 14 = \u003e 16 + 5 + 14 = 35 이다\u003c/p\u003e\n\u003cp\u003e매우 큰 배열에 인덱스가 35인 위치에 값을 1500으로 한다.\u003c/p\u003e\n\u003cp\u003ehash['pen'] =\u003e hash[35] =\u003e 1500\u003c/p\u003e\n\u003cp\u003e이렇게 접근할 수 있을 것이다.\u003c/p\u003e\n\u003cp\u003e눈치가 빠르신 분들은 이미 아셨겠지만, 각 자리수의 합이 35가 나올 수 있는 경우는 매우 많다.\u003c/p\u003e\n\u003cp\u003e예를 들면 'algo' 또한 35이다.\u003c/p\u003e\n\u003cp\u003e이렇게 키를 해싱한 값이 중복되는 경우를 충돌(Collision)이라고 한다.\u003c/p\u003e\n\u003cp\u003e해시 함수가 유효하려면 딱 한 가지 기준을 충족해야 하는데, 동일한 문자열을 해시 함수에 적용할 때마다 항상 동일한 숫자로 변환해야 한다.\u003c/p\u003e\n\u003cp\u003e난수나 현재 시간을 계산에 넣어서 사용하는 해시 함수는 유효하지 않다.\u003c/p\u003e\n\u003cp\u003e'pen'을 언제 몇번을 넣더라도 항상 35로 변환되어야 한다는 뜻이다.\u003c/p\u003e\n\u003ch3\u003e충돌 해결\u003c/h3\u003e\n\u003cp\u003e충돌을 해결하기 위한 방법이 많이 있다. 고전적인 방법인 분리 연결법, 개방 주소법 등등.\u003c/p\u003e\n\u003cp\u003e다만, 대부분의 프로그래밍 언어에서 해시 테이블을 구현할 때 이를 대신 처리한다. 가장 최선의 방법으로 해결해놓았다. 코딩테스트를 푸는 입장에서는 어떻게 이러한 해시테이블을 사용할지에 조금더 초점을 맞추겠다. 어떤 충돌해결방법이 있는지는 기본적인 컴퓨터 지식이므로 각자 공부하셔야 한다. 면접 때 당연히 물어볼 수 있다. 프론트엔드에서는 잘 안물어보긴 하더라...\u003c/p\u003e\n\u003ch3\u003e단방향 룩업\u003c/h3\u003e\n\u003cp\u003e해시 테이블에서 한 단계만에 값을 찾는 기능은 그 값의 키를 알 때만 가능하다.\n키를 모른 채 값을 찾으려면 해시 테이블 내 모든 키/값 쌍을 검색하는 수밖에 없고 이는 O(N)이다.\n키를 사용해 값을 찾을 때만 O(1) 룩업이 가능하고, 거꾸로 값을 이용해 연관된 키를 찾을 때는 해시 테이블의 빠른 룩업 기능을 활용할 수 없다.\u003c/p\u003e\n\u003cp\u003e각 키는 해시 테이블에 딱 하나만 존재할 수 있으나 동일한 값은 여러개 존재할 수 있다.\u003c/p\u003e\n\u003cp\u003epencil의 가격은 유일하게 1500원이지만, 1500원짜리인 사무용품은 pencil외에도 있을 수 있다.\u003c/p\u003e\n\u003cp\u003e대부분의 언어에서 이미 존재하는 키에 키/값 쌍을 저장하려 하면 키는 그대로 두고 기존 값만 덮어쓴다.\u003c/p\u003e\n\u003ch2\u003e4-2. 자바스크립트에서의 해시 테이블\u003c/h2\u003e\n\u003cp\u003e해시 테이블의 구현체로 가장 단순한 것이 \u003cstrong\u003e객체\u003c/strong\u003e입니다.\u003c/p\u003e\n\u003cp\u003e자바스크립트의 참조타입인 객체는 키와 값의 쌍으로 구성된 프로퍼티의 컬렉션입니다.\u003c/p\u003e\n\u003cp\u003e프로퍼티 키를 알고 있다면 값에 O(1)으로 접근이 가능합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e officeSupplies = {\n  \u003cspan class=\"hljs-attr\"\u003epencil\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003epen\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1500\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eeraser\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eruler\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1200\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003enote\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e,\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e키 값을 통해 값에 접근하는 방법\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003edot notation(점 표기법)\u003c/li\u003e\n\u003cli\u003ebracket notation(대괄호 표기법)\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4\u003e점 표기법\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e officeSupplies = {\n  \u003cspan class=\"hljs-attr\"\u003epencil\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003epen\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1500\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eeraser\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eruler\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1200\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003enote\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e,\n};\n\nofficeSupplies.\u003cspan class=\"hljs-property\"\u003epencil\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 1000\u003c/span\u003e\nofficeSupplies.\u003cspan class=\"hljs-property\"\u003epen\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 1500\u003c/span\u003e\nofficeSupplies.\u003cspan class=\"hljs-property\"\u003ewater\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// undefined\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e존재하지 않는 키로 접근하면 undefined 가 반환됩니다.\u003c/p\u003e\n\u003ch4\u003e대괄호 표기법\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e officeSupplies = {\n  \u003cspan class=\"hljs-attr\"\u003epencil\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003epen\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1500\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eeraser\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eruler\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1200\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003enote\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e,\n};\n\nofficeSupplies[\u003cspan class=\"hljs-string\"\u003e\"pencil\"\u003c/span\u003e]; \u003cspan class=\"hljs-comment\"\u003e// 1000\u003c/span\u003e\nofficeSupplies[\u003cspan class=\"hljs-string\"\u003e\"pen\"\u003c/span\u003e]; \u003cspan class=\"hljs-comment\"\u003e// 1500\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e name = \u003cspan class=\"hljs-string\"\u003e\"note\"\u003c/span\u003e;\nofficeSupplies[name]; \u003cspan class=\"hljs-comment\"\u003e// 2000\u003c/span\u003e\n\nofficeSupplies[\u003cspan class=\"hljs-string\"\u003e\"ru\"\u003c/span\u003e + \u003cspan class=\"hljs-string\"\u003e\"ler\"\u003c/span\u003e]; \u003cspan class=\"hljs-comment\"\u003e// 1200\u003c/span\u003e\nofficeSupplies[\u003cspan class=\"hljs-string\"\u003e\"-\"\u003c/span\u003e]; \u003cspan class=\"hljs-comment\"\u003e// undefined\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e대괄호 안에는 어떠한 표현식도 올 수 있습니다. 따라서 변수도 사용할 수 있습니다. \"-\" 와 같은 일부 기호는 자바스크립트에서 유효한 식별자가 아니기 때문에 점 표기법으로는 나타낼 수 없습니다. 그럴 때는 반드시 대괄호 연산자를 사용하여야 합니다.\u003c/p\u003e\n\u003ch3\u003e객체에 해당 키가 존재하는지 확인하는 방법\u003c/h3\u003e\n\u003cp\u003e많은 분들이 해당 키의 값이 undefined 인지 확인하는 방법을 쓰곤 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e officeSupplies = {\n  \u003cspan class=\"hljs-attr\"\u003epencil\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003epen\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1500\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eeraser\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eruler\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1200\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003enote\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e,\n};\n\nofficeSupplies.\u003cspan class=\"hljs-property\"\u003eapple\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// undefined\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런데 만약에 \"apple\"의 값이 undefined 이면 어떨까요?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e officeSupplies = {\n  \u003cspan class=\"hljs-attr\"\u003epencil\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003epen\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1500\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eeraser\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eruler\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1200\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003enote\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eapple\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e,\n};\n\nofficeSupplies.\u003cspan class=\"hljs-property\"\u003eapple\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// undefined\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e값이 undefined 인 경우와 키가 존재하는지는 다른 경우이지만, 이렇게 확인하는 경우 정확하게 구분할 수가 없습니다.\u003c/p\u003e\n\u003cp\u003e또는 이를 boolean context에 사용하는 경우가 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!officeSupplies.\u003cspan class=\"hljs-property\"\u003ecoffee\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 사무용품에 커피가 없다면...\u003c/span\u003e\n\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"커피도 판매해주세요\"\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런데 coffee의 가격이 0원이었다면?\n즉, 0이라는 값이 암묵적으로 false로 변환되고 ! 연산자로 인해 true로 변환되어...\u003c/p\u003e\n\u003cp\u003e의외로 많이 발생하는 케이스입니다.\n0, \"\", NaN 은 암묵적으로 false로 변환됩니다.\u003c/p\u003e\n\u003cp\u003e코딩테스트에서는 주로 문자열과 숫자를 다루는데, 0과 \"\" 이 값인 경우에 어떻게 처리할 것인지를 명확하게 나누지 않고 암묵적 형변환을 하면 이런 상황에서 디버깅이 까다로워질 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (officeSupplies.\u003cspan class=\"hljs-property\"\u003ecoffee\u003c/span\u003e === \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e) {\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003ccode\u003ein\u003c/code\u003e 연사자를 사용하는 방법\u003c/h4\u003e\n\u003cp\u003ein 연산자는 객체에 키가 존재하는지를 true/false로 반환합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e officeSupplies = {\n  \u003cspan class=\"hljs-attr\"\u003epencil\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003epen\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1500\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eeraser\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eruler\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1200\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003enote\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eapple\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e,\n};\n\n\u003cspan class=\"hljs-string\"\u003e\"pen\"\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e officeSupplies; \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e\"apple\"\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e officeSupplies; \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e\"banana\"\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e officeSupplies; \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e객체의 모든 키를 반환\u003c/h3\u003e\n\u003cp\u003eObject.prototype.keys\u003c/p\u003e\n\u003ch3\u003e객체의 모든 값을 반환\u003c/h3\u003e\n\u003cp\u003eObject.prototype.values\u003c/p\u003e\n\u003ch3\u003e객체의 모든 키와 값을 반환\u003c/h3\u003e\n\u003cp\u003eObject.prototype.entries\u003c/p\u003e\n\u003ch3\u003ecf. 엔트리로 객체를 구성\u003c/h3\u003e\n\u003cp\u003eObject.fromEntries\u003c/p\u003e\n\u003ch4\u003e객체는 해시테이블용으로 만들어진게 아니다\u003c/h4\u003e\n\u003cp\u003e객체는 해시테이블을 위해서 구현된 것이 아닙니다.\n일반적인 객체 리터럴으로 객체를 생성한 경우 생성자인 Object의 prototype 객체를 프로토타입 객체로 하기 때문에, Object.prototype의 메서드에 해당하는 키와 값이 모두 존재합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"hasOwnProperty\"\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e {}; \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n({}[\u003cspan class=\"hljs-string\"\u003e\"isPrototypeOf\"\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// [Function: isPrototypeOf]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e즉, 제가 추가하지 않은 키와 값이 이미 추가되어 있다는 것입니다.\u003c/p\u003e\n\u003cp\u003e이를 해결하기 위해서 프로토타입 객체를 null 로 하여서 객체를 생성할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e obj = \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n\n\u003cspan class=\"hljs-string\"\u003e\"hasOwnProperty\"\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e obj; \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\nobj.[\u003cspan class=\"hljs-string\"\u003e\"isPrototypeOf\"\u003c/span\u003e]; \u003cspan class=\"hljs-comment\"\u003e// undefined\u003c/span\u003e\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e하지만 번거롭지 않나요?\u003c/p\u003e\n\u003cp\u003e해시테이블용으로 만들어진 구현체가 있습니다.\u003c/p\u003e\n\u003ch3\u003eMap\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eMap은 어떠한 키와 값도 기본적으로 추가되어 있지 않다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e객체는 키값으로 문자열만 올 수 있으나 Map은 모든 타입이 다 올 수 있다. 참조타입이 오는 경우에는 참조값이 같은 경우에 같은 키로 취급한다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e객체는 키의 순서가 보장되지 않으나 Map은 추가한 순으로 키가 나열되는 것이 보장된다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eiterable-iterator protocol을 준수하기 때문에 순회가 수월하다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMap은 키의 개수를 O(1)으로 알 수 있으나 객체는 O(N) 이다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMap은 성능면에서도 최적화되어 있다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4\u003e사용법\u003c/h4\u003e\n\u003cp\u003eget\nset\nhas\nforEach\nvalues\nentries\u003c/p\u003e\n\u003ch2\u003e4-3. 문제풀이\u003c/h2\u003e\n\u003cp\u003e\u003cdel\u003e### \u003ca href=\"https://www.acmicpc.net/problem/2480\"\u003ehttps://www.acmicpc.net/problem/2480\u003c/a\u003e\u003c/del\u003e\u003c/p\u003e\n\u003cp\u003e\u003cdel\u003e카운트\u003c/del\u003e\u003c/p\u003e\n\u003ch3\u003e\u003ca href=\"https://www.acmicpc.net/problem/10809\"\u003ehttps://www.acmicpc.net/problem/10809\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eMap\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ehas ? get : default vs get() || default\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003ca href=\"https://www.acmicpc.net/problem/1157\"\u003ehttps://www.acmicpc.net/problem/1157\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMap.prototype.values\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003ca href=\"https://www.acmicpc.net/problem/5622\"\u003ehttps://www.acmicpc.net/problem/5622\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e객체\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e4-4. Set\u003c/h2\u003e\n\u003cp\u003e고유한 값을 저장하기 위한 자료구조\u003c/p\u003e\n\u003cp\u003e중복된 값을 허용하지 않는다.\u003c/p\u003e\n\u003cp\u003e고유한 값 =\u003e 해시 테이블의 키 를 떠올리게 된다.\u003c/p\u003e\n\u003cp\u003e그래서 고유한 값을 만들기 위해서 객체 또는 Map을 활용할 수 있다.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.acmicpc.net/problem/3052\"\u003ehttps://www.acmicpc.net/problem/3052\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e예시로 알아보는...\u003c/p\u003e\n\u003cp\u003eget\nadd\nhas\nforEach\nvalues\nentries\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.acmicpc.net/problem/1316\"\u003ehttps://www.acmicpc.net/problem/1316\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e정규표현식, Set size 비교로 배열의 요소가 모두 고유한지 파악\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca href=\"https://www.acmicpc.net/problem/3273\"\u003ehttps://www.acmicpc.net/problem/3273\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e집합. 문제를 제대로 읽기\u003c/li\u003e\n\u003c/ul\u003e","title":"Ch04. 해시테이블","date":"2020-03-13","summary":"해시테이블: 객체, Map, Set"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"draft:js-algorithm-ch4"},"buildId":"ixvRORGkhpVcTgFEK-o9r","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>