<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta name="next-head-count" content="2"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c0319daaf0c38f70.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-418d4e6c8aa144e7.js" defer=""></script><script src="/_next/static/mGeQbCKeTVK9iuQqBnbIJ/_buildManifest.js" defer=""></script><script src="/_next/static/mGeQbCKeTVK9iuQqBnbIJ/_ssgManifest.js" defer=""></script><script src="/_next/static/mGeQbCKeTVK9iuQqBnbIJ/_middlewareManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.3">*,::before,::after{box-sizing:border-box;}/*!sc*/
[hidden]{display:none;}/*!sc*/
h1{margin:0.67em 0;font-size:2rem;}/*!sc*/
h2{font-size:1.5rem;}/*!sc*/
h3{font-size:1.17rem;}/*!sc*/
h4{font-size:1rem;}/*!sc*/
h5{font-size:0.83rem;}/*!sc*/
h6{font-size:0.67rem;}/*!sc*/
pre{white-space:pre-wrap;}/*!sc*/
hr{border-style:solid;border-width:1px 0 0;color:inherit;height:0;overflow:visible;}/*!sc*/
img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle;max-width:100%;}/*!sc*/
picture{display:contents;}/*!sc*/
source{display:none;}/*!sc*/
img,svg,video,canvas{height:auto;}/*!sc*/
audio{width:100%;}/*!sc*/
audio:not([controls]){display:none;}/*!sc*/
img{border-style:none;}/*!sc*/
svg{overflow:hidden;}/*!sc*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block;}/*!sc*/
[type="checkbox"],[type="radio"]{box-sizing:border-box;padding:0;}/*!sc*/
html,body{padding:0;margin:0;font-family:-apple-system,BlinkMacSystemFont,"Apple SD Gothic Neo","Malgun Gothic","맑은 고딕","나눔고딕","Nanum Gothic","Noto Sans KR","Noto Sans CJK KR",arial,"돋움",Dotum,Tahoma,Geneva,"Helvetica Neue",sans-serif;}/*!sc*/
a{color:inherit;-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g1[id="sc-global-crMvLC1"]{content:"sc-global-crMvLC1,"}/*!sc*/
.gOdiQq{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;width:100%;}/*!sc*/
data-styled.g2[id="sc-d7fdb9d7-0"]{content:"gOdiQq,"}/*!sc*/
.kKdabY{margin:0;line-height:1.25;width:100%;font-size:3.6rem;text-align:center;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-column-gap:2rem;column-gap:2rem;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;font-weight:800;}/*!sc*/
@media (max-width:767px){.kKdabY{font-size:7.5vw;-webkit-column-gap:1rem;column-gap:1rem;}}/*!sc*/
data-styled.g3[id="sc-d7fdb9d7-1"]{content:"kKdabY,"}/*!sc*/
.hfKWMb{position:relative;overflow:hidden;border-radius:35%;width:25%;padding-bottom:25%;}/*!sc*/
@media (max-width:600px){.hfKWMb{width:20%;padding-bottom:20%;}}/*!sc*/
data-styled.g4[id="sc-d7fdb9d7-2"]{content:"hfKWMb,"}/*!sc*/
.caTBeP{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;}/*!sc*/
data-styled.g5[id="sc-d7fdb9d7-3"]{content:"caTBeP,"}/*!sc*/
.bkfRko{min-height:100vh;padding:3rem 2rem 0;-webkit-flex:1;-ms-flex:1;flex:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;max-width:768px;margin:auto;}/*!sc*/
@media (max-width:600px){.bkfRko{padding:2rem 1rem 0;}}/*!sc*/
data-styled.g9[id="sc-8d5d6634-0"]{content:"bkfRko,"}/*!sc*/
.dsDnMD{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;width:calc(100vw - 3rem);padding:2rem 0 1rem;border-top:1px solid #eaeaea;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}/*!sc*/
data-styled.g10[id="sc-8d5d6634-1"]{content:"dsDnMD,"}/*!sc*/
.gffvJe{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}/*!sc*/
data-styled.g11[id="sc-5d513e51-0"]{content:"gffvJe,"}/*!sc*/
</style></head><body><div id="__next" data-reactroot=""><div class="sc-8d5d6634-0 bkfRko"><header class="sc-d7fdb9d7-0 gOdiQq"><h1 class="sc-d7fdb9d7-1 kKdabY"><div class="sc-d7fdb9d7-2 hfKWMb"><img src="/profile.jpg" alt="프로필" class="sc-d7fdb9d7-3 caTBeP"/></div><span>프론트엔드 개발자<br/>김동희입니다</span></h1></header><div><h1>Ch02. 기초 알고리즘 지식</h1><time>2020-03-11</time></div><main class="sc-5d513e51-0 gffvJe"><p>앞으로 여러가지 알고리즘을 학습하게 될텐데요, 동일한 기능을 수행하는 알고리즘이 여러가지가 있을 수 있습니다. 예를 들어 정렬 알고리즘에서는 버블 정렬, 선택 정렬, 삽입 정렬, 머지 소트, 퀵 소트 등 여러가지 알고리즘을 수행해서 배열을 정렬할 수가 있습니다. 이러한 정렬 알고리즘 간에 어떤 것이 더 효율적인지를 어떻게 알 수 있을까요?
알고리즘의 효율성을 분석할 때는 시간 복잡도와 공간 복잡도의 두 가지 방법을 이용합니다.</p>
<h2>1. 시간복잡도</h2>
<p>시간복잡도란 주어진 입력에 따라 알고리즘이 문제를 해결할 때 걸리는 시간을 의미합니다.</p>
<p>~~시간복잡도란 입력의 크기와 문제를 해결하는데 걸리는 시간의 상관관계를 의미합니다.~~</p>
<p>입력의 크기가 1일 때와 100일 때 걸리는 시간이 상이할텐데, 어떤 알고리즘은 입력의 크기가 100배 차이 나면 시간도 100배 차이 나는 알고리즘도 있고, 100배가 아니라 10,000배 차이가 날수도 있고, 2^100 배 차이가 날수도 있고, 동일한 시간이 걸릴 수도 있습니다.</p>
<p>이러한 시간복잡도를 나타내는 방법 중에 많이 사용되는 것이 빅 오 표기법(Big O Notation) 입니다.</p>
<h3>1-1. 빅 오 표기법이란?</h3>
<p>빅 오 표기법의 수학적 정의는 다음과 같습니다.</p>
<pre><code>O(g(n)) = {f(n): 모든 n >= n0에 대해 0 &#x3C;= f(n) &#x3C;= cg(n)인 양의 상수 c, n0가 존재한다.}
</code></pre>
<p>굉장히 복잡해보이죠?</p>
<p>직관적으로 그냥 설명해보겠습니다.</p>
<p>~~빅 오 표기법은 주어진 입력값 N에 대하여 알고리즘을 수행할 때 필요한 단계수를 N을 사용하여 나타낸 방법입니다.~~</p>
<p>빅 오 표기법은 주어진 입력값이 증가할 때 해당 알고리즘 수행에 필요한 단계수가 어떻게 증가하는지를 나타낸 것입니다.</p>
<p>빅 오 표기법에 대해서 구체적인 예시를 통해서 조금 더 살펴보도록 하겠습니다.</p>
<h4>예시1) 배열에 특정 요소가 포함되어 있는지 확인하는 함수</h4>
<p><code>function includes(target: number, arr: number[]): boolean;</code></p>
<p>이러한 표기법이 조금 낯설게 느껴지실텐데요, 이는 타입스크립트에서 사용하는 함수 타입을 나타낼 때 쓰는 방법입니다. 콜론 뒤의 값이 해당 변수의 타입을 나타내고, 마지막에 함수의 선언 이후에 기재된 boolean은 이 함수의 반환값의 타입을 나타냅니다.</p>
<p>이렇게 함수의 구현이 아니라 입력과 반환값의 타입만을 나타내는 것을 함수의 시그니쳐라고 말합니다.</p>
<p>저희는 타입스크립트로 구현하지는 않지만, 여러분들과 저와 함수를 구현하기 전에 이러한 형태의 함수를 구현해나갈거에요 라는 걸 말할 때 이런 표기법으로 종종 설명드리도록 하겠습니다.</p>
<p>즉, <code>includes</code> 라는 함수는 number 타입인 target과 number 타입의 배열인 arr을 차례로 매개변수로 전달받아 arr에 target이 포함되어 있으면 true를, 포함되어 있지 않다면 false를 반환하는 함수입니다.</p>
<p>예를 들어 보면 다음과 같습니다.</p>
<pre><code>includes(3, [1, 2, 3]); // true
includes(10, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]); // false
</code></pre>
<p>이를 단순하게 구현해 본다면 이렇게 될 수 있겠죠.</p>
<pre><code>function includes(target, arr) {
  let isFound = false;

  for (let i = 0; i &#x3C; arr.length; i++) {
    if (arr[i] === target) {
      isFound = true;
    }
  }

  return isFound;
}
</code></pre>
<p>target은 항상 단 하나의 숫자이고, arr은 배열에 포함된 전체 요소의 갯수가 매번 다르겠죠. 그렇다면 여기서는 arr 배열에 포함된 전체 요소 개수를 N이라고 해보겠습니다.</p>
<p>그렇다면 includes 함수는 target을 찾기 위해 몇단계가 필요한가요?</p>
<p>N = 1 일 때, target과 일치하는지 하나의 요소만 비교하면 되니 1번입니다.
N = 2 일 때, target과 일치하는지 0번째 요소와 1번째 요소를 비교해야 하니 2번입니다.
N = 10일 때, 0번째 요소부터 9번째 요소까지 다 비교해야하니 10번입니다.
즉, N이 증가하면 그에 선형적으로 비례해서 단계수가 증가합니다.</p>
<p>그래프로 그려보면 아래와 같습니다.</p>
<p>이러한 includes 함수의 시간복잡도를 나타낼 때에 배열에 포함된 요소의 개수를 N이라고 할 때 <code>O(N)</code>이다 라고 표현합니다.</p>
<h4>예시2) 두 배열에 공통적으로 포함된 요소를 계산하는 함수</h4>
<pre><code>function intersection(a:number[], b:number[]): number[]
</code></pre>
<pre><code>intersection([3, 4], [1, 2, 3]); // [3]
intersection([0, 2, 3, 4, 5, 6, 8, 9], [4, 1, 7, 9]); // [4, 9]
intersection([10, 11, 12], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]); // []
</code></pre>
<pre><code>function intersection(a, b) {
  const result = [];

  for (let ai = 0; ai &#x3C; a.length; a++) {
    for (let bi = 0; bi &#x3C; b.length; b++) {
      if (a[ai] === b[bi]) {
        result.push(a[ai]);
      }
    }
  }

  return result;
}
</code></pre>
<p>a 배열에 포함된 요소의 개수를 N, b 배열에 포함된 요소의 개수를 M이라고 할 경우,
a 배열에 포함된 요소를 모두 순회하면서 해당 요소가 b 배열에 포함된 요소인지를 b 배열을 모두 순회하면서 비교하여야 합니다.</p>
<p>a 배열에 포함된 요소의 개수가 10개에서 20개로 2배가 된다면, 순회횟수도 2배 증가합니다.
N과 M 각각에 선형적으로 비례하여 증가하므로,
<code>O(NxM)</code></p>
<h4>예시3) 주어진 수가 짝수인지 확인하는 함수</h4>
<pre><code>function isEven(n: number): boolean;
</code></pre>
<pre><code>isEven(1); // false
isEven(2); // true
isEven(3); // false
isEven(100); // true
</code></pre>
<pre><code>function isEven(n) {
  if (n % 2 === 0) return true;
  else return false;
}
</code></pre>
<p>n이 1에서 10000이 되더라도 나누어서 나머지가 0인지 확인하는 단계수는 증가하지 않습니다.</p>
<p>즉, n이 증가하더라도 단계수가 증가하지 않으므로 <code>O(0)</code> 이라고 표현해야 할 거 같은데, 일반적으로 n^0 에 비례한다고 하여 <code>O(n^0) = O(1)</code> 이라고 표현합니다.</p>
<h3>1-2. 빅 오 표기법의 특징</h3>
<h4>a) 최대차수의 항만 고려하며 상수계수는 무시한다</h4>
<h4>b) 같은 O(N) 이라고 해서 동일하게 빠른게 아니다</h4>
<h4>c) 항상 O(N) &#x3C; O(N^2) 이 아니다</h4>
<h4>d) 빅 오 표기법의 정의는 최악의 상황의 성능을 나타내지만, 관행적으로 최선과 평균을 나타낼 때도 사용한다</h4>
<h3>1-3. 코딩테스트에서 빅 오 표기법을 어떻게 사용해야 하는가</h3>
<p>제한시간이 주어지는 문제가 있다. 구체적인 제한시간이 주어지지 않더라도 매우 많은 시간을 사용한다면 채점사이트에서 이를 무작정 기다릴 수 없으므로 일정 시간이 지나면 오답으로 처리한다.</p>
<p>일반적으로 아래와 같다. 하지만 1-2. 빅 오 표기법의 특징에서 말했듯이 N의 크기가 작으면 반드시 아래가 성립하지 않는다. 하지만 N이 충분히 커진다면 아래의 관계가 성립한다.</p>
<p><code>O(1) &#x3C; O(logN) &#x3C; O(N) &#x3C; O(NlogN) &#x3C; O(N^2) &#x3C; O(2^N) &#x3C; O(N!)</code></p>
<p>O(1)은 상수형 알고리즘...
O(logN)은 로그형 알고리즘 ..
(각각의 알고리즘 글로 한 번더 소개)</p>
<p>Node.js 로 1초에 대략 4000만번의 연산을 수행할 수 있다고 가정할 때, 1초내 수행할 수 있는 연산 수는 아래와 같다.</p>
<p>내가 떠올린 알고리즘의 빅오표기법이 O(N^2) 이고 최대 N이 10000이라면, 제한시간이 1초라면은 내가 아무리 알고리즘을 잘 구현하더라도 제한시간내에 되지 않겠구나 라고 추측할 수 있다. 그러나 빅오표기법에서 상수항은 무시하므로 정확하게 일치하는 것은 아니다. 대략적인 느낌만 잡아가면 된다.</p>
<h2>2. 공간복잡도</h2>
<p>공간복잡도란 알고리즘이 문제를 해결할 때 점유하는 컴퓨터의 메모리 공간을 뜻합니다.</p>
<p>공간복잡도에서도 빅 오 표기법의 개념을 가져와서 사용할 수 있습니다.</p>
<p>공간복잡도에서 빅 오 표기법은 주어진 입력값 N이 증가할 때 해당 알고리즘을 수행할 때 필요한 메모리가 어떻게 증가하는지를 N을 사용하여 나타냅니다.</p>
<h3>예제) 문자열 배열을 받아 모두 대문자로 바꾼 배열을 반환하는 함수</h3>
<pre><code>function makeUpperCase(arr: string[]): string[];
</code></pre>
<pre><code>makeUpperCase(["apple", "banana", "cinnamon"]); // ["APPLE", "BANANA", "CINNAMON"]
</code></pre>
<pre><code>function makeUpperCase(arr) {
  return arr.map((str) => str.toUpperCase());
}
</code></pre>
<p>이 함수를 공간복잡도 관점에서 분석하면 원소 N개를 포함하는 새로운 배열을 생성합니다. 즉, 원래 주어진 배열 이외에 메모리를 더 소모합니다.</p>
<p>함수가 데이터 원소 N개 증가하면 N개의 메모리를 추가로 소모하므로 이 함수의 공간 복잡도는 O(N) 입니다.</p>
<p>메모리 효율적인 함수로 변경해보겠습니다.</p>
<pre><code>function makeUpperCase(arr) {
  for (let i = 0; i &#x3C; arr.length; i++) {
    arr[i] = arr[i].toUpperCase();
  }

  return arr;
}
</code></pre>
<p>새 배열을 생성하지 않고 원래 배열을 수정하고, 수정된 배열을 반환합니다.
어떤 메모리도 추가로 소모하지 않으니 메모리 소모 관점에서는 엄청난 성능 향상입니다.</p>
<p>빅 오 표기법에 따르면 주어진 입력값이 증가하더라도 추가적으로 전혀 메모리를 소모하지 않으므로 O(N^0) = O(1) 입니다.</p>
<p>공간복잡도를 빅 오 표기법으로 나타낼 때에는 알고리즘에서 새로 생성한 데이터만 고려합니다. 원래 배열은 언제든 존재하고 알고리즘에서 추가로 소모하는 공간이 중요하니 원래 데이터 원소 N개는 빅 오로 나타낼 때 감안하지 않습니다.</p>
<p>버젼1과 버젼2의 시간 복잡도와 공간 복잡도를 모두 비교해보면 다음과 같습니다.</p>
<p>| 버전  | 시간 복잡도 | 공간 복잡도 |
| ----- | ----------- | ----------- |
| 버전1 | O(N)        | O(N)        |
| 버전2 | O(N)        | O(1)        |</p>
<p>버젼1과 버젼2 을 비교하였을 때 시간 복잡도는 동일하나 버전2가 공간 복잡도가 더 낮아졌으니 효율성 측면에서는 버젼2가 더 유리하다고 판단할 수 있습니다.</p>
<p>그러나 공간 복잡도와 시간 복잡도의 관계가 항상 이러한 것만은 아닙니다.</p>
<h3>시간과 공간의 트레이드 오프</h3>
<h4>두 수의 합 문제</h4>
<p>숫자 배열을 입력받아 합해서 10(또는 주어진 다른 수)이 되는 두 수가 배열에 있는지를 true나 false로 반환하는 함수를 작성하면 된다. 단순하게 풀기 위해 배열에 중복은 없다고 가정합니다.</p>
<p>버젼1 시간복잡도: O(N^2) 공간복잡도: O(1)</p>
<p>버젼2 시간복잡도: O(N) 공간복잡도: O(N)</p>
<h4>또다른 예시로는 정렬도 있다.</h4>
<p>선택 정렬
머지 소트
퀵 소트</p>
<p>자세히 설명하지는 않겠다. 일반적으로 코딩테스트에서 정렬</p>
<h4>일반적으로는 시간 복잡도를 더 중요시 여긴다</h4>
<p>특히 자바스크립트에서는 함수형 프로그래밍의 개념을 많이 차용하여 사용되는데, 공간복잡도를 희생해서 더 빠른 시간복잡도를 얻는 것을 좋게 여긴다. 버젼2의 경우, 입력값을 변경시키는데 이는 함수형 프로그래밍에서 강조하는 순수 함수의 정의에 어긋난다.
이 입력값을 다른 곳에서 또 쓴다면, 버젼2를 통과한 입력값은 값이 변경되어있어 의도치 않은 버그를 일으킬 수 있다. 버젼2와 같이 실제 함수에 전달된 원본 배열을 수정하는 것을 제자리(in-place) 수정이라고 불린다.</p>
<p>의도적으로 메모리 제한을 적게 주는 문제가 BOJ에는 있다. 그러나 일반적인 코딩테스트에서는 잘 나오지 않는다. 다만, 굉장히 큰 자료구조를 여러번 생성하거나 하면... 굉장히 속도가 느려져서 오히려 통과가 안되는 경우가 있다. 또 넉넉한 메모리를 통해서 손쉽게 풀 수 있는 알고리즘이 있다. 카운팅 소트 등...</p>
<p>또 재귀에서는 호출 스택이라는 숨겨진 공간복잡도가 있는데 이 부분에 대해서는 재귀 챕터에서 자세히 다루겠다.</p>
<h4>문제를 풀 때 시간 복잡도와 공간 복잡도를 잘 고려하자.</h4>
<p>각 상황마다 주어진 최소 허용 속도와 메모리 한도를 알아야 한다. 제약을 이해하고 다양한 알고리즘 중에서 고르고 선택할 수 있고 속도와 메모리 요구사항에 맞게 효율성을 유지할 수 있다.</p>
<ul>
<li>자바스크립트에서는 순수 함수의 개념을 이용하여 새로운 변수를 매번 정의하는 것을 선호하는 패턴이 현업에서도 일반적이므로 이러한 패턴을 적용하는 컨벤션을 익히는 것이 실제 알고리즘 문제 풀이에 미치는 영향을 알고 있어야 한다. 그래서 공간복잡도 때문에 초과되면 빠르게 이러한 패턴을 포기할 줄도 알아야 한다.</li>
</ul>
<h2>3. 숫자를 다룰 때 주의할 점: 부동소수점</h2>
<h3>3-1. 0.3 - 0.2 === 0.1</h3>
<p>console.log(0.3 - 0.2 === 0.1) 을 자바스크립트로 실행시키면 true가 출력될까요 false가 출력될까요??</p>
<p>웬 뜬금없는 질문이냐고 생각하실 수 있는데요, 정답은 false 입니다.</p>
<p>당황하신 분도 계실 것 같아요. 이때까지 내가 배워온 수학이 뭔가 잘못되었던 걸까?</p>
<p>하지만 그렇지 않습니다. 이론적으로는 0.3 - 0.2 === 0.1 은 true가 맞습니다. 우리가 사용하는 일상생활에서 사용하고 있는 숫자 체계는 10진법이죠.
0 ~ 9 까지의 숫자를 사용하고, 한 자리수를 추가할 때마다 10이 곱해집니다.</p>
<pre><code>235 = 2 * 10 ^ 2 + 3 * 10 ^ 1 + 5 * 10 ^ 0
</code></pre>
<p>소숫점도 동일합니다.</p>
<pre><code>38.746 = 3 * 10 ^ 1 + 8 * 10 ^ 0 + 7 * 10 ^ (-1) + 4 * 10 ^ (-2) + 6 * 10 ^ (-3)

0.3 = 3 * 10 ^ (-1)
</code></pre>
<p>그러나 컴퓨터는 내부적으로 0 과 1의 숫자만을 사용해서 한 자리수를 추가할 때마다 2가 곱해지는 2진법을 사용하고 있죠.</p>
<pre><code>38.746 = 100110.10111110111110011101101100100010110100001110011
0.3 = 0.010011001100110011001100110011001100110011001100110011
0.2 = 0.001100110011001100110011001100110011001100110011001101
0.1 = 0.0001100110011001100110011001100110011001100110011001101

</code></pre>
<p>0.3은 10진법으로 표기할 때는 딱 떨어지는 깔끔한 숫자입니다</p>
<p>그런데 2진법으로 표기하면 딱 떨어지지 않습니다.</p>
<p>1/3 을 예시로 들어볼까요?</p>
<p>1/3 을 소수로 나타내면 <code>0.3333333333333333</code> 이고 3을 무한대로 계속해서 적어야 합니다. 이론적으로는 3을 무한대로 적으면 되는데 실생활에서는 이를 무한대로 적을 수가 없죠. 그래서 과학이라는 분야에서는 유효범위라는 걸 정해서 몇자리수까지는 유효하다 이렇게 표현하기도 합니다.</p>
<p>0.3은 2진법으로 표기하면 마치 10진법의 1/3 처럼 딱 떨어지지가 않습니다.
<code>0.010011001100110011001100110011001100110011001100110011</code>
1100 이 계속해서 반복되죠. 컴퓨터는 유한한 메모리 내에서 이 수를 표현해야 하기 때문에 이 또한 정확하지가 않습니다.
0.2, 0.1 또한 마찬가지입니다.</p>
<p>따라서 정확하게 일치하지 않는 것입니다.</p>
<p>반대로 정확하게 표시되는 수가 무엇이 있을까요?
바로 0.5, 0.25 와 같은 수가 있습니다.</p>
<pre><code>0.5 = 1 * 2 ^ (-1)
0.25 = 0 * 2 ^ (-1) + 1 * 2 ^ (-2)
</code></pre>
<p>그렇기 때문에 0.5 - 0.25 === 0.25 는 true가 됩니다.</p>
<h3>3-2. double-precision 64-bit binary format IEEE 754</h3>
<p>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number</p>
<p>자바스크립트에서 숫자를 나타내는 원시자료형(primitive type)은 두가지가 있습니다. number와 bigint 입니다.</p>
<p>bigint는 ES2020에 추가된 스펙인데, 여기서는 일단 number에 대해서만 알아보도록 하겠습니다.</p>
<p>유한한 메모리 구조 내에서 number를 나타내기 위해서 사용되는 여러가지 표준이 있는데, 그 중에서 자바스크립트는 double-precision 64-bit binary format IEEE 754 로 숫자를 표현하는데, 간단히 설명드리자면</p>
<p>0 또는 1의 값을 가지는 64개의 비트로 숫자를 나타내며,</p>
<pre><code>가수부 x 2 ^ (지수부)
</code></pre>
<p>부호(sign) 1비트, 지수(exponent) 11비트, 가수(fraction) 52비트로 나타냅니다.</p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/61345d47f069d645947b9c0ab676c75551f1b188" alt=""></p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/300577464b37b5769a97e85aa67c56200e1011df" alt=""></p>
<pre><code>0.3 = 0 01111111110 0100110011001100110011001100110011001100110011001100

0.3 = (-1)^0 * (1.0100110011001100110011001100110011001100110011001100) * 2 ^ (01111111110 - 01111111111)

</code></pre>
<h4>가장 큰 수</h4>
<p>https://en.wikipedia.org/wiki/Double-precision_floating-point_format</p>
<p>따라서 이러한 정의에 따라 표현할 수 있는 가장 큰 숫자는 아래와 같고, 이는 Number.MAX_VALUE 로 접근 가능.</p>
<pre><code>0 11111111110 1111111111111111111111111111111111111111111111111111
≙ 7FEF FFFF FFFF FFFF16
≙ +2 ^ 1023 × (1 + (1 − 2^ (−52))
≈ 1.7976931348623157 × 10 ^ 308
</code></pre>
<h4>가장 작은 수</h4>
<p><code>Number.MIN_VALUE === 5e-324</code></p>
<h4>그래서 연산시에 주의할 점</h4>
<p>소수간의 비교를 할 때 정확하게 일치하는지로 구분하면 안된다. 소수 자체가 정확하게 표현되어 있지 않기 때문에 무조건 오차가 발생하기 때문에.
그래서 실제값과 기대값의 차이가 일정 범위 안에 있는지를 확인하는게 좋다.</p>
<pre><code>(0.3 - 0.2) - 0.1 &#x3C; Number.EPSILON
</code></pre>
<h5>절대오차 상대오차 개념</h5>
<p>절대오차 = | 내가 제출한 답 - 정답 |</p>
<p>상대 오차 = | 내가 제출한 답 - 정답 | / 정답</p>
<h4>EPSILON 이란...</h4>
<p>Number.EPSILON
The value of Number.EPSILON is the Number value for the magnitude of the difference between 1 and the smallest value greater than 1 that is representable as a Number value, which is approximately 2.2204460492503130808472633361816 × 10-16.</p>
<h4>가장 큰 양의 정수</h4>
<p>https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-properties-of-the-number-constructor</p>
<p>The value of Number.MAX_SAFE_INTEGER is 9007199254740991𝔽 (𝔽(2**53 - 1)).</p>
<h4>가장 작은 음의 정수</h4>
<p>The value of Number.MIN_SAFE_INTEGER is -9007199254740991𝔽 (𝔽(-(2**53 - 1))).</p>
<h3>3-3. Infinity</h3>
<p>무한대의 숫자를 나타낼 때 Infinity를 사용한다.
음의 무한대는 -Infinity</p>
<p>Infinity 는 어떠한 연산을 사용하더라도 절대 도달할 수 없는 값이므로 최초값을 할당할 때 많이 쓴다</p>
<p>예를 들어서 배열의 가장 작은 값을 찾는 함수</p>
<p><code>funtion min(arr: number[]):number</code> 가 있다고 가정해보자.</p>
<pre><code>
function min(arr) {
  let min = Infinity;

  for(const num of arr) {
    if (min > num) {
      min = num;
    }
  }

  return min;
}
</code></pre>
<p>min의 초기값으로 Infinity를 할당하면 for - of 루프의 첫번째 패스스루에서 항상 min 이 num 보다 크게 되어 min = num 이 실행된다.</p>
<h2>4. 자료형변환</h2>
<h3>4-1. 암시적 형변환</h3>
<p>서로 다른 자료형간의 연산을 수행하면 자바스크립트에서는 암시적 형변환이 일어난다. 예를들어 다음과 같다</p>
<pre><code>
"1" + 1 === "11"
"1" - 1 === 0

true + 1 === 2
[] + 2 === "2"
</code></pre>
<p>명시적으로 자료형을 변환해서 쓰자. 암시적을 몰라도 된다는건 아니지만 명시적 형변환이 더욱 의도를 명확하게 한다.</p>
<p>특히 변수 선언시에 자료형을 기재하지 않는 자바스크립트의 경우, 이를 습관화 하지 않으면 나중에 디버깅을 굉장히 어렵게 한다.</p>
<h4>동등 연산자(<code>==</code>)보다 일치 연산자(<code>===</code>)를 우선시 하자</h4>
<h3>4-1. string => number</h3>
<h4>Number vs parseInt(parseFloat) vs new Number</h4>
<h5>Number vs new Number</h5>
<p><code>Number</code> 는 function으로서 작용하여 primitive type을 반환하지만, <code>new Number</code>는 constructor로서 작용하여 Object를 반환합니다.</p>
<p>큰 차이가 없어 보이지만, 차이는 있습니다.</p>
<ol>
<li><code>Object</code>는 boolean context에서 항상 <code>true</code>입니다. 따라서 이를 의식하지 않고 코딩을 하다보면 일반적으로 생각하는 것과 다른 움직임을 보일 수 있습니다.</li>
</ol>
<pre><code>const a = Number("0");
const b = new Number("0");

if (a) {   // false 이므로 조건문 내부는 실행되지 아니함
...
}

if (b) { // `Object([Number: 0])`는 boolean context에서 `true`이므로 조건문 내부가 실행됨
...
}
</code></pre>
<ol start="2">
<li>Object와 primitive type 의 === 비교시 false가 반환됩니다.</li>
</ol>
<pre><code>const a = new Number("123");
console.log(a === 123); // false

const b = Number("123");
console.log(b === 123); // true

console.log(a instanceof Number); // true
console.log(b instanceof Number); // false
</code></pre>
<p>혼란을 피하기 위하여 ** new Number는 사용하지 않습니다.**</p>
<h5>Number vs parseInt</h5>
<p>Number 는 문자열 전체를 숫자로 반환하는 한편, parseInt는 문자열을 처음부터 읽어나가다가 최대로 숫자로서의 의미를 가지는 부분까지를 변환합니다.</p>
<pre><code>const str = "10x";
console.log(parseInt(str, 10)); // 10
console.log(Number(str)); // NaN
</code></pre>
<p>또한 parseInt의 시그니쳐는 다음과 같습니다.</p>
<p><code>function parseInt(str: string; radix?: number):number</code></p>
<p><code>parseInt</code>는 두번째 인자로 어떤 진법으로 문자열을 파싱할지를 전달받습니다. 만약에 생략되면 일반적으로 10진법으로 파싱되나 브라우저에 따라 상이할 수도 있다고 합니다.</p>
<p>이에 반해 Number의 시그니쳐는 다음과 같습니다.</p>
<p><code>function Number(str: string):number</code></p>
<p>이렇게 인자의 개수가 몇개인지에 따라서 동작이 달라지는 경우가 있습니다.</p>
<pre><code>const arr = ["1", "2", "3"];

arr.map((str) => Number(str)); // [1,2,3]
arr.map((str) => parseInt(str)); // [1,2,3]
</code></pre>
<p>배열의 map 메서드는 콜백함수를 전달받은 다음에 배열을 순회하면서 요소마다 콜백함수를 실행시키죠</p>
<p>parseInt 도, Number 도 함수이므로, 이를 map의 콜백함수로 전달할 수 있습니다.</p>
<pre><code>const arr = ["1", "2", "3"];

arr.map(Number); // [1,2,3]
arr.map(parseInt); // [ 1, NaN, NaN ]
</code></pre>
<p>예상하신 결과인가요?</p>
<p>map 함수는 el, index, this 값을 차례로 콜백함수에게 인자로 전달합니다.</p>
<p>따라서 "1"을 순회할 때에 ("1", 0, arr)이 parseInt의 인자로 전달되므로 parseInt(1,0, arr) 이 호출되는 것과 같습니다. 자바스크립트에서는 함수선언시의 매개변수의 개수와 실제 전달한 인자의 개수가 일치하지 않아도 함수 실행에 문제가 없습니다.</p>
<p>위와 같이 parseInt 함수 선언시에 2개의 인자를 받으나 3개를 넘기면 마지막 세번째 인자는 무시됩니다. 반대로 1개의 인자만을 넘기면 2번째 인자는 undefined 가 됩니다. (이를 제어하기 위해서 default parameter 라는 문법이 있죠 ^^)</p>
<p>세번째 인자인 arr은 무시됩니다.</p>
<p>parseInt는 두번째 인자인 radix로 0이 전달되면 이를 무시합니다. 따라서 1로 파싱이 됩니다.</p>
<p>다음 "2"를 순회할 때에는 ("2", 1, arr)이 전달되며 parseInt("2", 1, arr)이 호출되는 것과 같습니다.</p>
<p>parseInt의 radix는 [2,36] 사이의 값만 가질 수 있습니다. radix가 이 범위를 벗어나면 parseInt는 NaN을 반환합니다.</p>
<p>다음 "3"를 순회할 때에는 ("3", 2, arr)이 전달되며 parseInt("3", 2, arr)이 호출되는 것과 같습니다.</p>
<p>2진법에서 각 자리수는 0 또는 1이어야 하죠. 따라서 "3" 은 2진법에서는 절대 존재할 수 없는 숫자입니다. 따라서 NaN을 반환합니다.</p>
<p>또한 "1e6" 과 같이 지수표기법으로 나타낸 문자열도 Number 는 잘 변환합니다.</p>
<p>리터럴으로 a = 1e6; 또한 유효한 숫자 리터럴이기 때문이죠. 하지만 parseInt를 쓰면 e는 숫자 digit이 아니기 때문에 e 앞까지인 1만 숫자로 변환됩니다.</p>
<p>주저리주저리 설명하였지만... Number 를 쓰시는게 속이 편합니다.
경험적으로 <code>parseInt</code>와 <code>Number</code>의 실행속도차이는 미미한 것 같습니다.
저는 개인적으로 <code>Number</code>를 사용합니다. radix를 기재하는게 귀찮기도 하고, 그냥 익숙해서요.
코딩테스트에서는 입력값의 정확성은 보장되므로 어떤 것을 쓰더라도 문제 없을 것 같습니다.</p>
<p>반드시 parseInt를 써야하는 경우는 문자열이 10진수가 아닌 경우 뿐입니다.</p>
<h4>parseFloat</h4>
<p>parseFloat는 parseInt 와 다르게 하나의 인자만을 받습니다. 따라서 parseFloat로는 10진수가 아닌 다른 진법으로 기재된 소수를 파싱할 수 없다. 다른 진법으로 기재된 소수 문자열을 숫자로 변환하기 위해서는 별도의 함수를 만들어야 한다.</p>
<p>일반적으로 parseFloat를 쓸 일도 없다. 10진법이면 그냥 Number 를 쓰면 되기 때문이다.</p>
<h4>NaN</h4>
<p>NaN은 숫자가 아님을 나타내는 숫자자료형이다. NaN은 Not a Number 의 앞글자를 딴 것이다. NaN은 의미론적으로는 숫자가 아님을 나타내지만, 타입은 number이기 때문에 생각보다 골치아픈일이 발생한다.</p>
<pre><code>const a = NaN;

console.log(typeof a); // number;
</code></pre>
<p>임의로 NaN을 할당하는 경우는 잘 없기 때문에, 대부분 발생하는 경우는 암묵적 자료형변환에 의해서 발생한다.</p>
<p>Number 함수는 어떤 값이던지 매개변수로 받아서 숫자를 반환한다. 스펙에 따르면 절대 에러를 내지 않는다.
이를 함수 시그니쳐로 나타내면</p>
<p><code>function Number(a: any): number</code></p>
<p>any는 어떤 자료형이던지 올 수 있다는 뜻으로 나타내었다.</p>
<p>Number("abcd") 는 무엇을 반환할 것인가? 라고 하면 바로 NaN을 반환한다.</p>
<p>NaN은 숫자이기 때문에 숫자 관련 연산을 모두 수행할 수 있다. 더하기, 곱하기, 제곱, 나누기 ... 등. 연산의 결과는 모두 NaN이다.</p>
<p>그렇기 때문에 어떤 연산의 결과가 NaN 이라면 자료형변환을 제대로 하였는지 다시 한 번 확인해보자.</p>
<p>NaN인지 확인하는 방법으로 Window.isNaN과 Number.isNaN이 있는데 Number.isNaN을 쓰면 된다. Window.isNaN 에는 여러 문제점이 있어서 추가된 문법이 Number.isNaN 이다.
또는 매우 간단하게 체크하는 방법이 있는데, NaN은 유일하게 자기 자신과 비교하였을 때 false를 반환하는 성질이 있다.</p>
<pre><code>const a = NaN;

a === a; // false

function isNaN(a) {
  return a !== a;
}
</code></pre>
<h3>4-2. number => string</h3>
<h4>String vs toString vs new String</h4>
<p>어떠한 값이 number 라는 것이 확실하다면, 사용법측면에서 String이나 toString이나 동일하다</p>
<pre><code>const a = 3;

String(a); // "3"

a.toString(); // "3"
</code></pre>
<p>그런데 a는 3이라는 원시 자료형인데 어떻게 toString 이라는 메서드를 가질 수가 있는거지?</p>
<p>자바스크립트에는 원시자료형에 대한 래퍼객체가 존재한다.
숫자 자료형의 래퍼 객체는 Number 인데 원시자료형에서 래퍼 객체의 메소드를 호출하면 자바스크립트는 해당 값을 래퍼 객체로 감싼 다음에 래퍼 객체의 메서드를 호출하고 값을 반환한다. 래퍼 객체는 바로 제거된다.
그렇기 때문에 원시자료형도 각 래퍼 객체의 메소드를 자유롭게 호출할 수 있다.</p>
<p>참고로 리터럴에서도 사용할 수 있다.</p>
<pre><code>(3).toString();
(3).toString();
(3.5).toString();
</code></pre>
<p>첫번째의 .. 은 오타가 아니다. 그냥 . 은 소숫점 표기로 인식되기 때문에 정수의 경우에는 ..으로 해야한다. 아니면은 괄호로 감싸야 한다.</p>
<p>그런데 어떠한 값이 숫자일수도 있고 null 일 수도 있고 undefined 일 수도 있다. null이나 undefined는 래퍼객체가 존재하지 않고 따라서 toString 메서드가 존재하지 않기 때문에 에러가 발생한다.</p>
<pre><code>const a = null;

String(a); // "null"

a.toString(); // Uncaught TypeError: Cannot read property 'toString' of null
</code></pre>
<p>에러 핸들링은 현업에서 매우 깊게 다룰 주제이나, 알고리즘 문제 풀이시에는 에러를 빨리 내는게 디버깅을 편하게 한다. 계산을 다 하고 나서 "null"이 출력되면 이게 어디서부터 발생하는지 찾으러 가는게 더 어려워질 수 있다. 빠르게 에러를 발생시키자.
어떤 걸 쓸지는 취향차이지만, 어떠한 차이가 있을 수 있는지 알아두면 좋다.</p>
<h4>0, -0</h4>
<p>자바스크립트에는 0이 두가지가 있다. 양의 0과 음의 0. 이 둘을 구분해서 쓰는 경우는 현실적으로 없다.</p>
<pre><code>0 === -0; // true
</code></pre>
<p>그런데 주의해야할 때가 있다. 바로 문자열로 변환할 때이다.
-0 을 문자열으로 변환하면 "-0" 이 된다.</p>
<p>-0 을 임의로 할당하는 경우는 거의 없다. 주로 나오는 경우는 음수를 Infinity 로 나눈 값을 할당한 경우다. 상당히 디버깅이 까다로운 케이스중 하나인데, 왜냐하면 이론적으로는 다 맞기 때문이다. 테스트 케이스중에 이런 경우가 존재하는지 잘 판단해야 한다. 아니면 Infinity 로 나눌 때에는 명시적으로 Math.abs() 로 감싸는 것도 하나의 방법이다.</p>
<h3>소수를 정수로 변환</h3>
<p>Number.isInteger => 정수인지 판별 가능</p>
<p>Math.floor, Math.ceil, Math.round, Math.trunc,</p>
<h3>bigint</h3>
<p>큰 수를 다룰 때에 bigint 자료형을 쓴다.</p>
<p>BigInt 함수로 변환</p>
<p>number 와 bigint 자료형은 암시적으로 형변환이 되지 않는다.</p>
<p>리터럴 기재할 때 끝에 n을 쓰면 된다.</p>
<pre><code>0n;

1n;

1038428n;
</code></pre>
<p>bigint를 그냥 console.log로 찍어보면 끝에 n이 기재되어 출력되지만, 문자열로 바꾸면 끝에 'n' 이 없다. 따라서 문자열로 바꿔서 반드시 출력하도록 하자. 안그러면 n도 같이 출력된다.</p>
<p>bigint => string 도 number => string 과 동일하다. toString, String 쓰면 된다.</p>
<h2>5. 입출력</h2>
<p>Node.js와 브라우저의 차이 중에 가장 두드러지는 점이 입출력이 아닐까 생각합니다.</p>
<p>브라우저에서는 유저로부터 입력을 어떻게 받고 어떻게 출력하나요?</p>
<p>로그인 폼을 생각해보겠습니다. 유저로부터 어떻게 id와 pw를 입력받나요?</p>
<p>input, form 요소로 입력을 받습니다. 그러면 결과물은 어떻게 출력하나요? 로그인이 성공적으로 수행되었다던가, 로딩중이라던가, 비밀번호가 일치하지 않는가 등의 결과를요.
다양한 방법이 있을 것입니다. window.alert 도 있을 수 있을거 같구요, 아니면 원하는 내용을 담은 새로운 DOM 요소를 추가하고 예쁘게 스타일링할 수도 있습니다.</p>
<p>Node.js는 브라우저가 아닌 일반 터미널에서 실행되죠. 흔히 생각하는 검은 바탕에서 흰 글자가 깜빡거리는 그 곳입니다.
특히 C와 같은 저수준의 언어를 해보셨다면 친숙한 환경이 아닐까 싶습니다.</p>
<p>브라우저가 유저로부터 입력을 받을 수 있기 위해 input, form요소와 이벤트 핸들러를 제공하듯이 Node.js는 유저로부터 입력을 받을 수 있는 내장 모듈 몇가지를 제공합니다.</p>
<h3>5-1. fs 모듈</h3>
<p>자바스크립트의 가장 큰 특징으로 꼽히는 것이 비동기 프로그래밍이기에 자바스크립트의 내장 모듈을 기본적으로 비동기로 처리됩니다. 하지만, 코딩테스트에서 입력을 받은 뒤에 계산을 하고 출력을 합니다. 계산 도중에 인터랙티브하게 유저로부터 입력을 받는 일이 없습니다. 따라서, 이벤트 드리븐 방식의 복잡한 readline 모듈을 사용할 필요가 전혀 없습니다.</p>
<p>전형적으로 동기적 실행이기 때문에 동기적으로 실행되는 fs 모듈의 readFileSync만을 소개하겠습니다.</p>
<p><code>fs</code>는 <code>file system</code>을 의미합니다. POSIX 시스템에서는 모든 프로세스에 대해 커널이 현재 열려 있는 파일 및 리소스 테이블을 유지 관리합니다. 열려 있는 각 파일에는 파일 설명자(file descriptor)라는 간단한 숫자 식별자가 할당됩니다. 시스템 수준에서 모든 파일 시스템 작업은 이러한 파일 설명자를 사용하여 각 특정 파일을 식별하고 추적합니다. 윈도우즈 시스템은 리소스를 추적하기 위해 다르지만 개념적으로 유사한 메커니즘을 사용합니다. 사용자를 위한 작업을 단순화하기 위해 Node.js는 운영 체제 간의 특정 차이를 추상화하고 열려 있는 모든 파일에 숫자 파일 설명자를 할당합니다. 참고로, 표준입력(stdin: standard input)의 파일 설명자는 0 입니다.</p>
<p><code>readFile</code>함수는 비동기적으로 파일의 전체를 읽으므로 파일을 읽어들이기가 완료된 후에 콜백 함수를 통하여 다음 스텝을 진행할 수 있는 반면, <code>readFileSync</code>는 동기적으로 파일을 읽어들입니다. 어차피 입력을 다 받아야만 계산을 진행할 수 있으므로, 동기적 처리 방식이 코드도 간결하고 이해하기 편합니다.</p>
<p><code>fs.readFileSync(path[, options])</code></p>
<ul>
<li>path: &#x3C;string> | &#x3C;Buffer> | &#x3C;URL> | &#x3C;integer> filename or file descriptor</li>
<li>options: &#x3C;Object> | &#x3C;string>
<ul>
<li>encoding &#x3C;string> | &#x3C;null> Default: null</li>
<li>flag &#x3C;string> See support of file system flags. Default: 'r'.</li>
</ul>
</li>
<li>Returns: &#x3C;string> | &#x3C;Buffer></li>
</ul>
<pre><code>const fs = require("fs");

// 개행문자(\n)로 구분된 각 행을 요소로 가지는 배열을 반환.
// 인코딩을 명시적으로 넘기지 않은 경우에는 raw Buffer가 반환되므로
// toString()함수를 호출하여 string으로 변환하여야 한다.
const input1 = fs.readFileSync(0).toString().split("\n");

// options으로 인코딩을 string 자료형으로 넘기는 경우, string을 반환한다.
const input2 = fs.readFileSync(0, "utf8").split("\n");

// input2와 동일
const input3 = fs.readFileSync(0, { encoding: "utf8" }).split("\n");
</code></pre>
<p>참고: <a href="https://nodejs.org/dist/latest-v14.x/docs/api/fs.html#fs_file_system">Node.js v14.15.4 Documentation - File system</a></p>
<h4>readFileSync 는 파일 전체를 한 번에 읽어들인다</h4>
<p>한 줄 씩 읽어들여서 처리하지 않는다. 다 읽어들인다. 따라서 다 이를 한 줄씩 읽어들이는 것과 같은 효과를 내려면 보조함수를 작성하여야 한다.</p>
<p>클로저를 이용하여 변수의 스콥을 제한하고 한 줄씩 문자열을 반환하게끔 할 수 있다.</p>
<pre><code>const getLine = (() => {
  const input = require("fs").readFileSync(0, "utf8").split("\n");
  let i = 0;

  return () => input[i++];
})();
</code></pre>
<h3>5-2. 출력</h3>
<h4>console.log</h4>
<p>표준출력으로 console.log를 사용한다. console 객체는 브라우저에도 존재하고 Node.js 에도 존재하므로 매우 친숙할 것이다.
Node.js에서 더욱 저수준의 출력 내장 모듈을 제공하나 console.log 로 대부분 충분하다.</p>
<h4>다만, console.log는 굉장히 느리다</h4>
<p><code>console.log</code>를 이용해서 출력을 하면 됩니다.
다만,<code>console.log</code>는 호출시 많은 시간이 소요되는 함수이므로, 백트래킹과 같이 알고리즘 중간중간에 출력을 하는 경우에는 배열이나 <code>string</code>에 출력값을 저장해두었다가 계산 종료후 한번에 출력을 해주는 것이 좋습니다.</p>
<p>아래는 <a href="https://www.acmicpc.net/problem/15649">BOJ 15649번 문제 N과 M (1)</a>의 채점결과입니다. 위에는 계산 종료후 코드의 마지막에 한번만 출력을 해준 경우이고, 아래는 계산 중간중간에 계속해서 출력을 해준 경우입니다. 보시다시피 실행 시간의 차이가 엄청 많이 나신다는 것을 알 수 있습니다.</p>
<pre><code>// 계산 종료후 마지막에 한번만 출력
...
let print = "";

(function rec(lev) {
  if (lev === M) {
    print += `${arr.join(" ")}\n`; // depth가 M일 때마다 print에 출력 값 저장
    return;
  }

  ...
  rec(lev + 1);
  ...
})(0);

console.log(print); // 계산 종료후 마지막에 출력
</code></pre>
<pre><code>// 계산 중간중간에 출력
...

(function rec(lev) {
  if (lev === M) {
    console.log(`${arr.join(" ")}\n`); // depth가 M일 때마다 print에 출력 값 저장
    return;
  }

  ...
  rec(lev + 1);
  ...
})(0);
</code></pre>
<p><img src="https://images.velog.io/images/bigsaigon333/post/14c5f8aa-2f4a-4f4a-be0d-6399d5863abc/%ED%95%9C%EB%B2%88%EC%97%90_%EC%B6%9C%EB%A0%A5_vs_%EB%A7%A4%EB%B2%88_%EC%B6%9C%EB%A0%A5.png" alt="BOJ 15649번 문제 채점결과"></p>
<p>※ <code>process.stdout.write</code> vs <code>console.log</code>
Writable 스트림인 <code>process.stdout</code>의 <code>write</code>함수를 이용하여 출력을 할 수 있습니다. <code>console.log</code>도 내부적으로 <code>process.stdout.write</code>를 이용하여 출력한다고 합니다. 하지만 경험적으로 <code>console.log</code>와 <code>process.stdout.write</code>의 실행속도 차이를 느끼지 못하였습니다. <code>console.log</code>, <code>process.stdout.write</code> 모두 무거운 함수 호출이므로, 이를 최소화하기 위하여 배열이나 <code>string</code>에 출력값을 저장해두는 테크닉이 더 실행속도 단축에 도움이 되는 것 같습니다.</p>
<p>참고URL: <a href="https://nodejs.org/dist/latest-v14.x/docs/api/stream.html#stream_writable_write_chunk_encoding_callback">Node.js v14.15.4 Documentation - Writable Stream: writable.write(chunk[, encoding][, callback])</a></p>
<h3>5-3. BOJ 1000</h3>
<h4>마지막의 공백문자, 개행문자는 무시된다</h4>
<h3>5-4. 함수형 타입의 코딩테스트</h3>
<p>앞서 설명한 입출력이 굉장히 번거롭게 느껴지기도 한다. FE 개발자들은 Node.js 파일시스템 내장 모듈을 사용할 일이 생각보다 없다. 그래서 기업에서도 그냥 입출력으로 문제를 판단하는게 아니라 함수를 작성할 것을 요구한다. 함수의 매개변수로 입력값을 넣어주고, 출력값을 함수의 반환값으로 하라는 것이다.</p>
<p>오히려 좋아.</p>
<p>input compute output 의 3단계로 구분해서 문제를 풀자</p>
<p>BOJ는 input compute output 3단계를 다 구현하는 것이고</p>
<p>Programmers는 compute만 구현하는 것이라 생각하면 된다.</p>
<p>그러면 다 대응된다.</p>
<h2>6. 문제풀이 예시</h2>
<h3>6-1. 한수 - acmicpc.net/problem/1065</h3>
<ul>
<li>문제 읽고 이해</li>
<li>입력의 조건 이해
N: [1, 1000]</li>
<li>생각은 큰 단위에서 작은 단위로</li>
<li>구현은 작은 단위에서 큰 단위로</li>
<li>isHansu: (n: number) => boolean;
isHansu(1) === true
isHansu(246) === true
isHansu(247) === false</li>
</ul>
<hr>
<p>isHansu 구현
1자리수
2자리수
3자리수 이상
3_2_5 공차가 마이너스일 수도 있다</p>
<p>1부터 N까지 순회하면서 isHansu가 true이면 count를 1씩 증가</p>
<p>계산된 count를 반환후 stdout으로 출력</p>
<p>테스트</p>
<p>실제 제출</p>
<hr>
<p>왜 완전탐색인가? 1부터 N까지 순서대로 모든 숫자가 한수인지 isHansu 에 인자를 넣어서 확인했다
O(N logN) 이다</p>
<p>N이 만약 2자리수, 즉 99이하이면 그냥 N을 반환하게 할 수도 있다.
그러면 N이 99 이하이면 O(1) 이 된다
isHansu 조건이 굉장히 복잡하다고 가정했을 때에도, isHansu의 시간복잡도가 낮다면, 하나씩 다 탐색하여서 문제를 풀어낼 수 있다.</p>
<hr>
<p>포인트 1) 자료형을 명확하게 표기하자: 암시적 형변환에 의존하면, 나중에 큰일 난다</p>
<p>포인트 2) for 문을 줄일 수 있다면 줄이자. 이번에는 Option!</p>
<ul>
<li>배열의 한 요소가 다른 요소는 간섭하지 않는다.</li>
<li>상위 스코프의 값을 참조하지 않는다 => 순수함수이다
for 문보다 배열 내장 메소드가 먼저 떠오를만큼 숙달된다면 바로 쓰자!
왜 강조? 이게 바로 자바스크립트다운 배열 순회 방법. 기능의 분리.
Brute Force와 동일. 내가 익숙한 문법으로 정확하게 작성할 수 있다면 그걸로 keep going.
아니라면 이런 방법도 같이 익혀가면, 알고리즘 공부하면서 작성한 코드 스킬들이 나중에 프로젝트에서도 도움이 된다</li>
</ul>
<hr>
<h3>https://www.acmicpc.net/problem/2798</h3>
<p>시간복잡도에 너무 집착하지 마라</p>
<p>브루트 포스로 충분하면 그걸로 충분</p>
<p>면접때도 똑같이 말하면 된다. Keep it simple and stupid</p>
<p>단순한게 오히려 이해하기에 편하기 때문. 진짜 문제가 되면 그때 더 연구하겠다고 답변하면 된다.</p>
</main><footer class="sc-8d5d6634-1 dsDnMD">Copyright© 2022 All right reserved</footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"draft:js-algorithm-ch2","contentHtml":"\u003cp\u003e앞으로 여러가지 알고리즘을 학습하게 될텐데요, 동일한 기능을 수행하는 알고리즘이 여러가지가 있을 수 있습니다. 예를 들어 정렬 알고리즘에서는 버블 정렬, 선택 정렬, 삽입 정렬, 머지 소트, 퀵 소트 등 여러가지 알고리즘을 수행해서 배열을 정렬할 수가 있습니다. 이러한 정렬 알고리즘 간에 어떤 것이 더 효율적인지를 어떻게 알 수 있을까요?\n알고리즘의 효율성을 분석할 때는 시간 복잡도와 공간 복잡도의 두 가지 방법을 이용합니다.\u003c/p\u003e\n\u003ch2\u003e1. 시간복잡도\u003c/h2\u003e\n\u003cp\u003e시간복잡도란 주어진 입력에 따라 알고리즘이 문제를 해결할 때 걸리는 시간을 의미합니다.\u003c/p\u003e\n\u003cp\u003e~~시간복잡도란 입력의 크기와 문제를 해결하는데 걸리는 시간의 상관관계를 의미합니다.~~\u003c/p\u003e\n\u003cp\u003e입력의 크기가 1일 때와 100일 때 걸리는 시간이 상이할텐데, 어떤 알고리즘은 입력의 크기가 100배 차이 나면 시간도 100배 차이 나는 알고리즘도 있고, 100배가 아니라 10,000배 차이가 날수도 있고, 2^100 배 차이가 날수도 있고, 동일한 시간이 걸릴 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e이러한 시간복잡도를 나타내는 방법 중에 많이 사용되는 것이 빅 오 표기법(Big O Notation) 입니다.\u003c/p\u003e\n\u003ch3\u003e1-1. 빅 오 표기법이란?\u003c/h3\u003e\n\u003cp\u003e빅 오 표기법의 수학적 정의는 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eO(g(n)) = {f(n): 모든 n \u003e= n0에 대해 0 \u0026#x3C;= f(n) \u0026#x3C;= cg(n)인 양의 상수 c, n0가 존재한다.}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e굉장히 복잡해보이죠?\u003c/p\u003e\n\u003cp\u003e직관적으로 그냥 설명해보겠습니다.\u003c/p\u003e\n\u003cp\u003e~~빅 오 표기법은 주어진 입력값 N에 대하여 알고리즘을 수행할 때 필요한 단계수를 N을 사용하여 나타낸 방법입니다.~~\u003c/p\u003e\n\u003cp\u003e빅 오 표기법은 주어진 입력값이 증가할 때 해당 알고리즘 수행에 필요한 단계수가 어떻게 증가하는지를 나타낸 것입니다.\u003c/p\u003e\n\u003cp\u003e빅 오 표기법에 대해서 구체적인 예시를 통해서 조금 더 살펴보도록 하겠습니다.\u003c/p\u003e\n\u003ch4\u003e예시1) 배열에 특정 요소가 포함되어 있는지 확인하는 함수\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003efunction includes(target: number, arr: number[]): boolean;\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e이러한 표기법이 조금 낯설게 느껴지실텐데요, 이는 타입스크립트에서 사용하는 함수 타입을 나타낼 때 쓰는 방법입니다. 콜론 뒤의 값이 해당 변수의 타입을 나타내고, 마지막에 함수의 선언 이후에 기재된 boolean은 이 함수의 반환값의 타입을 나타냅니다.\u003c/p\u003e\n\u003cp\u003e이렇게 함수의 구현이 아니라 입력과 반환값의 타입만을 나타내는 것을 함수의 시그니쳐라고 말합니다.\u003c/p\u003e\n\u003cp\u003e저희는 타입스크립트로 구현하지는 않지만, 여러분들과 저와 함수를 구현하기 전에 이러한 형태의 함수를 구현해나갈거에요 라는 걸 말할 때 이런 표기법으로 종종 설명드리도록 하겠습니다.\u003c/p\u003e\n\u003cp\u003e즉, \u003ccode\u003eincludes\u003c/code\u003e 라는 함수는 number 타입인 target과 number 타입의 배열인 arr을 차례로 매개변수로 전달받아 arr에 target이 포함되어 있으면 true를, 포함되어 있지 않다면 false를 반환하는 함수입니다.\u003c/p\u003e\n\u003cp\u003e예를 들어 보면 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eincludes(3, [1, 2, 3]); // true\nincludes(10, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]); // false\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이를 단순하게 구현해 본다면 이렇게 될 수 있겠죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction includes(target, arr) {\n  let isFound = false;\n\n  for (let i = 0; i \u0026#x3C; arr.length; i++) {\n    if (arr[i] === target) {\n      isFound = true;\n    }\n  }\n\n  return isFound;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003etarget은 항상 단 하나의 숫자이고, arr은 배열에 포함된 전체 요소의 갯수가 매번 다르겠죠. 그렇다면 여기서는 arr 배열에 포함된 전체 요소 개수를 N이라고 해보겠습니다.\u003c/p\u003e\n\u003cp\u003e그렇다면 includes 함수는 target을 찾기 위해 몇단계가 필요한가요?\u003c/p\u003e\n\u003cp\u003eN = 1 일 때, target과 일치하는지 하나의 요소만 비교하면 되니 1번입니다.\nN = 2 일 때, target과 일치하는지 0번째 요소와 1번째 요소를 비교해야 하니 2번입니다.\nN = 10일 때, 0번째 요소부터 9번째 요소까지 다 비교해야하니 10번입니다.\n즉, N이 증가하면 그에 선형적으로 비례해서 단계수가 증가합니다.\u003c/p\u003e\n\u003cp\u003e그래프로 그려보면 아래와 같습니다.\u003c/p\u003e\n\u003cp\u003e이러한 includes 함수의 시간복잡도를 나타낼 때에 배열에 포함된 요소의 개수를 N이라고 할 때 \u003ccode\u003eO(N)\u003c/code\u003e이다 라고 표현합니다.\u003c/p\u003e\n\u003ch4\u003e예시2) 두 배열에 공통적으로 포함된 요소를 계산하는 함수\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003efunction intersection(a:number[], b:number[]): number[]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eintersection([3, 4], [1, 2, 3]); // [3]\nintersection([0, 2, 3, 4, 5, 6, 8, 9], [4, 1, 7, 9]); // [4, 9]\nintersection([10, 11, 12], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]); // []\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003efunction intersection(a, b) {\n  const result = [];\n\n  for (let ai = 0; ai \u0026#x3C; a.length; a++) {\n    for (let bi = 0; bi \u0026#x3C; b.length; b++) {\n      if (a[ai] === b[bi]) {\n        result.push(a[ai]);\n      }\n    }\n  }\n\n  return result;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ea 배열에 포함된 요소의 개수를 N, b 배열에 포함된 요소의 개수를 M이라고 할 경우,\na 배열에 포함된 요소를 모두 순회하면서 해당 요소가 b 배열에 포함된 요소인지를 b 배열을 모두 순회하면서 비교하여야 합니다.\u003c/p\u003e\n\u003cp\u003ea 배열에 포함된 요소의 개수가 10개에서 20개로 2배가 된다면, 순회횟수도 2배 증가합니다.\nN과 M 각각에 선형적으로 비례하여 증가하므로,\n\u003ccode\u003eO(NxM)\u003c/code\u003e\u003c/p\u003e\n\u003ch4\u003e예시3) 주어진 수가 짝수인지 확인하는 함수\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003efunction isEven(n: number): boolean;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eisEven(1); // false\nisEven(2); // true\nisEven(3); // false\nisEven(100); // true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003efunction isEven(n) {\n  if (n % 2 === 0) return true;\n  else return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003en이 1에서 10000이 되더라도 나누어서 나머지가 0인지 확인하는 단계수는 증가하지 않습니다.\u003c/p\u003e\n\u003cp\u003e즉, n이 증가하더라도 단계수가 증가하지 않으므로 \u003ccode\u003eO(0)\u003c/code\u003e 이라고 표현해야 할 거 같은데, 일반적으로 n^0 에 비례한다고 하여 \u003ccode\u003eO(n^0) = O(1)\u003c/code\u003e 이라고 표현합니다.\u003c/p\u003e\n\u003ch3\u003e1-2. 빅 오 표기법의 특징\u003c/h3\u003e\n\u003ch4\u003ea) 최대차수의 항만 고려하며 상수계수는 무시한다\u003c/h4\u003e\n\u003ch4\u003eb) 같은 O(N) 이라고 해서 동일하게 빠른게 아니다\u003c/h4\u003e\n\u003ch4\u003ec) 항상 O(N) \u0026#x3C; O(N^2) 이 아니다\u003c/h4\u003e\n\u003ch4\u003ed) 빅 오 표기법의 정의는 최악의 상황의 성능을 나타내지만, 관행적으로 최선과 평균을 나타낼 때도 사용한다\u003c/h4\u003e\n\u003ch3\u003e1-3. 코딩테스트에서 빅 오 표기법을 어떻게 사용해야 하는가\u003c/h3\u003e\n\u003cp\u003e제한시간이 주어지는 문제가 있다. 구체적인 제한시간이 주어지지 않더라도 매우 많은 시간을 사용한다면 채점사이트에서 이를 무작정 기다릴 수 없으므로 일정 시간이 지나면 오답으로 처리한다.\u003c/p\u003e\n\u003cp\u003e일반적으로 아래와 같다. 하지만 1-2. 빅 오 표기법의 특징에서 말했듯이 N의 크기가 작으면 반드시 아래가 성립하지 않는다. 하지만 N이 충분히 커진다면 아래의 관계가 성립한다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eO(1) \u0026#x3C; O(logN) \u0026#x3C; O(N) \u0026#x3C; O(NlogN) \u0026#x3C; O(N^2) \u0026#x3C; O(2^N) \u0026#x3C; O(N!)\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eO(1)은 상수형 알고리즘...\nO(logN)은 로그형 알고리즘 ..\n(각각의 알고리즘 글로 한 번더 소개)\u003c/p\u003e\n\u003cp\u003eNode.js 로 1초에 대략 4000만번의 연산을 수행할 수 있다고 가정할 때, 1초내 수행할 수 있는 연산 수는 아래와 같다.\u003c/p\u003e\n\u003cp\u003e내가 떠올린 알고리즘의 빅오표기법이 O(N^2) 이고 최대 N이 10000이라면, 제한시간이 1초라면은 내가 아무리 알고리즘을 잘 구현하더라도 제한시간내에 되지 않겠구나 라고 추측할 수 있다. 그러나 빅오표기법에서 상수항은 무시하므로 정확하게 일치하는 것은 아니다. 대략적인 느낌만 잡아가면 된다.\u003c/p\u003e\n\u003ch2\u003e2. 공간복잡도\u003c/h2\u003e\n\u003cp\u003e공간복잡도란 알고리즘이 문제를 해결할 때 점유하는 컴퓨터의 메모리 공간을 뜻합니다.\u003c/p\u003e\n\u003cp\u003e공간복잡도에서도 빅 오 표기법의 개념을 가져와서 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e공간복잡도에서 빅 오 표기법은 주어진 입력값 N이 증가할 때 해당 알고리즘을 수행할 때 필요한 메모리가 어떻게 증가하는지를 N을 사용하여 나타냅니다.\u003c/p\u003e\n\u003ch3\u003e예제) 문자열 배열을 받아 모두 대문자로 바꾼 배열을 반환하는 함수\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003efunction makeUpperCase(arr: string[]): string[];\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003emakeUpperCase([\"apple\", \"banana\", \"cinnamon\"]); // [\"APPLE\", \"BANANA\", \"CINNAMON\"]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003efunction makeUpperCase(arr) {\n  return arr.map((str) =\u003e str.toUpperCase());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수를 공간복잡도 관점에서 분석하면 원소 N개를 포함하는 새로운 배열을 생성합니다. 즉, 원래 주어진 배열 이외에 메모리를 더 소모합니다.\u003c/p\u003e\n\u003cp\u003e함수가 데이터 원소 N개 증가하면 N개의 메모리를 추가로 소모하므로 이 함수의 공간 복잡도는 O(N) 입니다.\u003c/p\u003e\n\u003cp\u003e메모리 효율적인 함수로 변경해보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction makeUpperCase(arr) {\n  for (let i = 0; i \u0026#x3C; arr.length; i++) {\n    arr[i] = arr[i].toUpperCase();\n  }\n\n  return arr;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e새 배열을 생성하지 않고 원래 배열을 수정하고, 수정된 배열을 반환합니다.\n어떤 메모리도 추가로 소모하지 않으니 메모리 소모 관점에서는 엄청난 성능 향상입니다.\u003c/p\u003e\n\u003cp\u003e빅 오 표기법에 따르면 주어진 입력값이 증가하더라도 추가적으로 전혀 메모리를 소모하지 않으므로 O(N^0) = O(1) 입니다.\u003c/p\u003e\n\u003cp\u003e공간복잡도를 빅 오 표기법으로 나타낼 때에는 알고리즘에서 새로 생성한 데이터만 고려합니다. 원래 배열은 언제든 존재하고 알고리즘에서 추가로 소모하는 공간이 중요하니 원래 데이터 원소 N개는 빅 오로 나타낼 때 감안하지 않습니다.\u003c/p\u003e\n\u003cp\u003e버젼1과 버젼2의 시간 복잡도와 공간 복잡도를 모두 비교해보면 다음과 같습니다.\u003c/p\u003e\n\u003cp\u003e| 버전  | 시간 복잡도 | 공간 복잡도 |\n| ----- | ----------- | ----------- |\n| 버전1 | O(N)        | O(N)        |\n| 버전2 | O(N)        | O(1)        |\u003c/p\u003e\n\u003cp\u003e버젼1과 버젼2 을 비교하였을 때 시간 복잡도는 동일하나 버전2가 공간 복잡도가 더 낮아졌으니 효율성 측면에서는 버젼2가 더 유리하다고 판단할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그러나 공간 복잡도와 시간 복잡도의 관계가 항상 이러한 것만은 아닙니다.\u003c/p\u003e\n\u003ch3\u003e시간과 공간의 트레이드 오프\u003c/h3\u003e\n\u003ch4\u003e두 수의 합 문제\u003c/h4\u003e\n\u003cp\u003e숫자 배열을 입력받아 합해서 10(또는 주어진 다른 수)이 되는 두 수가 배열에 있는지를 true나 false로 반환하는 함수를 작성하면 된다. 단순하게 풀기 위해 배열에 중복은 없다고 가정합니다.\u003c/p\u003e\n\u003cp\u003e버젼1 시간복잡도: O(N^2) 공간복잡도: O(1)\u003c/p\u003e\n\u003cp\u003e버젼2 시간복잡도: O(N) 공간복잡도: O(N)\u003c/p\u003e\n\u003ch4\u003e또다른 예시로는 정렬도 있다.\u003c/h4\u003e\n\u003cp\u003e선택 정렬\n머지 소트\n퀵 소트\u003c/p\u003e\n\u003cp\u003e자세히 설명하지는 않겠다. 일반적으로 코딩테스트에서 정렬\u003c/p\u003e\n\u003ch4\u003e일반적으로는 시간 복잡도를 더 중요시 여긴다\u003c/h4\u003e\n\u003cp\u003e특히 자바스크립트에서는 함수형 프로그래밍의 개념을 많이 차용하여 사용되는데, 공간복잡도를 희생해서 더 빠른 시간복잡도를 얻는 것을 좋게 여긴다. 버젼2의 경우, 입력값을 변경시키는데 이는 함수형 프로그래밍에서 강조하는 순수 함수의 정의에 어긋난다.\n이 입력값을 다른 곳에서 또 쓴다면, 버젼2를 통과한 입력값은 값이 변경되어있어 의도치 않은 버그를 일으킬 수 있다. 버젼2와 같이 실제 함수에 전달된 원본 배열을 수정하는 것을 제자리(in-place) 수정이라고 불린다.\u003c/p\u003e\n\u003cp\u003e의도적으로 메모리 제한을 적게 주는 문제가 BOJ에는 있다. 그러나 일반적인 코딩테스트에서는 잘 나오지 않는다. 다만, 굉장히 큰 자료구조를 여러번 생성하거나 하면... 굉장히 속도가 느려져서 오히려 통과가 안되는 경우가 있다. 또 넉넉한 메모리를 통해서 손쉽게 풀 수 있는 알고리즘이 있다. 카운팅 소트 등...\u003c/p\u003e\n\u003cp\u003e또 재귀에서는 호출 스택이라는 숨겨진 공간복잡도가 있는데 이 부분에 대해서는 재귀 챕터에서 자세히 다루겠다.\u003c/p\u003e\n\u003ch4\u003e문제를 풀 때 시간 복잡도와 공간 복잡도를 잘 고려하자.\u003c/h4\u003e\n\u003cp\u003e각 상황마다 주어진 최소 허용 속도와 메모리 한도를 알아야 한다. 제약을 이해하고 다양한 알고리즘 중에서 고르고 선택할 수 있고 속도와 메모리 요구사항에 맞게 효율성을 유지할 수 있다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e자바스크립트에서는 순수 함수의 개념을 이용하여 새로운 변수를 매번 정의하는 것을 선호하는 패턴이 현업에서도 일반적이므로 이러한 패턴을 적용하는 컨벤션을 익히는 것이 실제 알고리즘 문제 풀이에 미치는 영향을 알고 있어야 한다. 그래서 공간복잡도 때문에 초과되면 빠르게 이러한 패턴을 포기할 줄도 알아야 한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e3. 숫자를 다룰 때 주의할 점: 부동소수점\u003c/h2\u003e\n\u003ch3\u003e3-1. 0.3 - 0.2 === 0.1\u003c/h3\u003e\n\u003cp\u003econsole.log(0.3 - 0.2 === 0.1) 을 자바스크립트로 실행시키면 true가 출력될까요 false가 출력될까요??\u003c/p\u003e\n\u003cp\u003e웬 뜬금없는 질문이냐고 생각하실 수 있는데요, 정답은 false 입니다.\u003c/p\u003e\n\u003cp\u003e당황하신 분도 계실 것 같아요. 이때까지 내가 배워온 수학이 뭔가 잘못되었던 걸까?\u003c/p\u003e\n\u003cp\u003e하지만 그렇지 않습니다. 이론적으로는 0.3 - 0.2 === 0.1 은 true가 맞습니다. 우리가 사용하는 일상생활에서 사용하고 있는 숫자 체계는 10진법이죠.\n0 ~ 9 까지의 숫자를 사용하고, 한 자리수를 추가할 때마다 10이 곱해집니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e235 = 2 * 10 ^ 2 + 3 * 10 ^ 1 + 5 * 10 ^ 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e소숫점도 동일합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e38.746 = 3 * 10 ^ 1 + 8 * 10 ^ 0 + 7 * 10 ^ (-1) + 4 * 10 ^ (-2) + 6 * 10 ^ (-3)\n\n0.3 = 3 * 10 ^ (-1)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 컴퓨터는 내부적으로 0 과 1의 숫자만을 사용해서 한 자리수를 추가할 때마다 2가 곱해지는 2진법을 사용하고 있죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e38.746 = 100110.10111110111110011101101100100010110100001110011\n0.3 = 0.010011001100110011001100110011001100110011001100110011\n0.2 = 0.001100110011001100110011001100110011001100110011001101\n0.1 = 0.0001100110011001100110011001100110011001100110011001101\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e0.3은 10진법으로 표기할 때는 딱 떨어지는 깔끔한 숫자입니다\u003c/p\u003e\n\u003cp\u003e그런데 2진법으로 표기하면 딱 떨어지지 않습니다.\u003c/p\u003e\n\u003cp\u003e1/3 을 예시로 들어볼까요?\u003c/p\u003e\n\u003cp\u003e1/3 을 소수로 나타내면 \u003ccode\u003e0.3333333333333333\u003c/code\u003e 이고 3을 무한대로 계속해서 적어야 합니다. 이론적으로는 3을 무한대로 적으면 되는데 실생활에서는 이를 무한대로 적을 수가 없죠. 그래서 과학이라는 분야에서는 유효범위라는 걸 정해서 몇자리수까지는 유효하다 이렇게 표현하기도 합니다.\u003c/p\u003e\n\u003cp\u003e0.3은 2진법으로 표기하면 마치 10진법의 1/3 처럼 딱 떨어지지가 않습니다.\n\u003ccode\u003e0.010011001100110011001100110011001100110011001100110011\u003c/code\u003e\n1100 이 계속해서 반복되죠. 컴퓨터는 유한한 메모리 내에서 이 수를 표현해야 하기 때문에 이 또한 정확하지가 않습니다.\n0.2, 0.1 또한 마찬가지입니다.\u003c/p\u003e\n\u003cp\u003e따라서 정확하게 일치하지 않는 것입니다.\u003c/p\u003e\n\u003cp\u003e반대로 정확하게 표시되는 수가 무엇이 있을까요?\n바로 0.5, 0.25 와 같은 수가 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e0.5 = 1 * 2 ^ (-1)\n0.25 = 0 * 2 ^ (-1) + 1 * 2 ^ (-2)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그렇기 때문에 0.5 - 0.25 === 0.25 는 true가 됩니다.\u003c/p\u003e\n\u003ch3\u003e3-2. double-precision 64-bit binary format IEEE 754\u003c/h3\u003e\n\u003cp\u003ehttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number\u003c/p\u003e\n\u003cp\u003e자바스크립트에서 숫자를 나타내는 원시자료형(primitive type)은 두가지가 있습니다. number와 bigint 입니다.\u003c/p\u003e\n\u003cp\u003ebigint는 ES2020에 추가된 스펙인데, 여기서는 일단 number에 대해서만 알아보도록 하겠습니다.\u003c/p\u003e\n\u003cp\u003e유한한 메모리 구조 내에서 number를 나타내기 위해서 사용되는 여러가지 표준이 있는데, 그 중에서 자바스크립트는 double-precision 64-bit binary format IEEE 754 로 숫자를 표현하는데, 간단히 설명드리자면\u003c/p\u003e\n\u003cp\u003e0 또는 1의 값을 가지는 64개의 비트로 숫자를 나타내며,\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e가수부 x 2 ^ (지수부)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e부호(sign) 1비트, 지수(exponent) 11비트, 가수(fraction) 52비트로 나타냅니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/61345d47f069d645947b9c0ab676c75551f1b188\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/300577464b37b5769a97e85aa67c56200e1011df\" alt=\"\"\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e0.3 = 0 01111111110 0100110011001100110011001100110011001100110011001100\n\n0.3 = (-1)^0 * (1.0100110011001100110011001100110011001100110011001100) * 2 ^ (01111111110 - 01111111111)\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e가장 큰 수\u003c/h4\u003e\n\u003cp\u003ehttps://en.wikipedia.org/wiki/Double-precision_floating-point_format\u003c/p\u003e\n\u003cp\u003e따라서 이러한 정의에 따라 표현할 수 있는 가장 큰 숫자는 아래와 같고, 이는 Number.MAX_VALUE 로 접근 가능.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e0 11111111110 1111111111111111111111111111111111111111111111111111\n≙ 7FEF FFFF FFFF FFFF16\n≙ +2 ^ 1023 × (1 + (1 − 2^ (−52))\n≈ 1.7976931348623157 × 10 ^ 308\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e가장 작은 수\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eNumber.MIN_VALUE === 5e-324\u003c/code\u003e\u003c/p\u003e\n\u003ch4\u003e그래서 연산시에 주의할 점\u003c/h4\u003e\n\u003cp\u003e소수간의 비교를 할 때 정확하게 일치하는지로 구분하면 안된다. 소수 자체가 정확하게 표현되어 있지 않기 때문에 무조건 오차가 발생하기 때문에.\n그래서 실제값과 기대값의 차이가 일정 범위 안에 있는지를 확인하는게 좋다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e(0.3 - 0.2) - 0.1 \u0026#x3C; Number.EPSILON\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e절대오차 상대오차 개념\u003c/h5\u003e\n\u003cp\u003e절대오차 = | 내가 제출한 답 - 정답 |\u003c/p\u003e\n\u003cp\u003e상대 오차 = | 내가 제출한 답 - 정답 | / 정답\u003c/p\u003e\n\u003ch4\u003eEPSILON 이란...\u003c/h4\u003e\n\u003cp\u003eNumber.EPSILON\nThe value of Number.EPSILON is the Number value for the magnitude of the difference between 1 and the smallest value greater than 1 that is representable as a Number value, which is approximately 2.2204460492503130808472633361816 × 10-16.\u003c/p\u003e\n\u003ch4\u003e가장 큰 양의 정수\u003c/h4\u003e\n\u003cp\u003ehttps://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-properties-of-the-number-constructor\u003c/p\u003e\n\u003cp\u003eThe value of Number.MAX_SAFE_INTEGER is 9007199254740991𝔽 (𝔽(2**53 - 1)).\u003c/p\u003e\n\u003ch4\u003e가장 작은 음의 정수\u003c/h4\u003e\n\u003cp\u003eThe value of Number.MIN_SAFE_INTEGER is -9007199254740991𝔽 (𝔽(-(2**53 - 1))).\u003c/p\u003e\n\u003ch3\u003e3-3. Infinity\u003c/h3\u003e\n\u003cp\u003e무한대의 숫자를 나타낼 때 Infinity를 사용한다.\n음의 무한대는 -Infinity\u003c/p\u003e\n\u003cp\u003eInfinity 는 어떠한 연산을 사용하더라도 절대 도달할 수 없는 값이므로 최초값을 할당할 때 많이 쓴다\u003c/p\u003e\n\u003cp\u003e예를 들어서 배열의 가장 작은 값을 찾는 함수\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efuntion min(arr: number[]):number\u003c/code\u003e 가 있다고 가정해보자.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\nfunction min(arr) {\n  let min = Infinity;\n\n  for(const num of arr) {\n    if (min \u003e num) {\n      min = num;\n    }\n  }\n\n  return min;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emin의 초기값으로 Infinity를 할당하면 for - of 루프의 첫번째 패스스루에서 항상 min 이 num 보다 크게 되어 min = num 이 실행된다.\u003c/p\u003e\n\u003ch2\u003e4. 자료형변환\u003c/h2\u003e\n\u003ch3\u003e4-1. 암시적 형변환\u003c/h3\u003e\n\u003cp\u003e서로 다른 자료형간의 연산을 수행하면 자바스크립트에서는 암시적 형변환이 일어난다. 예를들어 다음과 같다\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n\"1\" + 1 === \"11\"\n\"1\" - 1 === 0\n\ntrue + 1 === 2\n[] + 2 === \"2\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e명시적으로 자료형을 변환해서 쓰자. 암시적을 몰라도 된다는건 아니지만 명시적 형변환이 더욱 의도를 명확하게 한다.\u003c/p\u003e\n\u003cp\u003e특히 변수 선언시에 자료형을 기재하지 않는 자바스크립트의 경우, 이를 습관화 하지 않으면 나중에 디버깅을 굉장히 어렵게 한다.\u003c/p\u003e\n\u003ch4\u003e동등 연산자(\u003ccode\u003e==\u003c/code\u003e)보다 일치 연산자(\u003ccode\u003e===\u003c/code\u003e)를 우선시 하자\u003c/h4\u003e\n\u003ch3\u003e4-1. string =\u003e number\u003c/h3\u003e\n\u003ch4\u003eNumber vs parseInt(parseFloat) vs new Number\u003c/h4\u003e\n\u003ch5\u003eNumber vs new Number\u003c/h5\u003e\n\u003cp\u003e\u003ccode\u003eNumber\u003c/code\u003e 는 function으로서 작용하여 primitive type을 반환하지만, \u003ccode\u003enew Number\u003c/code\u003e는 constructor로서 작용하여 Object를 반환합니다.\u003c/p\u003e\n\u003cp\u003e큰 차이가 없어 보이지만, 차이는 있습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eObject\u003c/code\u003e는 boolean context에서 항상 \u003ccode\u003etrue\u003c/code\u003e입니다. 따라서 이를 의식하지 않고 코딩을 하다보면 일반적으로 생각하는 것과 다른 움직임을 보일 수 있습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003econst a = Number(\"0\");\nconst b = new Number(\"0\");\n\nif (a) {   // false 이므로 조건문 내부는 실행되지 아니함\n...\n}\n\nif (b) { // `Object([Number: 0])`는 boolean context에서 `true`이므로 조건문 내부가 실행됨\n...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eObject와 primitive type 의 === 비교시 false가 반환됩니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003econst a = new Number(\"123\");\nconsole.log(a === 123); // false\n\nconst b = Number(\"123\");\nconsole.log(b === 123); // true\n\nconsole.log(a instanceof Number); // true\nconsole.log(b instanceof Number); // false\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e혼란을 피하기 위하여 ** new Number는 사용하지 않습니다.**\u003c/p\u003e\n\u003ch5\u003eNumber vs parseInt\u003c/h5\u003e\n\u003cp\u003eNumber 는 문자열 전체를 숫자로 반환하는 한편, parseInt는 문자열을 처음부터 읽어나가다가 최대로 숫자로서의 의미를 가지는 부분까지를 변환합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst str = \"10x\";\nconsole.log(parseInt(str, 10)); // 10\nconsole.log(Number(str)); // NaN\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또한 parseInt의 시그니쳐는 다음과 같습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efunction parseInt(str: string; radix?: number):number\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eparseInt\u003c/code\u003e는 두번째 인자로 어떤 진법으로 문자열을 파싱할지를 전달받습니다. 만약에 생략되면 일반적으로 10진법으로 파싱되나 브라우저에 따라 상이할 수도 있다고 합니다.\u003c/p\u003e\n\u003cp\u003e이에 반해 Number의 시그니쳐는 다음과 같습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efunction Number(str: string):number\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e이렇게 인자의 개수가 몇개인지에 따라서 동작이 달라지는 경우가 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst arr = [\"1\", \"2\", \"3\"];\n\narr.map((str) =\u003e Number(str)); // [1,2,3]\narr.map((str) =\u003e parseInt(str)); // [1,2,3]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e배열의 map 메서드는 콜백함수를 전달받은 다음에 배열을 순회하면서 요소마다 콜백함수를 실행시키죠\u003c/p\u003e\n\u003cp\u003eparseInt 도, Number 도 함수이므로, 이를 map의 콜백함수로 전달할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst arr = [\"1\", \"2\", \"3\"];\n\narr.map(Number); // [1,2,3]\narr.map(parseInt); // [ 1, NaN, NaN ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예상하신 결과인가요?\u003c/p\u003e\n\u003cp\u003emap 함수는 el, index, this 값을 차례로 콜백함수에게 인자로 전달합니다.\u003c/p\u003e\n\u003cp\u003e따라서 \"1\"을 순회할 때에 (\"1\", 0, arr)이 parseInt의 인자로 전달되므로 parseInt(1,0, arr) 이 호출되는 것과 같습니다. 자바스크립트에서는 함수선언시의 매개변수의 개수와 실제 전달한 인자의 개수가 일치하지 않아도 함수 실행에 문제가 없습니다.\u003c/p\u003e\n\u003cp\u003e위와 같이 parseInt 함수 선언시에 2개의 인자를 받으나 3개를 넘기면 마지막 세번째 인자는 무시됩니다. 반대로 1개의 인자만을 넘기면 2번째 인자는 undefined 가 됩니다. (이를 제어하기 위해서 default parameter 라는 문법이 있죠 ^^)\u003c/p\u003e\n\u003cp\u003e세번째 인자인 arr은 무시됩니다.\u003c/p\u003e\n\u003cp\u003eparseInt는 두번째 인자인 radix로 0이 전달되면 이를 무시합니다. 따라서 1로 파싱이 됩니다.\u003c/p\u003e\n\u003cp\u003e다음 \"2\"를 순회할 때에는 (\"2\", 1, arr)이 전달되며 parseInt(\"2\", 1, arr)이 호출되는 것과 같습니다.\u003c/p\u003e\n\u003cp\u003eparseInt의 radix는 [2,36] 사이의 값만 가질 수 있습니다. radix가 이 범위를 벗어나면 parseInt는 NaN을 반환합니다.\u003c/p\u003e\n\u003cp\u003e다음 \"3\"를 순회할 때에는 (\"3\", 2, arr)이 전달되며 parseInt(\"3\", 2, arr)이 호출되는 것과 같습니다.\u003c/p\u003e\n\u003cp\u003e2진법에서 각 자리수는 0 또는 1이어야 하죠. 따라서 \"3\" 은 2진법에서는 절대 존재할 수 없는 숫자입니다. 따라서 NaN을 반환합니다.\u003c/p\u003e\n\u003cp\u003e또한 \"1e6\" 과 같이 지수표기법으로 나타낸 문자열도 Number 는 잘 변환합니다.\u003c/p\u003e\n\u003cp\u003e리터럴으로 a = 1e6; 또한 유효한 숫자 리터럴이기 때문이죠. 하지만 parseInt를 쓰면 e는 숫자 digit이 아니기 때문에 e 앞까지인 1만 숫자로 변환됩니다.\u003c/p\u003e\n\u003cp\u003e주저리주저리 설명하였지만... Number 를 쓰시는게 속이 편합니다.\n경험적으로 \u003ccode\u003eparseInt\u003c/code\u003e와 \u003ccode\u003eNumber\u003c/code\u003e의 실행속도차이는 미미한 것 같습니다.\n저는 개인적으로 \u003ccode\u003eNumber\u003c/code\u003e를 사용합니다. radix를 기재하는게 귀찮기도 하고, 그냥 익숙해서요.\n코딩테스트에서는 입력값의 정확성은 보장되므로 어떤 것을 쓰더라도 문제 없을 것 같습니다.\u003c/p\u003e\n\u003cp\u003e반드시 parseInt를 써야하는 경우는 문자열이 10진수가 아닌 경우 뿐입니다.\u003c/p\u003e\n\u003ch4\u003eparseFloat\u003c/h4\u003e\n\u003cp\u003eparseFloat는 parseInt 와 다르게 하나의 인자만을 받습니다. 따라서 parseFloat로는 10진수가 아닌 다른 진법으로 기재된 소수를 파싱할 수 없다. 다른 진법으로 기재된 소수 문자열을 숫자로 변환하기 위해서는 별도의 함수를 만들어야 한다.\u003c/p\u003e\n\u003cp\u003e일반적으로 parseFloat를 쓸 일도 없다. 10진법이면 그냥 Number 를 쓰면 되기 때문이다.\u003c/p\u003e\n\u003ch4\u003eNaN\u003c/h4\u003e\n\u003cp\u003eNaN은 숫자가 아님을 나타내는 숫자자료형이다. NaN은 Not a Number 의 앞글자를 딴 것이다. NaN은 의미론적으로는 숫자가 아님을 나타내지만, 타입은 number이기 때문에 생각보다 골치아픈일이 발생한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst a = NaN;\n\nconsole.log(typeof a); // number;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e임의로 NaN을 할당하는 경우는 잘 없기 때문에, 대부분 발생하는 경우는 암묵적 자료형변환에 의해서 발생한다.\u003c/p\u003e\n\u003cp\u003eNumber 함수는 어떤 값이던지 매개변수로 받아서 숫자를 반환한다. 스펙에 따르면 절대 에러를 내지 않는다.\n이를 함수 시그니쳐로 나타내면\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efunction Number(a: any): number\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eany는 어떤 자료형이던지 올 수 있다는 뜻으로 나타내었다.\u003c/p\u003e\n\u003cp\u003eNumber(\"abcd\") 는 무엇을 반환할 것인가? 라고 하면 바로 NaN을 반환한다.\u003c/p\u003e\n\u003cp\u003eNaN은 숫자이기 때문에 숫자 관련 연산을 모두 수행할 수 있다. 더하기, 곱하기, 제곱, 나누기 ... 등. 연산의 결과는 모두 NaN이다.\u003c/p\u003e\n\u003cp\u003e그렇기 때문에 어떤 연산의 결과가 NaN 이라면 자료형변환을 제대로 하였는지 다시 한 번 확인해보자.\u003c/p\u003e\n\u003cp\u003eNaN인지 확인하는 방법으로 Window.isNaN과 Number.isNaN이 있는데 Number.isNaN을 쓰면 된다. Window.isNaN 에는 여러 문제점이 있어서 추가된 문법이 Number.isNaN 이다.\n또는 매우 간단하게 체크하는 방법이 있는데, NaN은 유일하게 자기 자신과 비교하였을 때 false를 반환하는 성질이 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst a = NaN;\n\na === a; // false\n\nfunction isNaN(a) {\n  return a !== a;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e4-2. number =\u003e string\u003c/h3\u003e\n\u003ch4\u003eString vs toString vs new String\u003c/h4\u003e\n\u003cp\u003e어떠한 값이 number 라는 것이 확실하다면, 사용법측면에서 String이나 toString이나 동일하다\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst a = 3;\n\nString(a); // \"3\"\n\na.toString(); // \"3\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런데 a는 3이라는 원시 자료형인데 어떻게 toString 이라는 메서드를 가질 수가 있는거지?\u003c/p\u003e\n\u003cp\u003e자바스크립트에는 원시자료형에 대한 래퍼객체가 존재한다.\n숫자 자료형의 래퍼 객체는 Number 인데 원시자료형에서 래퍼 객체의 메소드를 호출하면 자바스크립트는 해당 값을 래퍼 객체로 감싼 다음에 래퍼 객체의 메서드를 호출하고 값을 반환한다. 래퍼 객체는 바로 제거된다.\n그렇기 때문에 원시자료형도 각 래퍼 객체의 메소드를 자유롭게 호출할 수 있다.\u003c/p\u003e\n\u003cp\u003e참고로 리터럴에서도 사용할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e(3).toString();\n(3).toString();\n(3.5).toString();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e첫번째의 .. 은 오타가 아니다. 그냥 . 은 소숫점 표기로 인식되기 때문에 정수의 경우에는 ..으로 해야한다. 아니면은 괄호로 감싸야 한다.\u003c/p\u003e\n\u003cp\u003e그런데 어떠한 값이 숫자일수도 있고 null 일 수도 있고 undefined 일 수도 있다. null이나 undefined는 래퍼객체가 존재하지 않고 따라서 toString 메서드가 존재하지 않기 때문에 에러가 발생한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst a = null;\n\nString(a); // \"null\"\n\na.toString(); // Uncaught TypeError: Cannot read property 'toString' of null\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e에러 핸들링은 현업에서 매우 깊게 다룰 주제이나, 알고리즘 문제 풀이시에는 에러를 빨리 내는게 디버깅을 편하게 한다. 계산을 다 하고 나서 \"null\"이 출력되면 이게 어디서부터 발생하는지 찾으러 가는게 더 어려워질 수 있다. 빠르게 에러를 발생시키자.\n어떤 걸 쓸지는 취향차이지만, 어떠한 차이가 있을 수 있는지 알아두면 좋다.\u003c/p\u003e\n\u003ch4\u003e0, -0\u003c/h4\u003e\n\u003cp\u003e자바스크립트에는 0이 두가지가 있다. 양의 0과 음의 0. 이 둘을 구분해서 쓰는 경우는 현실적으로 없다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e0 === -0; // true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런데 주의해야할 때가 있다. 바로 문자열로 변환할 때이다.\n-0 을 문자열으로 변환하면 \"-0\" 이 된다.\u003c/p\u003e\n\u003cp\u003e-0 을 임의로 할당하는 경우는 거의 없다. 주로 나오는 경우는 음수를 Infinity 로 나눈 값을 할당한 경우다. 상당히 디버깅이 까다로운 케이스중 하나인데, 왜냐하면 이론적으로는 다 맞기 때문이다. 테스트 케이스중에 이런 경우가 존재하는지 잘 판단해야 한다. 아니면 Infinity 로 나눌 때에는 명시적으로 Math.abs() 로 감싸는 것도 하나의 방법이다.\u003c/p\u003e\n\u003ch3\u003e소수를 정수로 변환\u003c/h3\u003e\n\u003cp\u003eNumber.isInteger =\u003e 정수인지 판별 가능\u003c/p\u003e\n\u003cp\u003eMath.floor, Math.ceil, Math.round, Math.trunc,\u003c/p\u003e\n\u003ch3\u003ebigint\u003c/h3\u003e\n\u003cp\u003e큰 수를 다룰 때에 bigint 자료형을 쓴다.\u003c/p\u003e\n\u003cp\u003eBigInt 함수로 변환\u003c/p\u003e\n\u003cp\u003enumber 와 bigint 자료형은 암시적으로 형변환이 되지 않는다.\u003c/p\u003e\n\u003cp\u003e리터럴 기재할 때 끝에 n을 쓰면 된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e0n;\n\n1n;\n\n1038428n;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebigint를 그냥 console.log로 찍어보면 끝에 n이 기재되어 출력되지만, 문자열로 바꾸면 끝에 'n' 이 없다. 따라서 문자열로 바꿔서 반드시 출력하도록 하자. 안그러면 n도 같이 출력된다.\u003c/p\u003e\n\u003cp\u003ebigint =\u003e string 도 number =\u003e string 과 동일하다. toString, String 쓰면 된다.\u003c/p\u003e\n\u003ch2\u003e5. 입출력\u003c/h2\u003e\n\u003cp\u003eNode.js와 브라우저의 차이 중에 가장 두드러지는 점이 입출력이 아닐까 생각합니다.\u003c/p\u003e\n\u003cp\u003e브라우저에서는 유저로부터 입력을 어떻게 받고 어떻게 출력하나요?\u003c/p\u003e\n\u003cp\u003e로그인 폼을 생각해보겠습니다. 유저로부터 어떻게 id와 pw를 입력받나요?\u003c/p\u003e\n\u003cp\u003einput, form 요소로 입력을 받습니다. 그러면 결과물은 어떻게 출력하나요? 로그인이 성공적으로 수행되었다던가, 로딩중이라던가, 비밀번호가 일치하지 않는가 등의 결과를요.\n다양한 방법이 있을 것입니다. window.alert 도 있을 수 있을거 같구요, 아니면 원하는 내용을 담은 새로운 DOM 요소를 추가하고 예쁘게 스타일링할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003eNode.js는 브라우저가 아닌 일반 터미널에서 실행되죠. 흔히 생각하는 검은 바탕에서 흰 글자가 깜빡거리는 그 곳입니다.\n특히 C와 같은 저수준의 언어를 해보셨다면 친숙한 환경이 아닐까 싶습니다.\u003c/p\u003e\n\u003cp\u003e브라우저가 유저로부터 입력을 받을 수 있기 위해 input, form요소와 이벤트 핸들러를 제공하듯이 Node.js는 유저로부터 입력을 받을 수 있는 내장 모듈 몇가지를 제공합니다.\u003c/p\u003e\n\u003ch3\u003e5-1. fs 모듈\u003c/h3\u003e\n\u003cp\u003e자바스크립트의 가장 큰 특징으로 꼽히는 것이 비동기 프로그래밍이기에 자바스크립트의 내장 모듈을 기본적으로 비동기로 처리됩니다. 하지만, 코딩테스트에서 입력을 받은 뒤에 계산을 하고 출력을 합니다. 계산 도중에 인터랙티브하게 유저로부터 입력을 받는 일이 없습니다. 따라서, 이벤트 드리븐 방식의 복잡한 readline 모듈을 사용할 필요가 전혀 없습니다.\u003c/p\u003e\n\u003cp\u003e전형적으로 동기적 실행이기 때문에 동기적으로 실행되는 fs 모듈의 readFileSync만을 소개하겠습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efs\u003c/code\u003e는 \u003ccode\u003efile system\u003c/code\u003e을 의미합니다. POSIX 시스템에서는 모든 프로세스에 대해 커널이 현재 열려 있는 파일 및 리소스 테이블을 유지 관리합니다. 열려 있는 각 파일에는 파일 설명자(file descriptor)라는 간단한 숫자 식별자가 할당됩니다. 시스템 수준에서 모든 파일 시스템 작업은 이러한 파일 설명자를 사용하여 각 특정 파일을 식별하고 추적합니다. 윈도우즈 시스템은 리소스를 추적하기 위해 다르지만 개념적으로 유사한 메커니즘을 사용합니다. 사용자를 위한 작업을 단순화하기 위해 Node.js는 운영 체제 간의 특정 차이를 추상화하고 열려 있는 모든 파일에 숫자 파일 설명자를 할당합니다. 참고로, 표준입력(stdin: standard input)의 파일 설명자는 0 입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ereadFile\u003c/code\u003e함수는 비동기적으로 파일의 전체를 읽으므로 파일을 읽어들이기가 완료된 후에 콜백 함수를 통하여 다음 스텝을 진행할 수 있는 반면, \u003ccode\u003ereadFileSync\u003c/code\u003e는 동기적으로 파일을 읽어들입니다. 어차피 입력을 다 받아야만 계산을 진행할 수 있으므로, 동기적 처리 방식이 코드도 간결하고 이해하기 편합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efs.readFileSync(path[, options])\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003epath: \u0026#x3C;string\u003e | \u0026#x3C;Buffer\u003e | \u0026#x3C;URL\u003e | \u0026#x3C;integer\u003e filename or file descriptor\u003c/li\u003e\n\u003cli\u003eoptions: \u0026#x3C;Object\u003e | \u0026#x3C;string\u003e\n\u003cul\u003e\n\u003cli\u003eencoding \u0026#x3C;string\u003e | \u0026#x3C;null\u003e Default: null\u003c/li\u003e\n\u003cli\u003eflag \u0026#x3C;string\u003e See support of file system flags. Default: 'r'.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eReturns: \u0026#x3C;string\u003e | \u0026#x3C;Buffer\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003econst fs = require(\"fs\");\n\n// 개행문자(\\n)로 구분된 각 행을 요소로 가지는 배열을 반환.\n// 인코딩을 명시적으로 넘기지 않은 경우에는 raw Buffer가 반환되므로\n// toString()함수를 호출하여 string으로 변환하여야 한다.\nconst input1 = fs.readFileSync(0).toString().split(\"\\n\");\n\n// options으로 인코딩을 string 자료형으로 넘기는 경우, string을 반환한다.\nconst input2 = fs.readFileSync(0, \"utf8\").split(\"\\n\");\n\n// input2와 동일\nconst input3 = fs.readFileSync(0, { encoding: \"utf8\" }).split(\"\\n\");\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e참고: \u003ca href=\"https://nodejs.org/dist/latest-v14.x/docs/api/fs.html#fs_file_system\"\u003eNode.js v14.15.4 Documentation - File system\u003c/a\u003e\u003c/p\u003e\n\u003ch4\u003ereadFileSync 는 파일 전체를 한 번에 읽어들인다\u003c/h4\u003e\n\u003cp\u003e한 줄 씩 읽어들여서 처리하지 않는다. 다 읽어들인다. 따라서 다 이를 한 줄씩 읽어들이는 것과 같은 효과를 내려면 보조함수를 작성하여야 한다.\u003c/p\u003e\n\u003cp\u003e클로저를 이용하여 변수의 스콥을 제한하고 한 줄씩 문자열을 반환하게끔 할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst getLine = (() =\u003e {\n  const input = require(\"fs\").readFileSync(0, \"utf8\").split(\"\\n\");\n  let i = 0;\n\n  return () =\u003e input[i++];\n})();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e5-2. 출력\u003c/h3\u003e\n\u003ch4\u003econsole.log\u003c/h4\u003e\n\u003cp\u003e표준출력으로 console.log를 사용한다. console 객체는 브라우저에도 존재하고 Node.js 에도 존재하므로 매우 친숙할 것이다.\nNode.js에서 더욱 저수준의 출력 내장 모듈을 제공하나 console.log 로 대부분 충분하다.\u003c/p\u003e\n\u003ch4\u003e다만, console.log는 굉장히 느리다\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003econsole.log\u003c/code\u003e를 이용해서 출력을 하면 됩니다.\n다만,\u003ccode\u003econsole.log\u003c/code\u003e는 호출시 많은 시간이 소요되는 함수이므로, 백트래킹과 같이 알고리즘 중간중간에 출력을 하는 경우에는 배열이나 \u003ccode\u003estring\u003c/code\u003e에 출력값을 저장해두었다가 계산 종료후 한번에 출력을 해주는 것이 좋습니다.\u003c/p\u003e\n\u003cp\u003e아래는 \u003ca href=\"https://www.acmicpc.net/problem/15649\"\u003eBOJ 15649번 문제 N과 M (1)\u003c/a\u003e의 채점결과입니다. 위에는 계산 종료후 코드의 마지막에 한번만 출력을 해준 경우이고, 아래는 계산 중간중간에 계속해서 출력을 해준 경우입니다. 보시다시피 실행 시간의 차이가 엄청 많이 나신다는 것을 알 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 계산 종료후 마지막에 한번만 출력\n...\nlet print = \"\";\n\n(function rec(lev) {\n  if (lev === M) {\n    print += `${arr.join(\" \")}\\n`; // depth가 M일 때마다 print에 출력 값 저장\n    return;\n  }\n\n  ...\n  rec(lev + 1);\n  ...\n})(0);\n\nconsole.log(print); // 계산 종료후 마지막에 출력\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e// 계산 중간중간에 출력\n...\n\n(function rec(lev) {\n  if (lev === M) {\n    console.log(`${arr.join(\" \")}\\n`); // depth가 M일 때마다 print에 출력 값 저장\n    return;\n  }\n\n  ...\n  rec(lev + 1);\n  ...\n})(0);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://images.velog.io/images/bigsaigon333/post/14c5f8aa-2f4a-4f4a-be0d-6399d5863abc/%ED%95%9C%EB%B2%88%EC%97%90_%EC%B6%9C%EB%A0%A5_vs_%EB%A7%A4%EB%B2%88_%EC%B6%9C%EB%A0%A5.png\" alt=\"BOJ 15649번 문제 채점결과\"\u003e\u003c/p\u003e\n\u003cp\u003e※ \u003ccode\u003eprocess.stdout.write\u003c/code\u003e vs \u003ccode\u003econsole.log\u003c/code\u003e\nWritable 스트림인 \u003ccode\u003eprocess.stdout\u003c/code\u003e의 \u003ccode\u003ewrite\u003c/code\u003e함수를 이용하여 출력을 할 수 있습니다. \u003ccode\u003econsole.log\u003c/code\u003e도 내부적으로 \u003ccode\u003eprocess.stdout.write\u003c/code\u003e를 이용하여 출력한다고 합니다. 하지만 경험적으로 \u003ccode\u003econsole.log\u003c/code\u003e와 \u003ccode\u003eprocess.stdout.write\u003c/code\u003e의 실행속도 차이를 느끼지 못하였습니다. \u003ccode\u003econsole.log\u003c/code\u003e, \u003ccode\u003eprocess.stdout.write\u003c/code\u003e 모두 무거운 함수 호출이므로, 이를 최소화하기 위하여 배열이나 \u003ccode\u003estring\u003c/code\u003e에 출력값을 저장해두는 테크닉이 더 실행속도 단축에 도움이 되는 것 같습니다.\u003c/p\u003e\n\u003cp\u003e참고URL: \u003ca href=\"https://nodejs.org/dist/latest-v14.x/docs/api/stream.html#stream_writable_write_chunk_encoding_callback\"\u003eNode.js v14.15.4 Documentation - Writable Stream: writable.write(chunk[, encoding][, callback])\u003c/a\u003e\u003c/p\u003e\n\u003ch3\u003e5-3. BOJ 1000\u003c/h3\u003e\n\u003ch4\u003e마지막의 공백문자, 개행문자는 무시된다\u003c/h4\u003e\n\u003ch3\u003e5-4. 함수형 타입의 코딩테스트\u003c/h3\u003e\n\u003cp\u003e앞서 설명한 입출력이 굉장히 번거롭게 느껴지기도 한다. FE 개발자들은 Node.js 파일시스템 내장 모듈을 사용할 일이 생각보다 없다. 그래서 기업에서도 그냥 입출력으로 문제를 판단하는게 아니라 함수를 작성할 것을 요구한다. 함수의 매개변수로 입력값을 넣어주고, 출력값을 함수의 반환값으로 하라는 것이다.\u003c/p\u003e\n\u003cp\u003e오히려 좋아.\u003c/p\u003e\n\u003cp\u003einput compute output 의 3단계로 구분해서 문제를 풀자\u003c/p\u003e\n\u003cp\u003eBOJ는 input compute output 3단계를 다 구현하는 것이고\u003c/p\u003e\n\u003cp\u003eProgrammers는 compute만 구현하는 것이라 생각하면 된다.\u003c/p\u003e\n\u003cp\u003e그러면 다 대응된다.\u003c/p\u003e\n\u003ch2\u003e6. 문제풀이 예시\u003c/h2\u003e\n\u003ch3\u003e6-1. 한수 - acmicpc.net/problem/1065\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e문제 읽고 이해\u003c/li\u003e\n\u003cli\u003e입력의 조건 이해\nN: [1, 1000]\u003c/li\u003e\n\u003cli\u003e생각은 큰 단위에서 작은 단위로\u003c/li\u003e\n\u003cli\u003e구현은 작은 단위에서 큰 단위로\u003c/li\u003e\n\u003cli\u003eisHansu: (n: number) =\u003e boolean;\nisHansu(1) === true\nisHansu(246) === true\nisHansu(247) === false\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003eisHansu 구현\n1자리수\n2자리수\n3자리수 이상\n3_2_5 공차가 마이너스일 수도 있다\u003c/p\u003e\n\u003cp\u003e1부터 N까지 순회하면서 isHansu가 true이면 count를 1씩 증가\u003c/p\u003e\n\u003cp\u003e계산된 count를 반환후 stdout으로 출력\u003c/p\u003e\n\u003cp\u003e테스트\u003c/p\u003e\n\u003cp\u003e실제 제출\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e왜 완전탐색인가? 1부터 N까지 순서대로 모든 숫자가 한수인지 isHansu 에 인자를 넣어서 확인했다\nO(N logN) 이다\u003c/p\u003e\n\u003cp\u003eN이 만약 2자리수, 즉 99이하이면 그냥 N을 반환하게 할 수도 있다.\n그러면 N이 99 이하이면 O(1) 이 된다\nisHansu 조건이 굉장히 복잡하다고 가정했을 때에도, isHansu의 시간복잡도가 낮다면, 하나씩 다 탐색하여서 문제를 풀어낼 수 있다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e포인트 1) 자료형을 명확하게 표기하자: 암시적 형변환에 의존하면, 나중에 큰일 난다\u003c/p\u003e\n\u003cp\u003e포인트 2) for 문을 줄일 수 있다면 줄이자. 이번에는 Option!\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e배열의 한 요소가 다른 요소는 간섭하지 않는다.\u003c/li\u003e\n\u003cli\u003e상위 스코프의 값을 참조하지 않는다 =\u003e 순수함수이다\nfor 문보다 배열 내장 메소드가 먼저 떠오를만큼 숙달된다면 바로 쓰자!\n왜 강조? 이게 바로 자바스크립트다운 배열 순회 방법. 기능의 분리.\nBrute Force와 동일. 내가 익숙한 문법으로 정확하게 작성할 수 있다면 그걸로 keep going.\n아니라면 이런 방법도 같이 익혀가면, 알고리즘 공부하면서 작성한 코드 스킬들이 나중에 프로젝트에서도 도움이 된다\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003ehttps://www.acmicpc.net/problem/2798\u003c/h3\u003e\n\u003cp\u003e시간복잡도에 너무 집착하지 마라\u003c/p\u003e\n\u003cp\u003e브루트 포스로 충분하면 그걸로 충분\u003c/p\u003e\n\u003cp\u003e면접때도 똑같이 말하면 된다. Keep it simple and stupid\u003c/p\u003e\n\u003cp\u003e단순한게 오히려 이해하기에 편하기 때문. 진짜 문제가 되면 그때 더 연구하겠다고 답변하면 된다.\u003c/p\u003e\n","title":"Ch02. 기초 알고리즘 지식","date":"2020-03-11","summary":"기초 알고리즘 지식"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"draft:js-algorithm-ch2"},"buildId":"mGeQbCKeTVK9iuQqBnbIJ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>