---
title: Ch03. 배열
date: "2020-03-12"
summary: "배열"
---

## 1. 배열이란?

배열이란 메모리 상에 요소를 연속하게 배치한 자료구조입니다.

연속하게 배치하니까 요소의 순서가 있겠죠. 제일 앞에 있는거를 0번째, 그다음을 1번째, 2번째 ... 라고 합니다.

컴퓨터는 배열의 0번째 요소의 메모리 위치를 기억하고 있습니다. 따라서 n번째 요소의 메모리 위치는 0번째 요소에서 n 만큼 떨어져 있으므로 바로 n번째 요소에 접근이 가능합니다.

배열의 가장 큰 특징 중에 하나입니다. 인덱스 값을 알고 있다면 배열의 특정 위치의 요소값을 O(1)으로 읽을 수 있습니다.

## 2. 자바스크립트에서 배열

앞에서 말씀드린 배열은 컴퓨터 과학에서 말하는 추상적인 자료구조로서의 배열입니다.

이를 실제로 구현한 것이 자바스크립트에서 배열(`[1, 2, 3]`)인 것이죠.

위에서 말한 추상적인 자료구조로서의 배열의 특징을 모두 가지고 있지만 그 이외에 자바스크립트의 배열의 특징으로는 다음과 같은 것들이 있습니다.

### 2-2. 배열은 메모리 상에 연속적으로 배치되는 것이 보장되지 않는다

사실 배열은 그냥 자바스크립트 객체입니다. 추상적인 의미에서 배열은 메모리상에 연속적으로 배치되어야 하는데, 자바스크립트에서 배열은 인덱스를 키값으로 하고 요소를 값으로 하는 객체에 지나지 않습니다.

```js
[1,2,3]

{'0': 1, '1': 2, '2': 3, length: 3}
```

의미론적으로 동일합니다.

### 2-1. 배열의 크기가 동적이다

계속해서 뒤에 추가해 나갈 수 있고, 배열의 크기를 줄일 수도 있습니다.

배열의 크기는 length 프로퍼티를 통해 알 수 있는데요, push, pop 과 같은 메서드로 인해 배열의 크기가 변경되면 length 프로퍼티가 자동으로 변경되기 때문에 배열의 크기를 O(1)으로 알 수 있습니다.

문제에서 주어진 숫자의 전체 개수와 숫자를 주는 경우가 있다.

예시

```
7
1 1 2 3 4 2 1
```

그러면 이거를 파싱할 때 N = 7, nums = [1, 1, 2, 3, 4, 2, 1] 이렇게 파싱을 한다.

N === nums.length 이다

따라서 추가로 N을 넘겨주지 않아도 된다. 이게 오히려 혼란을 불러일으킬 때가 있다.

이렇게 주는 이유는 C 와 같은 언어에서는 배열의 크기가 정적이기 때문에, 배열의 크기를 가장 큰 N으로 설정해두고 실제 런타임에서는 N까지만 순회시키게 하기 위해서인데, 자바스크립트에서는 런타임에 배열의 크기를 정할 수 있기 때문에 굳이 이렇게 안해도 된다.

---

참고

최대 크기는 2^32 - 1 입니다.

1. ECMAScript에서는 배열을 인덱스와 값을 연결하는 맵(딕셔너리)로 정의합니다. 그로 인한 특징은 다음과 같습니다.

   - 배열은 연속적이지 않으며 '구멍'이 있을 수 있습니다.

     ※ 다만, 실제 JS엔진은 구멍이 없는 배열을 내부적으로 최적화해서 연속 형태로 저장합니다. 키가 배열 인덱스인 배열 프로퍼티를 요소라고 부릅니다.

   - 배열의 크기를 동적으로 늘였다 줄일 수 있습니다. 즉, C++과 같은 정적 언어에서의 배열과 달리 요소를 추가하면 길이가 늘어나고, 임의의 인덱스의 요소(예를 들어 length보다 큰 인덱스의 요소) 에도 접근・할당할 수 있습니다.
   - 배열은 프로퍼티 키가 숫자인 객체이므로 프로퍼티를 가질 수 있습니다. 배열 프로퍼티는 배열 요소가 아닙니다.

2. 배열의 고유 프로퍼티는 인덱스와 length입니다.

   1. 배열의 인덱스
      1. 0 ≤ i < 2^32 - 1
      2. 배열의 최대 길이는 2^32 - 1
      3. 범위를 넘는 인덱스는 일반적인 프로퍼티 키(문자열)로 취급하며, 배열 요소로 표시되지 않고 length 프로퍼티에도 영향이 없습니다.
   2. length 프로퍼티

      1. 기본 기능은 배열에서 가장 높은 인덱스를 추적합니다.
      2. length가 요소의 개수를 세는 것이 아닙니다.
      3. length 프로퍼티를 직접 늘리면 단지 구멍만 생깁니다. 하지만 length 프로퍼티는 새 요소를 삽입할 위치를 나타내는 포인터 구실은 정확히 합니다.
      4. length를 줄이면 그보다 큰 인덱스에 있던 요소는 모두 삭제됩니다.
      5. length를 0으로 설정하면 빈 배열이 됩니다. 하지만 이 접근법은 각 배열 요소를 명시적으로 삭제하므로 느릴 수 있습니다. 모순처럼 보이지만, 빈 배열을 새로 만드는 편이 더 빠를 때가 많습니다.
      6. 배열의 최대 길이는 2^32 - 1 입니다.

      ```tsx
      console.log(Object.getOwnPropertyDescriptors([]));

      /*
      {
        length: {
          value: 0,
          writable: true,
          enumerable: false,
          configurable: false
        }
      }
      */
      ```

3. 배열을 생성하는 방법

   1. 배열 리터럴(`[]`): 배열 요소를 나열합니다. 요소의 위치는 묵시적 인덱스입니다.
   2. Array 생성자: new연산자는 옵션입니다. new없이 일반적인 함수처럼 호출해도 new를 쓴 결과와 같습니다. new 연산자를 이용한 배열 생성은 권장되는 방법이 아닙니다.

      ※ **why?**

      - Array 생성자는 단일 인자로 숫자를 받는 경우에, 숫자만큼의 길이를 가진 배열을 만듭니다. 하지만, 여러 인자가 들어올 경우, 해당 인자를 요소로 하는 배열을 생성합니다. 따라서, Array 생성자로는 단 하나의 숫자 요소로 이루어진 배열을 생성할 수 없습니다.
      - 길이를 지정해 생성한 빈 배열에는 구멍만 있으므로 생성자를 이런 식으로 쓰는 건 옳지 않습니다.

4. 배열의 구멍(empty)

   1. 배열은 인덱스와 값을 연결하는 맵이므로, 배열에는 구멍, 즉 배열 길이보다 작으면서 아무것도 정의되지 않은 인덱스가 있을 수 있다. 이런 인덱스를 읽으려고 하면 undefined가 반환됩니다.
   2. empty 와 undefined는 다르다. empty는 배열의 인덱스가 존재하지 않는 것이고, 요소가 undefined인 것은 배열의 인덱스는 존재하나 인덱스를 키로 하는 프로퍼티의 값이 undefined 인 것이다.

      ```tsx
      arr = ["a", , "b"];

      Object.getOwnPropertyDescriptors(arr);
      ```

   3. 구멍을 만드는 방법

      1. 배열 인덱스에 값을 할당하여 만들 수 있다.

         ```tsx
         const arr: number[] = [];
         arr[0] = 0;
         arr[2] = 2;
         console.log(arr); // [LOG]: [0, , 2]
         ```

      2. 배열 리터럴에서 값을 생략하면 구멍이 만들어진다.

         ```tsx
         const arr = [0, , 2];
         console.log(arr); // [LOG]: [0, , 2]
         ```

      3. TS에서 구멍은 undefined로 추론된다.

         ```tsx
         const arr = [0, , 2]; // declare const arr: (number | undefined)[];
         console.log(arr); // [LOG]: [0, , 2]
         ```

   4. **구멍(empty) vs undefined인 요소**
      1. in 연산자로 요소 존재여부를 확인시 구멍은 false, undefined인 요소는 true
      2. Array.prototype의 메서드는 구멍을 다루는 방법이 각기 다르다.

5. 객체가 배열인지 확인하는 방법
   1. `Array.isArray` : instanceof와 달리 영역(창 또는 프레임)을 넘어온 객체도 정확히 처리한다
6. 배열은 iterable이다. 전개 연산자, for - of 구문에서 사용된다. [Symbol.iterator]는 Array.prototype.values 이다. keys, values, entries 모두 이터레이터를 반환한다.
7. Array.from() 메서드를 사용하면 이터러블(유사 배열 객체 포함)도 배열로 변환할 수 있다.
   1. 이터레이터를 사용해서 배열로 변환한다.
   2. `Array.from(iter, callback, thisArg)` : 만들어질 배열의 인덱스에 결과 값을 저장하기 전에 유사 배열 객체의 각 값에 특정 연산을 수행하거나 최종 형태로의 변환 작업을 할 수 있다.
8. 타입 배열
   1. 특수한 목적을 가진 배열. 숫자 타입과 동작하도록 설계되었다.
   2. 타입 배열은 WebGL로부터 시작되었으며, WebGL은 OpenGL ES 2.0을 포팅하여 웹 페이지에서 <canvas> 엘리먼트와 사용되도록 설계된 버전을 의미한다. 빠른 산술 비트 연산을 제공하기 위한 포팅 과정의 일부로 타입 배열이 만들어졌다.
   3. 자바스크립트 숫자를 이용한 산술 연산은 숫자를 64비트 부동소수점 형식으로 저장하고 필요에 따라 32비트 정수로 변환했기 때문에 WebGL을 위해서는 너무 느렸다. 타입 배열은 이러한 제약을 피하고 더 나은 성능의 산술 연산을 제공하기 위해 도입되었다. 이 개념은 어떤 단일 숫자든지 비트 배열처럼 처리될 수 있도록 하며, 자바스크립트 배열에서 이용할 수 있는 익숙한 메서드를 사용할 수 있다는 의미이다.
   4. ECMAScript 6에서는 자바스크립트 엔진을 통한 더 나은 호환성 그리고 배열과의 상호 운용성을 보장하기 위해 공식적인 언어의 일부로 타입 배열을 받아들였다. ECMAScript 6 버전의 타입 배열은 WebGL 버전과 완전히 같지는 않지만 ECMAScript 6 버전을 다른 접근법보다 WebGL의 진화한 버전이라 할 수 있는 유사점이 충분히 존재한다.

### 내장 메서드 소개

forEach

map

filter

reduce

reverse

join

## 3. 문제 풀이

### https://www.acmicpc.net/problem/9093

Array.prototype.map,join,reverse
String.prototype.split

### https://www.acmicpc.net/problem/4344

Array.prototype.reduce,filter
Number.prototype.toFixed

### https://www.acmicpc.net/problem/8958

String.prototype.split
Array.prototype.reduce,filter

### https://www.acmicpc.net/problem/10818

Array.prototype.forEach
Array.prototype.reduce,
Math.max, Math.min, destructuring
