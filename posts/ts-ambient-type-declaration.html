<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta name="next-head-count" content="2"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c0319daaf0c38f70.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-418d4e6c8aa144e7.js" defer=""></script><script src="/_next/static/mGeQbCKeTVK9iuQqBnbIJ/_buildManifest.js" defer=""></script><script src="/_next/static/mGeQbCKeTVK9iuQqBnbIJ/_ssgManifest.js" defer=""></script><script src="/_next/static/mGeQbCKeTVK9iuQqBnbIJ/_middlewareManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.3">*,::before,::after{box-sizing:border-box;}/*!sc*/
[hidden]{display:none;}/*!sc*/
h1{margin:0.67em 0;font-size:2rem;}/*!sc*/
h2{font-size:1.5rem;}/*!sc*/
h3{font-size:1.17rem;}/*!sc*/
h4{font-size:1rem;}/*!sc*/
h5{font-size:0.83rem;}/*!sc*/
h6{font-size:0.67rem;}/*!sc*/
pre{white-space:pre-wrap;}/*!sc*/
hr{border-style:solid;border-width:1px 0 0;color:inherit;height:0;overflow:visible;}/*!sc*/
img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle;max-width:100%;}/*!sc*/
picture{display:contents;}/*!sc*/
source{display:none;}/*!sc*/
img,svg,video,canvas{height:auto;}/*!sc*/
audio{width:100%;}/*!sc*/
audio:not([controls]){display:none;}/*!sc*/
img{border-style:none;}/*!sc*/
svg{overflow:hidden;}/*!sc*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block;}/*!sc*/
[type="checkbox"],[type="radio"]{box-sizing:border-box;padding:0;}/*!sc*/
html,body{padding:0;margin:0;font-family:-apple-system,BlinkMacSystemFont,"Apple SD Gothic Neo","Malgun Gothic","맑은 고딕","나눔고딕","Nanum Gothic","Noto Sans KR","Noto Sans CJK KR",arial,"돋움",Dotum,Tahoma,Geneva,"Helvetica Neue",sans-serif;}/*!sc*/
a{color:inherit;-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g1[id="sc-global-crMvLC1"]{content:"sc-global-crMvLC1,"}/*!sc*/
.gOdiQq{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;width:100%;}/*!sc*/
data-styled.g2[id="sc-d7fdb9d7-0"]{content:"gOdiQq,"}/*!sc*/
.kKdabY{margin:0;line-height:1.25;width:100%;font-size:3.6rem;text-align:center;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-column-gap:2rem;column-gap:2rem;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;font-weight:800;}/*!sc*/
@media (max-width:767px){.kKdabY{font-size:7.5vw;-webkit-column-gap:1rem;column-gap:1rem;}}/*!sc*/
data-styled.g3[id="sc-d7fdb9d7-1"]{content:"kKdabY,"}/*!sc*/
.hfKWMb{position:relative;overflow:hidden;border-radius:35%;width:25%;padding-bottom:25%;}/*!sc*/
@media (max-width:600px){.hfKWMb{width:20%;padding-bottom:20%;}}/*!sc*/
data-styled.g4[id="sc-d7fdb9d7-2"]{content:"hfKWMb,"}/*!sc*/
.caTBeP{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;}/*!sc*/
data-styled.g5[id="sc-d7fdb9d7-3"]{content:"caTBeP,"}/*!sc*/
.bkfRko{min-height:100vh;padding:3rem 2rem 0;-webkit-flex:1;-ms-flex:1;flex:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;max-width:768px;margin:auto;}/*!sc*/
@media (max-width:600px){.bkfRko{padding:2rem 1rem 0;}}/*!sc*/
data-styled.g9[id="sc-8d5d6634-0"]{content:"bkfRko,"}/*!sc*/
.dsDnMD{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;width:calc(100vw - 3rem);padding:2rem 0 1rem;border-top:1px solid #eaeaea;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}/*!sc*/
data-styled.g10[id="sc-8d5d6634-1"]{content:"dsDnMD,"}/*!sc*/
.gffvJe{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}/*!sc*/
data-styled.g11[id="sc-5d513e51-0"]{content:"gffvJe,"}/*!sc*/
</style></head><body><div id="__next" data-reactroot=""><div class="sc-8d5d6634-0 bkfRko"><header class="sc-d7fdb9d7-0 gOdiQq"><h1 class="sc-d7fdb9d7-1 kKdabY"><div class="sc-d7fdb9d7-2 hfKWMb"><img src="/profile.jpg" alt="프로필" class="sc-d7fdb9d7-3 caTBeP"/></div><span>프론트엔드 개발자<br/>김동희입니다</span></h1></header><div><h1>Ambient Type Declaration</h1><time>2022-05-07</time></div><main class="sc-5d513e51-0 gffvJe"><p>타입스크립트의 타입 선언은 <code>.ts, .tsx</code> 확장자를 가진 파일에서도 할 수 있지만 <code>.d.ts</code> 확장자를 가진 파일에서도 할 수 있습니다.</p>
<h2>I. 앰비언트 타입 선언</h2>
<p><code>.d.ts</code> 확장자를 가진 파일에서는 타입 선언만 할 수 있고 값을 표현할 수는 없습니다. 값을 포함하는 일반적인 선언과 구별하기 위해 <code>d.ts</code> 확장자를 가진 파일에서 하는 타입 선언에 앰비언트(ambient; 주위의, 주변의)라는 표현을 붙여 <strong>앰비언트 타입 선언</strong>이라고 부릅니다.
타입스크립트에서 class는 타입으로도 값으로도 사용되지만, <code>d.ts</code> 확장자를 가진 파일에서는 타입 선언만 할 수 있고 메서드의 구체적인 구현이나 프로퍼티의 할당은 할 수 없습니다.</p>
<p>다만 값을 정의할 수는 없지만, <code>declare</code> 라는 특별 키워드를 사용해 자바스크립트의 다른 어딘가에 값이 있다는 사실을 선언할 수 있습니다.
<code>declare</code> 는 "나의 자바스크립트는 이 타입을 익스포트함을 맹세한다"라고 선언하는 것이라 생각하면 좋습니다.</p>
<p>또 다른 특징으로는 앰비언트 타입 선언은 명시적으로 <code>import</code> 하지 않더라도 어디서든 사용할 수 있다는 점입니다. 앰비언트 타입 선언은 마치 전역 변수를 설정하는 것과 유사합니다.</p>
<h2>II. 언제 앰비언트 타입 선언이 주로 사용되나요</h2>
<p><code>.ts, .tsx</code>확장자를 가진 파일에서는 타입 선언과 구현을 모두 할 수 있으므로 일반적으로 앰비언트 타입 선언을 사용하여 타입 선언과 구현을 분리할 필요는 없습니다. 그럼 반대로 타입 선언과 구현을 같이 할 수 없는 상황을 생각해 보면, 언제 앰비언트 타입 선언을 사용해야 하는지 알 수 있습니다.</p>
<h3>1. 타입 선언이 없는 자바스크립트로 작성된 서드 파티 라이브러리</h3>
<p>DefinitelyTyped 를 잠시 잊어보겠습니다. 자바스크립트로 작성된 npm library 가 있다고 가정해보겠습니다. 자바스크립트로 구현하였기에 이에 대한 타입 선언은 없습니다.
타입스크립트에서 사용은 가능하나 타입 선언이 없으므로 import 한 모듈은 모두 any 로 추론될 것이며, tsconfig.json 설정에서 any 사용을 금지하였다면 빌드되지 않을 것입니다.
이러한 경우에 앰비언트 타입 선언을 사용할 수 있습니다. 앰비언트 타입 선언으로 자바스크립트 라이브러리 내 함수, 변수들의 타입을 선언하면, 타입스크립트는 컴파일 시에 자동으로 <code>d.ts</code> 확장자를 가진 파일을 검색해서 타입 체킹에 이용하므로 문제없이 컴파일됩니다. vscode와 같은 코드 편집기도 <code>d.ts</code> 확장자를 가진 파일을 읽어 해석한 다음 코드 작성시 유용한 타입 힌트를 제공합니다.</p>
<p>DefinitelyTyped 에 있는 라이브러리가 하는 일이 방금 저희가 한 일입니다.
예를 들어 @types/react 를 <code>npm install -D</code> 하면 node_modules/@types/react 에 index.d.ts, global.d.ts 가 설치됩니다. 여기에 리액트의 컴포넌트, 훅에 대한 타입이 정의가 되어 있습니다. 그리고 tsc는 별도의 설정을 해주지 않더라도 node_modules/@types 디렉토리에 있는 타입 선언을 타입 체킹에 이용합니다.
또한 vscode는 index.d.ts, global.d.ts를 이용하여 타입 힌트를 제공합니다.</p>
<p>즉, 앰비언트 타입 선언은 타입스크립트에 "자바스크립트에는 이런저런 정보가 정의되어 있어"라고 알려주는 수단으로 생각할 수 있습니다.</p>
<h3>2. 타입스크립트로 작성된 서드 파티 라이브러리</h3>
<p>서드 파티 라이브러리는 타입스크립트로 작성되더라도 자바스크립트 파일과 <code>d.ts</code> 파일으로 배포되는 것이 일반적입니다.</p>
<p>타입스크립트 파일을 배포하여 라이브러리 사용자가 타입스크립트를 컴파일할 때 라이브러리 코드도 포함해서 컴파일하게 할 수도 있으나, 자바스크립트 파일과 <code>d.ts</code> 파일로 배포하면 라이브러리 파일을 또 컴파일할 필요가 없어 컴파일 시간을 크게 줄여줍니다. 또한 <code>d.ts</code> 파일이 있으므로 당연히 타입 관점에서 동일한 기능을 제공할 수 있습니다.
tsconfig.json의 <code>declaration</code>을 true 로 설정하면 타입스크립트는 컴파일 시 <code>d.ts</code> 파일을 자동으로 생성합니다.</p>
<h3>3. 프로젝트 어디에서나 전역으로 이용할 수 있는 타입을 정의하여 임포트 없이 바로 사용하고자 할 때</h3>
<p>앰비언트 타입 선언은 전역 변수와 같습니다. 따라서 앰비언트 타입 선언으로 타입을 선언하면 모든 코드 내에서 import 하지 않고 사용할 수 있습니다. 예를 들어 정말 유용한 타입 유틸 함수를 작성했다고 가정해보겠습니다. 그렇다면 앰비언트 타입 선언으로 타입 유틸 함수를 선언한다면 더이상 명시적으로 모든 코드에 import하지 않더라도 사용할 수 있습니다. 마치 내장 타입 유틸 함수인 것 처럼 말이죠.</p>
<pre><code>// src/index.d.ts
type Optional&#x3C;T extends object, K extends keyof T = keyof T> = Omit&#x3C;T, K> &#x26;
  Partial&#x3C;Pick&#x3C;T, K>>;

// src/components.ts
type Props = { name: string; age: number; visible: boolean };
type OptionalProps = Optional&#x3C;Props>; // Expect: { name?: string; age?: number; visible?: boolean; }
</code></pre>
<h3>4. 자바스크립트 어딘가에 전역 변수가 정의되어 있음을 타입스크립트에 알릴 때</h3>
<p>타입스크립트로 직접 구현하지는 않았지만 실제로는 자바스크립트 어딘가에 전역 변수가 정의되어 있음을 타입스크립트에 알릴 때 사용합니다.</p>
<p>예를 들어 웹뷰 개발시 네이티브앱과의 통신을 위한 인터페이스를 네이티브앱이 윈도우 객체에 추가하는 경우가 많습니다. 즉, 타입스크립트로 직접 구현을 하지는 않았지만 실제로 해당 변수(자바스크립트의 함수는 일급 객체이므로 변수의 범위에 함수도 당연히 포함됩니다)가 정의되어 있어 런타임에서 해당 변수를 사용할 수 있습니다.</p>
<p>예를 들어 deviceId, appVersion, latitude, longitutde 같은 값을 네이티브 앱에서 window 전역 객체에 할당해준다고 하겠습니다. 이러한 window 객체의 프로퍼티는 실제로 타입스크립트로 정의한 값이 아니므로 타입스크립트는 window 객체의 타입에 이러한 속성이 없는 것으로 판단하여 이러한 속성에 접근하려고 하면 window 객체에 존재하지 않는 프로퍼티라는 에러를 방출하게 됩니다.
따라서 global namespace에 있는 Window 객체에 해당 프로퍼티가 정의되어 있다는 것을 나타내기 위해 앰비언트 타입 선언을 이용합니다.</p>
<pre><code>declare global {
  interface Window {
    deviceId: string | undefined;
    appVersion: string;
    latitude: string | undefined;
    longitude: string | undefined;
  }
}
</code></pre>
<h2>III. 언제 앰비언트 타입 선언을 사용하는 것이 좋은가?</h2>
<h3>❌ 타입스크립트로 라이브러리 개발시</h3>
<p>tsconfig.json의 <code>declaration</code>을 true 로 설정하면 타입스크립트는 컴파일 시 <code>d.ts</code> 파일을 자동으로 생성하므로, 수동으로 <code>d.ts</code>를 작성할 필요가 없습니다.
따라서 타입스크립트로 라이브러리 개발시에는 앰비언트 타입 선언을 사용할 필요가 없습니다.</p>
<h3>❌ 프로젝트 어디에서나 전역으로 이용할 수 있는 타입을 정의하여 import 없이 바로 사용하기 위해</h3>
<p>앰비언트 타입 선언은 마치 프로토타입에 메서드를 추가하는 것과 같습니다. 서로 다른 라이브러리에서 동일한 이름의 앰비언트 타입 선언을 한다면 충돌이 발생하여 어떤 타입 선언이 적용되는지 알 수 없고, 원하는대로 동작하지 않을 수 있습니다. 또한 명시적인 import, export가 없기 때문에 의존성 관계가 보이지 않아 추후 변경이 어려울 수 있습니다. 따라서 전역으로 이용하기 위한 타입도 <code>.ts</code> 파일에 작성하고 명시적으로 import 하는 것을 추천합니다.</p>
<h3>🤔 DefinitelyTyped에 타입 선언이 존재하지 않는 라이브러리에 타입 추가시</h3>
<p>이런 라이브러리는 사용하지 않는 것이 좋습니다. 다른 대안을 찾아보세요. 타입을 직접 추가해야하는 라이브러리를 사용하기 위해 동료들을 설득하는 것은 라이브러리에 타입을 추가하는 것보다 더 힘든 일입니다.</p>
<h3>✅ 타입스크립트로 정의하지는 않았지만 실행시에는 존재하는 인터페이스 정의시</h3>
<h4>1. webpack 등의 번들러는 json, css, image 파일등을 모듈로 취급합니다</h4>
<p>하지만 타입스크립트는 json, css, image 파일의 모듈을 타입을 알 수 없기 때문에 앰비언트 모듈 선언을 해주어야 합니다. <code>react-scripts</code>를 사용하는 경우, <code>react-app.d.ts</code>에 이미 정의되어 있어 별도의 설정이 필요하지 않을 수도 있습니다</p>
<pre><code>// node_modules/react-scripts/lib/react-app.d.ts
declare module "*.jpg" {
  const src: string;
  export default src;
}

declare module "*.png" {
  const src: string;
  export default src;
}

declare module "*.webp" {
  const src: string;
  export default src;
}

declare module "*.svg" {
  import * as React from "react";

  export const ReactComponent: React.FunctionComponent&#x3C;
    React.SVGProps&#x3C;SVGSVGElement> &#x26; { title?: string }
  >;

  const src: string;
  export default src;
}
</code></pre>
<h4>2. 전역변수 확장</h4>
<p>웹뷰 개발시 네이티브앱과의 통신을 위한 인터페이스를 window 객체에 추가하는 경우가 많습니다. 이러한 경우에는 앰비언트 타입 선언을 사용하여야 합니다.</p>
<h2>IV. 앰비언트 타입 선언을 잘못 썼을 때 문제점</h2>
<h3>1. 앰비언트 타입 선언은 의존성 관계가 보이지 않기 때문에 변경의 영향 범위 파악이 어렵습니다</h3>
<p>명시적인 import, export 없이 코드 전역에서 사용할 수 있기 때문입니다. 자주 변경되는 타입 선언의 경우,</p>
<p>하기 때문입니다. 가 보이지 않기 때문에</p>
<p>소스 코드의 규모가 큰 경우, 변경이 어려울 수 있다.</p>
<h3>2. 타입스크립트로 정의하지는 않았지만 실행시 존재하는 인터페이스는 배포 시점 관리가 중요합니다</h3>
<p>네이티브 앱과의 인터페이스가 수정이 될 경우, window 객체를 확장한 앰비언트 타입 선언도 이에 맞추어 수정되어야 합니다. 원활한 커뮤니케이션으로 네이티브 앱 인터페이스 변경 시점과 웹뷰 변경 시점을 잘 맞추어야 합니다.</p>
<h3>3. 타입 선언과 타입 사용을 별도 파일로 관리할 필요가 없습니다</h3>
<p>타입스크립트의 큰 특징은 덕 타이핑입니다. 타입 주도 개발을 하려고 할 때</p>
<p>타입 주도 개발과 시그니쳐를 먼저 설정하는 것의 차이를 명확히 알고, 모든 타입을 다 선언하고 관계를 다 그린이후에 개발을 하려고 하지 않아도 된다. 이는 애자일에도 맞지 않음. 적절한 수준의 중복이 성급한 추상화보다 훨씬 낫다는걸 깨닫게 된다.</p>
<h3>4. .ts 파일 내 앰비언트 변수 선언은 개발자에게 혼란을 야기합니다</h3>
<p><code>declare</code> 키워드를 이용한 앰비언트 변수 선언은 <code>d.ts</code> 파일이 아닌 <code>.ts</code>, <code>.tsx</code> 파일 내에서도 가능합니다.</p>
<pre><code>// src/index.tsx
import React from "react";
import ReactDOM from "react-dom";
import App from "App";

declare global {
  interface Window {
    JavaScriptInterface: {
      getCommonInfo: (callbackString: string) => void;
    };
    getCommonInfoCallback?: (jsonStr: string) => void | undefined;
  }
}

ReactDOM.render(
  &#x3C;React.StrictMode>
    &#x3C;App />
  &#x3C;/React.StrictMode>,
  document.getElementById("root")
);
</code></pre>
<p>그러나 앰비언트 변수 선언과 일반 타입 선언이 섞이게 되면, 어떤 파일에 앰비언트 선언이 포함되어 있는지 관리가 여럽게 됩니다. 위의 예제에서는 window 전역 객체의 확장이고 src/index.tsx 라는 최상위 파일에서 앰비언트 변수 선언을 하여서 그나마 파악이 쉬우나, 어떤 작은 컴포넌트에 앰비언트 변수 선언이 포함되어 있어 모든 파일의 타입에 영향을 미친다면 굉장히 관리가 어려울 수 있습니다.</p>
<p>앰비언트 타입 선언을 <code>d.ts</code>에서 한다는 것은 개발자들간의 약속입니다. 있어야 할 곳에 있어야 할 것이 있는 코드가 가독성도 높고 이해하기도 쉽고, 유지보수하기도 편하한 코드일 것입니다.</p>
</main><footer class="sc-8d5d6634-1 dsDnMD">Copyright© 2022 All right reserved</footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"ts-ambient-type-declaration","contentHtml":"\u003cp\u003e타입스크립트의 타입 선언은 \u003ccode\u003e.ts, .tsx\u003c/code\u003e 확장자를 가진 파일에서도 할 수 있지만 \u003ccode\u003e.d.ts\u003c/code\u003e 확장자를 가진 파일에서도 할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003eI. 앰비언트 타입 선언\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e.d.ts\u003c/code\u003e 확장자를 가진 파일에서는 타입 선언만 할 수 있고 값을 표현할 수는 없습니다. 값을 포함하는 일반적인 선언과 구별하기 위해 \u003ccode\u003ed.ts\u003c/code\u003e 확장자를 가진 파일에서 하는 타입 선언에 앰비언트(ambient; 주위의, 주변의)라는 표현을 붙여 \u003cstrong\u003e앰비언트 타입 선언\u003c/strong\u003e이라고 부릅니다.\n타입스크립트에서 class는 타입으로도 값으로도 사용되지만, \u003ccode\u003ed.ts\u003c/code\u003e 확장자를 가진 파일에서는 타입 선언만 할 수 있고 메서드의 구체적인 구현이나 프로퍼티의 할당은 할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e다만 값을 정의할 수는 없지만, \u003ccode\u003edeclare\u003c/code\u003e 라는 특별 키워드를 사용해 자바스크립트의 다른 어딘가에 값이 있다는 사실을 선언할 수 있습니다.\n\u003ccode\u003edeclare\u003c/code\u003e 는 \"나의 자바스크립트는 이 타입을 익스포트함을 맹세한다\"라고 선언하는 것이라 생각하면 좋습니다.\u003c/p\u003e\n\u003cp\u003e또 다른 특징으로는 앰비언트 타입 선언은 명시적으로 \u003ccode\u003eimport\u003c/code\u003e 하지 않더라도 어디서든 사용할 수 있다는 점입니다. 앰비언트 타입 선언은 마치 전역 변수를 설정하는 것과 유사합니다.\u003c/p\u003e\n\u003ch2\u003eII. 언제 앰비언트 타입 선언이 주로 사용되나요\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e.ts, .tsx\u003c/code\u003e확장자를 가진 파일에서는 타입 선언과 구현을 모두 할 수 있으므로 일반적으로 앰비언트 타입 선언을 사용하여 타입 선언과 구현을 분리할 필요는 없습니다. 그럼 반대로 타입 선언과 구현을 같이 할 수 없는 상황을 생각해 보면, 언제 앰비언트 타입 선언을 사용해야 하는지 알 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e1. 타입 선언이 없는 자바스크립트로 작성된 서드 파티 라이브러리\u003c/h3\u003e\n\u003cp\u003eDefinitelyTyped 를 잠시 잊어보겠습니다. 자바스크립트로 작성된 npm library 가 있다고 가정해보겠습니다. 자바스크립트로 구현하였기에 이에 대한 타입 선언은 없습니다.\n타입스크립트에서 사용은 가능하나 타입 선언이 없으므로 import 한 모듈은 모두 any 로 추론될 것이며, tsconfig.json 설정에서 any 사용을 금지하였다면 빌드되지 않을 것입니다.\n이러한 경우에 앰비언트 타입 선언을 사용할 수 있습니다. 앰비언트 타입 선언으로 자바스크립트 라이브러리 내 함수, 변수들의 타입을 선언하면, 타입스크립트는 컴파일 시에 자동으로 \u003ccode\u003ed.ts\u003c/code\u003e 확장자를 가진 파일을 검색해서 타입 체킹에 이용하므로 문제없이 컴파일됩니다. vscode와 같은 코드 편집기도 \u003ccode\u003ed.ts\u003c/code\u003e 확장자를 가진 파일을 읽어 해석한 다음 코드 작성시 유용한 타입 힌트를 제공합니다.\u003c/p\u003e\n\u003cp\u003eDefinitelyTyped 에 있는 라이브러리가 하는 일이 방금 저희가 한 일입니다.\n예를 들어 @types/react 를 \u003ccode\u003enpm install -D\u003c/code\u003e 하면 node_modules/@types/react 에 index.d.ts, global.d.ts 가 설치됩니다. 여기에 리액트의 컴포넌트, 훅에 대한 타입이 정의가 되어 있습니다. 그리고 tsc는 별도의 설정을 해주지 않더라도 node_modules/@types 디렉토리에 있는 타입 선언을 타입 체킹에 이용합니다.\n또한 vscode는 index.d.ts, global.d.ts를 이용하여 타입 힌트를 제공합니다.\u003c/p\u003e\n\u003cp\u003e즉, 앰비언트 타입 선언은 타입스크립트에 \"자바스크립트에는 이런저런 정보가 정의되어 있어\"라고 알려주는 수단으로 생각할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e2. 타입스크립트로 작성된 서드 파티 라이브러리\u003c/h3\u003e\n\u003cp\u003e서드 파티 라이브러리는 타입스크립트로 작성되더라도 자바스크립트 파일과 \u003ccode\u003ed.ts\u003c/code\u003e 파일으로 배포되는 것이 일반적입니다.\u003c/p\u003e\n\u003cp\u003e타입스크립트 파일을 배포하여 라이브러리 사용자가 타입스크립트를 컴파일할 때 라이브러리 코드도 포함해서 컴파일하게 할 수도 있으나, 자바스크립트 파일과 \u003ccode\u003ed.ts\u003c/code\u003e 파일로 배포하면 라이브러리 파일을 또 컴파일할 필요가 없어 컴파일 시간을 크게 줄여줍니다. 또한 \u003ccode\u003ed.ts\u003c/code\u003e 파일이 있으므로 당연히 타입 관점에서 동일한 기능을 제공할 수 있습니다.\ntsconfig.json의 \u003ccode\u003edeclaration\u003c/code\u003e을 true 로 설정하면 타입스크립트는 컴파일 시 \u003ccode\u003ed.ts\u003c/code\u003e 파일을 자동으로 생성합니다.\u003c/p\u003e\n\u003ch3\u003e3. 프로젝트 어디에서나 전역으로 이용할 수 있는 타입을 정의하여 임포트 없이 바로 사용하고자 할 때\u003c/h3\u003e\n\u003cp\u003e앰비언트 타입 선언은 전역 변수와 같습니다. 따라서 앰비언트 타입 선언으로 타입을 선언하면 모든 코드 내에서 import 하지 않고 사용할 수 있습니다. 예를 들어 정말 유용한 타입 유틸 함수를 작성했다고 가정해보겠습니다. 그렇다면 앰비언트 타입 선언으로 타입 유틸 함수를 선언한다면 더이상 명시적으로 모든 코드에 import하지 않더라도 사용할 수 있습니다. 마치 내장 타입 유틸 함수인 것 처럼 말이죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// src/index.d.ts\ntype Optional\u0026#x3C;T extends object, K extends keyof T = keyof T\u003e = Omit\u0026#x3C;T, K\u003e \u0026#x26;\n  Partial\u0026#x3C;Pick\u0026#x3C;T, K\u003e\u003e;\n\n// src/components.ts\ntype Props = { name: string; age: number; visible: boolean };\ntype OptionalProps = Optional\u0026#x3C;Props\u003e; // Expect: { name?: string; age?: number; visible?: boolean; }\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e4. 자바스크립트 어딘가에 전역 변수가 정의되어 있음을 타입스크립트에 알릴 때\u003c/h3\u003e\n\u003cp\u003e타입스크립트로 직접 구현하지는 않았지만 실제로는 자바스크립트 어딘가에 전역 변수가 정의되어 있음을 타입스크립트에 알릴 때 사용합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어 웹뷰 개발시 네이티브앱과의 통신을 위한 인터페이스를 네이티브앱이 윈도우 객체에 추가하는 경우가 많습니다. 즉, 타입스크립트로 직접 구현을 하지는 않았지만 실제로 해당 변수(자바스크립트의 함수는 일급 객체이므로 변수의 범위에 함수도 당연히 포함됩니다)가 정의되어 있어 런타임에서 해당 변수를 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어 deviceId, appVersion, latitude, longitutde 같은 값을 네이티브 앱에서 window 전역 객체에 할당해준다고 하겠습니다. 이러한 window 객체의 프로퍼티는 실제로 타입스크립트로 정의한 값이 아니므로 타입스크립트는 window 객체의 타입에 이러한 속성이 없는 것으로 판단하여 이러한 속성에 접근하려고 하면 window 객체에 존재하지 않는 프로퍼티라는 에러를 방출하게 됩니다.\n따라서 global namespace에 있는 Window 객체에 해당 프로퍼티가 정의되어 있다는 것을 나타내기 위해 앰비언트 타입 선언을 이용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edeclare global {\n  interface Window {\n    deviceId: string | undefined;\n    appVersion: string;\n    latitude: string | undefined;\n    longitude: string | undefined;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eIII. 언제 앰비언트 타입 선언을 사용하는 것이 좋은가?\u003c/h2\u003e\n\u003ch3\u003e❌ 타입스크립트로 라이브러리 개발시\u003c/h3\u003e\n\u003cp\u003etsconfig.json의 \u003ccode\u003edeclaration\u003c/code\u003e을 true 로 설정하면 타입스크립트는 컴파일 시 \u003ccode\u003ed.ts\u003c/code\u003e 파일을 자동으로 생성하므로, 수동으로 \u003ccode\u003ed.ts\u003c/code\u003e를 작성할 필요가 없습니다.\n따라서 타입스크립트로 라이브러리 개발시에는 앰비언트 타입 선언을 사용할 필요가 없습니다.\u003c/p\u003e\n\u003ch3\u003e❌ 프로젝트 어디에서나 전역으로 이용할 수 있는 타입을 정의하여 import 없이 바로 사용하기 위해\u003c/h3\u003e\n\u003cp\u003e앰비언트 타입 선언은 마치 프로토타입에 메서드를 추가하는 것과 같습니다. 서로 다른 라이브러리에서 동일한 이름의 앰비언트 타입 선언을 한다면 충돌이 발생하여 어떤 타입 선언이 적용되는지 알 수 없고, 원하는대로 동작하지 않을 수 있습니다. 또한 명시적인 import, export가 없기 때문에 의존성 관계가 보이지 않아 추후 변경이 어려울 수 있습니다. 따라서 전역으로 이용하기 위한 타입도 \u003ccode\u003e.ts\u003c/code\u003e 파일에 작성하고 명시적으로 import 하는 것을 추천합니다.\u003c/p\u003e\n\u003ch3\u003e🤔 DefinitelyTyped에 타입 선언이 존재하지 않는 라이브러리에 타입 추가시\u003c/h3\u003e\n\u003cp\u003e이런 라이브러리는 사용하지 않는 것이 좋습니다. 다른 대안을 찾아보세요. 타입을 직접 추가해야하는 라이브러리를 사용하기 위해 동료들을 설득하는 것은 라이브러리에 타입을 추가하는 것보다 더 힘든 일입니다.\u003c/p\u003e\n\u003ch3\u003e✅ 타입스크립트로 정의하지는 않았지만 실행시에는 존재하는 인터페이스 정의시\u003c/h3\u003e\n\u003ch4\u003e1. webpack 등의 번들러는 json, css, image 파일등을 모듈로 취급합니다\u003c/h4\u003e\n\u003cp\u003e하지만 타입스크립트는 json, css, image 파일의 모듈을 타입을 알 수 없기 때문에 앰비언트 모듈 선언을 해주어야 합니다. \u003ccode\u003ereact-scripts\u003c/code\u003e를 사용하는 경우, \u003ccode\u003ereact-app.d.ts\u003c/code\u003e에 이미 정의되어 있어 별도의 설정이 필요하지 않을 수도 있습니다\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// node_modules/react-scripts/lib/react-app.d.ts\ndeclare module \"*.jpg\" {\n  const src: string;\n  export default src;\n}\n\ndeclare module \"*.png\" {\n  const src: string;\n  export default src;\n}\n\ndeclare module \"*.webp\" {\n  const src: string;\n  export default src;\n}\n\ndeclare module \"*.svg\" {\n  import * as React from \"react\";\n\n  export const ReactComponent: React.FunctionComponent\u0026#x3C;\n    React.SVGProps\u0026#x3C;SVGSVGElement\u003e \u0026#x26; { title?: string }\n  \u003e;\n\n  const src: string;\n  export default src;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e2. 전역변수 확장\u003c/h4\u003e\n\u003cp\u003e웹뷰 개발시 네이티브앱과의 통신을 위한 인터페이스를 window 객체에 추가하는 경우가 많습니다. 이러한 경우에는 앰비언트 타입 선언을 사용하여야 합니다.\u003c/p\u003e\n\u003ch2\u003eIV. 앰비언트 타입 선언을 잘못 썼을 때 문제점\u003c/h2\u003e\n\u003ch3\u003e1. 앰비언트 타입 선언은 의존성 관계가 보이지 않기 때문에 변경의 영향 범위 파악이 어렵습니다\u003c/h3\u003e\n\u003cp\u003e명시적인 import, export 없이 코드 전역에서 사용할 수 있기 때문입니다. 자주 변경되는 타입 선언의 경우,\u003c/p\u003e\n\u003cp\u003e하기 때문입니다. 가 보이지 않기 때문에\u003c/p\u003e\n\u003cp\u003e소스 코드의 규모가 큰 경우, 변경이 어려울 수 있다.\u003c/p\u003e\n\u003ch3\u003e2. 타입스크립트로 정의하지는 않았지만 실행시 존재하는 인터페이스는 배포 시점 관리가 중요합니다\u003c/h3\u003e\n\u003cp\u003e네이티브 앱과의 인터페이스가 수정이 될 경우, window 객체를 확장한 앰비언트 타입 선언도 이에 맞추어 수정되어야 합니다. 원활한 커뮤니케이션으로 네이티브 앱 인터페이스 변경 시점과 웹뷰 변경 시점을 잘 맞추어야 합니다.\u003c/p\u003e\n\u003ch3\u003e3. 타입 선언과 타입 사용을 별도 파일로 관리할 필요가 없습니다\u003c/h3\u003e\n\u003cp\u003e타입스크립트의 큰 특징은 덕 타이핑입니다. 타입 주도 개발을 하려고 할 때\u003c/p\u003e\n\u003cp\u003e타입 주도 개발과 시그니쳐를 먼저 설정하는 것의 차이를 명확히 알고, 모든 타입을 다 선언하고 관계를 다 그린이후에 개발을 하려고 하지 않아도 된다. 이는 애자일에도 맞지 않음. 적절한 수준의 중복이 성급한 추상화보다 훨씬 낫다는걸 깨닫게 된다.\u003c/p\u003e\n\u003ch3\u003e4. .ts 파일 내 앰비언트 변수 선언은 개발자에게 혼란을 야기합니다\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003edeclare\u003c/code\u003e 키워드를 이용한 앰비언트 변수 선언은 \u003ccode\u003ed.ts\u003c/code\u003e 파일이 아닌 \u003ccode\u003e.ts\u003c/code\u003e, \u003ccode\u003e.tsx\u003c/code\u003e 파일 내에서도 가능합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// src/index.tsx\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"App\";\n\ndeclare global {\n  interface Window {\n    JavaScriptInterface: {\n      getCommonInfo: (callbackString: string) =\u003e void;\n    };\n    getCommonInfoCallback?: (jsonStr: string) =\u003e void | undefined;\n  }\n}\n\nReactDOM.render(\n  \u0026#x3C;React.StrictMode\u003e\n    \u0026#x3C;App /\u003e\n  \u0026#x3C;/React.StrictMode\u003e,\n  document.getElementById(\"root\")\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 앰비언트 변수 선언과 일반 타입 선언이 섞이게 되면, 어떤 파일에 앰비언트 선언이 포함되어 있는지 관리가 여럽게 됩니다. 위의 예제에서는 window 전역 객체의 확장이고 src/index.tsx 라는 최상위 파일에서 앰비언트 변수 선언을 하여서 그나마 파악이 쉬우나, 어떤 작은 컴포넌트에 앰비언트 변수 선언이 포함되어 있어 모든 파일의 타입에 영향을 미친다면 굉장히 관리가 어려울 수 있습니다.\u003c/p\u003e\n\u003cp\u003e앰비언트 타입 선언을 \u003ccode\u003ed.ts\u003c/code\u003e에서 한다는 것은 개발자들간의 약속입니다. 있어야 할 곳에 있어야 할 것이 있는 코드가 가독성도 높고 이해하기도 쉽고, 유지보수하기도 편하한 코드일 것입니다.\u003c/p\u003e\n","title":"Ambient Type Declaration","date":"2022-05-07"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"ts-ambient-type-declaration"},"buildId":"mGeQbCKeTVK9iuQqBnbIJ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>