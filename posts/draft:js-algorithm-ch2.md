---
title: Ch02. 기초 알고리즘 지식
date: "2020-03-11"
summary: "기초 알고리즘 지식"
---

알고리즘은 문제를 해결하기 위해 사용하는 일련의 단계입니다. 문제를 해결하기 위해 사용하는 단계가 적을수록 더 효율적인 알고리즘이라고 할 수 있습니다. 알고리즘의 효율성을 분석할 때는 시간 복잡도와 공간 복잡도의 두 가지 방법을 이용합니다.

## 1. 시간복잡도

시간복잡도란 주어진 입력에 따라 알고리즘이 문제를 해결할 때 걸리는 시간을 의미합니다.

~~시간복잡도란 입력의 크기와 문제를 해결하는데 걸리는 시간의 상관관계를 의미합니다.~~

입력의 크기가 1일 때와 100일 때 걸리는 시간이 상이할텐데, 어떤 알고리즘은 입력의 크기가 100배 차이 나면 시간도 100배 차이 나는 알고리즘도 있고, 100배가 아니라 10,000배 차이가 날수도 있고, 2^100 배 차이가 날수도 있고, 동일한 시간이 걸릴 수도 있습니다.

이러한 시간복잡도를 나타내는 방법 중에 많이 사용되는 것이 빅 오 표기법(Big O Notation) 입니다.

### 1-1. 빅 오 표기법이란?

빅 오 표기법의 수학적 정의는 다음과 같습니다.

```
O(g(n)) = {f(n): 모든 n >= n0에 대해 0 <= f(n) <= cg(n)인 양의 상수 c, n0가 존재한다.}
```

굉장히 복잡해보이죠?

직관적으로 그냥 설명해보겠습니다.

빅 오 표기법은 주어진 입력값 N에 대하여 알고리즘을 수행할 때 필요한 단계수를 N을 사용하여 나타낸 방법입니다.

빅 오 표기법은 주어진 입력값 N이 증가할 때 해당 알고리즘을 수행할 때 필요한 단계수가 어떻게 증가하는지를 N을 사용하여 나타낸 방법입니다.

주어진 입력값 N은 어떤 상황인지, 어떤 알고리즘을 적용하려는지에 따라서 다 제각각인데요, 이 빅 오 표기법에 대해서 구체적인 예시를 통해서 조금 더 살펴보도록 하겠습니다.

#### 예시1) 배열에 특정 요소가 포함되어 있는지 확인하는 함수

`function includes(target: number, arr: number[]): boolean;`

이러한 표기법이 조금 낯설게 느껴지실텐데요, 이는 타입스크립트에서 사용하는 함수 타입을 나타낼 때 쓰는 방법입니다. 콜론 뒤의 값이 해당 변수의 타입을 나타내고, 마지막에 함수의 선언 이후에 기재된 boolean은 이 함수의 반환값의 타입을 나타냅니다.

이렇게 함수의 구현이 아니라 입력과 반환값의 타입만을 나타내는 것을 함수의 시그니쳐라고 말합니다.

저희는 타입스크립트로 구현하지는 않지만, 여러분들과 저와 함수를 구현하기 전에 이러한 형태의 함수를 구현해나갈거에요 라는 걸 말할 때 이런 표기법으로 종종 설명드리도록 하겠습니다.

즉, `includes` 라는 함수는 number 타입인 target과 number 타입의 배열인 arr을 차례로 매개변수로 전달받아 arr에 target이 포함되어 있으면 true를, 포함되어 있지 않다면 false를 반환하는 함수입니다.

예를 들어 보면 다음과 같습니다.

```js
includes(3, [1, 2, 3]); // true
includes(10, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]); // false
```

이를 단순하게 구현해 본다면 이렇게 될 수 있겠죠.

```js
function includes(target, arr) {
  let isFound = false;

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) {
      isFound = true;
    }
  }

  return isFound;
}
```

target은 항상 단 하나의 숫자이고, arr은 배열에 포함된 전체 요소의 갯수가 매번 다르겠죠. 그렇다면 여기서는 arr 배열에 포함된 전체 요소 개수를 N이라고 해보겠습니다.

그렇다면 includes 함수는 target을 찾기 위해 몇단계가 필요한가요?

N = 1 일 때, target과 일치하는지 하나의 요소만 비교하면 되니 1번입니다.
N = 2 일 때, target과 일치하는지 0번째 요소와 1번째 요소를 비교해야 하니 2번입니다.
N = 10일 때, 0번째 요소부터 9번째 요소까지 다 비교해야하니 10번입니다.
즉, N이 증가하면 그에 선형적으로 비례해서 단계수가 증가합니다.

그래프로 그려보면 아래와 같습니다.

이러한 includes 함수의 시간복잡도를 나타낼 때에 배열에 포함된 요소의 개수를 N이라고 할 때 `O(N)`이다 라고 표현합니다.

#### 예시2) 두 배열에 공통적으로 포함된 요소를 계산하는 함수

```js
function intersection(a:number[], b:number[]): number[]
```

```js
intersection([3, 4], [1, 2, 3]); // [3]
intersection([0, 2, 3, 4, 5, 6, 8, 9], [4, 1, 7, 9]); // [4, 9]
intersection([10, 11, 12], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]); // []
```

```js
function intersection(a, b) {
  const result = [];

  for (let ai = 0; ai < a.length; a++) {
    for (let bi = 0; bi < b.length; b++) {
      if (a[ai] === b[bi]) {
        result.push(a[ai]);
      }
    }
  }

  return result;
}
```

a 배열에 포함된 요소의 개수를 N, b 배열에 포함된 요소의 개수를 M이라고 할 경우,
a 배열에 포함된 요소를 모두 순회하면서 해당 요소가 b 배열에 포함된 요소인지를 b 배열을 모두 순회하면서 비교하여야 합니다.

a 배열에 포함된 요소의 개수가 10개에서 20개로 2배가 된다면, 순회횟수도 2배 증가합니다.
N과 M 각각에 선형적으로 비례하여 증가하므로,
`O(NxM)`

#### 예시3) 주어진 수가 짝수인지 확인하는 함수

```js
function isEven(n: number): boolean;
```

```js
isEven(1); // false
isEven(2); // true
isEven(3); // false
isEven(100); // true
```

```js
function isEven(n) {
  if (n % 2 === 0) return true;
  else return false;
}
```

n이 1에서 10000이 되더라도 나누어서 나머지가 0인지 확인하는 단계수는 증가하지 않습니다.

즉, n이 증가하더라도 단계수가 증가하지 않으므로 `O(0)` 이라고 표현해야 할 거 같은데, 일반적으로 n^0 에 비례한다고 하여 `O(n^0) = O(1)` 이라고 표현합니다.

### 1-2. 빅 오 표기법의 특징

#### a) 최대차수의 항만 고려하며 상수계수는 무시한다

#### b) 같은 O(N) 이라고 해서 동일하게 빠른게 아니다

#### c) 항상 O(N) < O(N^2) 이 아니다

#### d) 빅 오 표기법의 정의는 최악의 상황의 성능을 나타내지만, 관행적으로 최선과 평균을 나타낼 때도 사용한다

### 1-3. 코딩테스트에서 빅 오 표기법을 어떻게 사용해야 하는가

제한시간이 주어지는 문제가 있다. 구체적인 제한시간이 주어지지 않더라도 매우 많은 시간을 사용한다면 채점사이트에서 이를 무작정 기다릴 수 없으므로 일정 시간이 지나면 오답으로 처리한다.

일반적으로 아래와 같다. 하지만 1-2. 빅 오 표기법의 특징에서 말했듯이 N의 크기가 작으면 반드시 아래가 성립하지 않는다. 하지만 N이 충분히 커진다면 아래의 관계가 성립한다.

`O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(2^N) < O(N!)`

O(1)은 상수형 알고리즘...
O(logN)은 로그형 알고리즘 ..
(각각의 알고리즘 글로 한 번더 소개)

Node.js 로 1초에 대략 4000만번의 연산을 수행할 수 있다고 가정할 때, 1초내 수행할 수 있는 연산 수는 아래와 같다.

내가 떠올린 알고리즘의 빅오표기법이 O(N^2) 이고 최대 N이 10000이라면, 제한시간이 1초라면은 내가 아무리 알고리즘을 잘 구현하더라도 제한시간내에 되지 않겠구나 라고 추측할 수 있다. 그러나 빅오표기법에서 상수항은 무시하므로 정확하게 일치하는 것은 아니다. 대략적인 느낌만 잡아가면 된다.

## 2. 공간복잡도

공간복잡도란 알고리즘이 문제를 해결할 때 점유하는 컴퓨터의 메모리 공간을 뜻합니다.

## 3. 부동소수점

## 4. 자료형변환

## 5. 파일입출력

## 6. 문제풀이 예시
