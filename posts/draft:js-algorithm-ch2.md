---
title: Ch02. 기초 알고리즘 지식
date: "2020-03-11"
summary: "기초 알고리즘 지식"
---

앞으로 여러가지 알고리즘을 학습하게 될텐데요, 동일한 기능을 수행하는 알고리즘이 여러가지가 있을 수 있습니다. 예를 들어 정렬 알고리즘에서는 버블 정렬, 선택 정렬, 삽입 정렬, 머지 소트, 퀵 소트 등 여러가지 알고리즘을 수행해서 배열을 정렬할 수가 있습니다. 이러한 정렬 알고리즘 간에 어떤 것이 더 효율적인지를 어떻게 알 수 있을까요?
알고리즘의 효율성을 분석할 때는 시간 복잡도와 공간 복잡도의 두 가지 방법을 이용합니다.

## 1. 시간복잡도

시간복잡도란 주어진 입력에 따라 알고리즘이 문제를 해결할 때 걸리는 시간을 의미합니다.

~~시간복잡도란 입력의 크기와 문제를 해결하는데 걸리는 시간의 상관관계를 의미합니다.~~

입력의 크기가 1일 때와 100일 때 걸리는 시간이 상이할텐데, 어떤 알고리즘은 입력의 크기가 100배 차이 나면 시간도 100배 차이 나는 알고리즘도 있고, 100배가 아니라 10,000배 차이가 날수도 있고, 2^100 배 차이가 날수도 있고, 동일한 시간이 걸릴 수도 있습니다.

이러한 시간복잡도를 나타내는 방법 중에 많이 사용되는 것이 빅 오 표기법(Big O Notation) 입니다.

### 1-1. 빅 오 표기법이란?

빅 오 표기법의 수학적 정의는 다음과 같습니다.

```
O(g(n)) = {f(n): 모든 n >= n0에 대해 0 <= f(n) <= cg(n)인 양의 상수 c, n0가 존재한다.}
```

굉장히 복잡해보이죠?

직관적으로 그냥 설명해보겠습니다.

~~빅 오 표기법은 주어진 입력값 N에 대하여 알고리즘을 수행할 때 필요한 단계수를 N을 사용하여 나타낸 방법입니다.~~

빅 오 표기법은 주어진 입력값이 증가할 때 해당 알고리즘 수행에 필요한 단계수가 어떻게 증가하는지를 나타낸 것입니다.

빅 오 표기법에 대해서 구체적인 예시를 통해서 조금 더 살펴보도록 하겠습니다.

#### 예시1) 배열에 특정 요소가 포함되어 있는지 확인하는 함수

`function includes(target: number, arr: number[]): boolean;`

이러한 표기법이 조금 낯설게 느껴지실텐데요, 이는 타입스크립트에서 사용하는 함수 타입을 나타낼 때 쓰는 방법입니다. 콜론 뒤의 값이 해당 변수의 타입을 나타내고, 마지막에 함수의 선언 이후에 기재된 boolean은 이 함수의 반환값의 타입을 나타냅니다.

이렇게 함수의 구현이 아니라 입력과 반환값의 타입만을 나타내는 것을 함수의 시그니쳐라고 말합니다.

저희는 타입스크립트로 구현하지는 않지만, 여러분들과 저와 함수를 구현하기 전에 이러한 형태의 함수를 구현해나갈거에요 라는 걸 말할 때 이런 표기법으로 종종 설명드리도록 하겠습니다.

즉, `includes` 라는 함수는 number 타입인 target과 number 타입의 배열인 arr을 차례로 매개변수로 전달받아 arr에 target이 포함되어 있으면 true를, 포함되어 있지 않다면 false를 반환하는 함수입니다.

예를 들어 보면 다음과 같습니다.

```js
includes(3, [1, 2, 3]); // true
includes(10, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]); // false
```

이를 단순하게 구현해 본다면 이렇게 될 수 있겠죠.

```js
function includes(target, arr) {
  let isFound = false;

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) {
      isFound = true;
    }
  }

  return isFound;
}
```

target은 항상 단 하나의 숫자이고, arr은 배열에 포함된 전체 요소의 갯수가 매번 다르겠죠. 그렇다면 여기서는 arr 배열에 포함된 전체 요소 개수를 N이라고 해보겠습니다.

그렇다면 includes 함수는 target을 찾기 위해 몇단계가 필요한가요?

N = 1 일 때, target과 일치하는지 하나의 요소만 비교하면 되니 1번입니다.
N = 2 일 때, target과 일치하는지 0번째 요소와 1번째 요소를 비교해야 하니 2번입니다.
N = 10일 때, 0번째 요소부터 9번째 요소까지 다 비교해야하니 10번입니다.
즉, N이 증가하면 그에 선형적으로 비례해서 단계수가 증가합니다.

그래프로 그려보면 아래와 같습니다.

이러한 includes 함수의 시간복잡도를 나타낼 때에 배열에 포함된 요소의 개수를 N이라고 할 때 `O(N)`이다 라고 표현합니다.

#### 예시2) 두 배열에 공통적으로 포함된 요소를 계산하는 함수

```js
function intersection(a:number[], b:number[]): number[]
```

```js
intersection([3, 4], [1, 2, 3]); // [3]
intersection([0, 2, 3, 4, 5, 6, 8, 9], [4, 1, 7, 9]); // [4, 9]
intersection([10, 11, 12], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]); // []
```

```js
function intersection(a, b) {
  const result = [];

  for (let ai = 0; ai < a.length; a++) {
    for (let bi = 0; bi < b.length; b++) {
      if (a[ai] === b[bi]) {
        result.push(a[ai]);
      }
    }
  }

  return result;
}
```

a 배열에 포함된 요소의 개수를 N, b 배열에 포함된 요소의 개수를 M이라고 할 경우,
a 배열에 포함된 요소를 모두 순회하면서 해당 요소가 b 배열에 포함된 요소인지를 b 배열을 모두 순회하면서 비교하여야 합니다.

a 배열에 포함된 요소의 개수가 10개에서 20개로 2배가 된다면, 순회횟수도 2배 증가합니다.
N과 M 각각에 선형적으로 비례하여 증가하므로,
`O(NxM)`

#### 예시3) 주어진 수가 짝수인지 확인하는 함수

```js
function isEven(n: number): boolean;
```

```js
isEven(1); // false
isEven(2); // true
isEven(3); // false
isEven(100); // true
```

```js
function isEven(n) {
  if (n % 2 === 0) return true;
  else return false;
}
```

n이 1에서 10000이 되더라도 나누어서 나머지가 0인지 확인하는 단계수는 증가하지 않습니다.

즉, n이 증가하더라도 단계수가 증가하지 않으므로 `O(0)` 이라고 표현해야 할 거 같은데, 일반적으로 n^0 에 비례한다고 하여 `O(n^0) = O(1)` 이라고 표현합니다.

### 1-2. 빅 오 표기법의 특징

#### a) 최대차수의 항만 고려하며 상수계수는 무시한다

#### b) 같은 O(N) 이라고 해서 동일하게 빠른게 아니다

#### c) 항상 O(N) < O(N^2) 이 아니다

#### d) 빅 오 표기법의 정의는 최악의 상황의 성능을 나타내지만, 관행적으로 최선과 평균을 나타낼 때도 사용한다

### 1-3. 코딩테스트에서 빅 오 표기법을 어떻게 사용해야 하는가

제한시간이 주어지는 문제가 있다. 구체적인 제한시간이 주어지지 않더라도 매우 많은 시간을 사용한다면 채점사이트에서 이를 무작정 기다릴 수 없으므로 일정 시간이 지나면 오답으로 처리한다.

일반적으로 아래와 같다. 하지만 1-2. 빅 오 표기법의 특징에서 말했듯이 N의 크기가 작으면 반드시 아래가 성립하지 않는다. 하지만 N이 충분히 커진다면 아래의 관계가 성립한다.

`O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(2^N) < O(N!)`

O(1)은 상수형 알고리즘...
O(logN)은 로그형 알고리즘 ..
(각각의 알고리즘 글로 한 번더 소개)

Node.js 로 1초에 대략 4000만번의 연산을 수행할 수 있다고 가정할 때, 1초내 수행할 수 있는 연산 수는 아래와 같다.

내가 떠올린 알고리즘의 빅오표기법이 O(N^2) 이고 최대 N이 10000이라면, 제한시간이 1초라면은 내가 아무리 알고리즘을 잘 구현하더라도 제한시간내에 되지 않겠구나 라고 추측할 수 있다. 그러나 빅오표기법에서 상수항은 무시하므로 정확하게 일치하는 것은 아니다. 대략적인 느낌만 잡아가면 된다.

## 2. 공간복잡도

공간복잡도란 알고리즘이 문제를 해결할 때 점유하는 컴퓨터의 메모리 공간을 뜻합니다.

공간복잡도에서도 빅 오 표기법의 개념을 가져와서 사용할 수 있습니다.

공간복잡도에서 빅 오 표기법은 주어진 입력값 N이 증가할 때 해당 알고리즘을 수행할 때 필요한 메모리가 어떻게 증가하는지를 N을 사용하여 나타냅니다.

### 예제) 문자열 배열을 받아 모두 대문자로 바꾼 배열을 반환하는 함수

```js
function makeUpperCase(arr: string[]): string[];
```

```js
makeUpperCase(["apple", "banana", "cinnamon"]); // ["APPLE", "BANANA", "CINNAMON"]
```

```js
function makeUpperCase(arr) {
  return arr.map((str) => str.toUpperCase());
}
```

이 함수를 공간복잡도 관점에서 분석하면 원소 N개를 포함하는 새로운 배열을 생성합니다. 즉, 원래 주어진 배열 이외에 메모리를 더 소모합니다.

함수가 데이터 원소 N개 증가하면 N개의 메모리를 추가로 소모하므로 이 함수의 공간 복잡도는 O(N) 입니다.

메모리 효율적인 함수로 변경해보겠습니다.

```js
function makeUpperCase(arr) {
  for (let i = 0; i < arr.length; i++) {
    arr[i] = arr[i].toUpperCase();
  }

  return arr;
}
```

새 배열을 생성하지 않고 원래 배열을 수정하고, 수정된 배열을 반환합니다.
어떤 메모리도 추가로 소모하지 않으니 메모리 소모 관점에서는 엄청난 성능 향상입니다.

빅 오 표기법에 따르면 주어진 입력값이 증가하더라도 추가적으로 전혀 메모리를 소모하지 않으므로 O(N^0) = O(1) 입니다.

공간복잡도를 빅 오 표기법으로 나타낼 때에는 알고리즘에서 새로 생성한 데이터만 고려합니다. 원래 배열은 언제든 존재하고 알고리즘에서 추가로 소모하는 공간이 중요하니 원래 데이터 원소 N개는 빅 오로 나타낼 때 감안하지 않습니다.

버젼1과 버젼2의 시간 복잡도와 공간 복잡도를 모두 비교해보면 다음과 같습니다.

| 버전  | 시간 복잡도 | 공간 복잡도 |
| ----- | ----------- | ----------- |
| 버전1 | O(N)        | O(N)        |
| 버전2 | O(N)        | O(1)        |

버젼1과 버젼2 을 비교하였을 때 시간 복잡도는 동일하나 버전2가 공간 복잡도가 더 낮아졌으니 효율성 측면에서는 버젼2가 더 유리하다고 판단할 수 있습니다.

그러나 공간 복잡도와 시간 복잡도의 관계가 항상 이러한 것만은 아닙니다.

### 시간과 공간의 트레이드 오프

#### 두 수의 합 문제

숫자 배열을 입력받아 합해서 10(또는 주어진 다른 수)이 되는 두 수가 배열에 있는지를 true나 false로 반환하는 함수를 작성하면 된다. 단순하게 풀기 위해 배열에 중복은 없다고 가정합니다.

버젼1 시간복잡도: O(N^2) 공간복잡도: O(1)

버젼2 시간복잡도: O(N) 공간복잡도: O(N)

#### 또다른 예시로는 정렬도 있다.

선택 정렬
머지 소트
퀵 소트

자세히 설명하지는 않겠다. 일반적으로 코딩테스트에서 정렬

#### 일반적으로는 시간 복잡도를 더 중요시 여긴다

특히 자바스크립트에서는 함수형 프로그래밍의 개념을 많이 차용하여 사용되는데, 공간복잡도를 희생해서 더 빠른 시간복잡도를 얻는 것을 좋게 여긴다. 버젼2의 경우, 입력값을 변경시키는데 이는 함수형 프로그래밍에서 강조하는 순수 함수의 정의에 어긋난다.
이 입력값을 다른 곳에서 또 쓴다면, 버젼2를 통과한 입력값은 값이 변경되어있어 의도치 않은 버그를 일으킬 수 있다.

의도적으로 메모리 제한을 적게 주는 문제가 BOJ에는 있다. 그러나 일반적인 코딩테스트에서는 잘 나오지 않는다. 다만, 굉장히 큰 자료구조를 여러번 생성하거나 하면... 굉장히 속도가 느려져서 오히려 통과가 안되는 경우가 있다. 또 넉넉한 메모리를 통해서 손쉽게 풀 수 있는 알고리즘이 있다. 카운팅 소트 등...

또 재귀에서는 호출 스택이라는 숨겨진 공간복잡도가 있는데 이 부분에 대해서는 재귀 챕터에서 자세히 다루겠다.

#### 문제를 풀 때 시간 복잡도와 공간 복잡도를 잘 고려하자.

각 상황마다 주어진 최소 허용 속도와 메모리 한도를 알아야 한다. 제약을 이해하고 다양한 알고리즘 중에서 고르고 선택할 수 있고 속도와 메모리 요구사항에 맞게 효율성을 유지할 수 있다.

- 자바스크립트에서는 순수 함수의 개념을 이용하여 새로운 변수를 매번 정의하는 것을 선호하는 패턴이 현업에서도 일반적이므로 이러한 패턴을 적용하는 컨벤션을 익히는 것이 실제 알고리즘 문제 풀이에 미치는 영향을 알고 있어야 한다. 그래서 공간복잡도 때문에 초과되면 빠르게 이러한 패턴을 포기할 줄도 알아야 한다.

## 3. 부동소수점

## 4. 자료형변환

## 5. 파일입출력

## 6. 문제풀이 예시
