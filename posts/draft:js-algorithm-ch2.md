---
title: Ch02. 기초 알고리즘 지식
date: "2020-03-11"
summary: "기초 알고리즘 지식"
---

앞으로 여러가지 알고리즘을 학습하게 될텐데요, 동일한 기능을 수행하는 알고리즘이 여러가지가 있을 수 있습니다. 예를 들어 정렬 알고리즘에서는 버블 정렬, 선택 정렬, 삽입 정렬, 머지 소트, 퀵 소트 등 여러가지 알고리즘을 수행해서 배열을 정렬할 수가 있습니다. 이러한 정렬 알고리즘 간에 어떤 것이 더 효율적인지를 어떻게 알 수 있을까요?
알고리즘의 효율성을 분석할 때는 시간 복잡도와 공간 복잡도의 두 가지 방법을 이용합니다.

## 1. 시간복잡도

시간복잡도란 주어진 입력에 따라 알고리즘이 문제를 해결할 때 걸리는 시간을 의미합니다.

~~시간복잡도란 입력의 크기와 문제를 해결하는데 걸리는 시간의 상관관계를 의미합니다.~~

입력의 크기가 1일 때와 100일 때 걸리는 시간이 상이할텐데, 어떤 알고리즘은 입력의 크기가 100배 차이 나면 시간도 100배 차이 나는 알고리즘도 있고, 100배가 아니라 10,000배 차이가 날수도 있고, 2^100 배 차이가 날수도 있고, 동일한 시간이 걸릴 수도 있습니다.

이러한 시간복잡도를 나타내는 방법 중에 많이 사용되는 것이 빅 오 표기법(Big O Notation) 입니다.

### 1-1. 빅 오 표기법이란?

빅 오 표기법의 수학적 정의는 다음과 같습니다.

```
O(g(n)) = {f(n): 모든 n >= n0에 대해 0 <= f(n) <= cg(n)인 양의 상수 c, n0가 존재한다.}
```

굉장히 복잡해보이죠?

직관적으로 그냥 설명해보겠습니다.

~~빅 오 표기법은 주어진 입력값 N에 대하여 알고리즘을 수행할 때 필요한 단계수를 N을 사용하여 나타낸 방법입니다.~~

빅 오 표기법은 주어진 입력값이 증가할 때 해당 알고리즘 수행에 필요한 단계수가 어떻게 증가하는지를 나타낸 것입니다.

빅 오 표기법에 대해서 구체적인 예시를 통해서 조금 더 살펴보도록 하겠습니다.

#### 예시1) 배열에 특정 요소가 포함되어 있는지 확인하는 함수

`function includes(target: number, arr: number[]): boolean;`

이러한 표기법이 조금 낯설게 느껴지실텐데요, 이는 타입스크립트에서 사용하는 함수 타입을 나타낼 때 쓰는 방법입니다. 콜론 뒤의 값이 해당 변수의 타입을 나타내고, 마지막에 함수의 선언 이후에 기재된 boolean은 이 함수의 반환값의 타입을 나타냅니다.

이렇게 함수의 구현이 아니라 입력과 반환값의 타입만을 나타내는 것을 함수의 시그니쳐라고 말합니다.

저희는 타입스크립트로 구현하지는 않지만, 여러분들과 저와 함수를 구현하기 전에 이러한 형태의 함수를 구현해나갈거에요 라는 걸 말할 때 이런 표기법으로 종종 설명드리도록 하겠습니다.

즉, `includes` 라는 함수는 number 타입인 target과 number 타입의 배열인 arr을 차례로 매개변수로 전달받아 arr에 target이 포함되어 있으면 true를, 포함되어 있지 않다면 false를 반환하는 함수입니다.

예를 들어 보면 다음과 같습니다.

```js
includes(3, [1, 2, 3]); // true
includes(10, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]); // false
```

이를 단순하게 구현해 본다면 이렇게 될 수 있겠죠.

```js
function includes(target, arr) {
  let isFound = false;

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) {
      isFound = true;
    }
  }

  return isFound;
}
```

target은 항상 단 하나의 숫자이고, arr은 배열에 포함된 전체 요소의 갯수가 매번 다르겠죠. 그렇다면 여기서는 arr 배열에 포함된 전체 요소 개수를 N이라고 해보겠습니다.

그렇다면 includes 함수는 target을 찾기 위해 몇단계가 필요한가요?

N = 1 일 때, target과 일치하는지 하나의 요소만 비교하면 되니 1번입니다.
N = 2 일 때, target과 일치하는지 0번째 요소와 1번째 요소를 비교해야 하니 2번입니다.
N = 10일 때, 0번째 요소부터 9번째 요소까지 다 비교해야하니 10번입니다.
즉, N이 증가하면 그에 선형적으로 비례해서 단계수가 증가합니다.

그래프로 그려보면 아래와 같습니다.

이러한 includes 함수의 시간복잡도를 나타낼 때에 배열에 포함된 요소의 개수를 N이라고 할 때 `O(N)`이다 라고 표현합니다.

#### 예시2) 두 배열에 공통적으로 포함된 요소를 계산하는 함수

```js
function intersection(a:number[], b:number[]): number[]
```

```js
intersection([3, 4], [1, 2, 3]); // [3]
intersection([0, 2, 3, 4, 5, 6, 8, 9], [4, 1, 7, 9]); // [4, 9]
intersection([10, 11, 12], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]); // []
```

```js
function intersection(a, b) {
  const result = [];

  for (let ai = 0; ai < a.length; a++) {
    for (let bi = 0; bi < b.length; b++) {
      if (a[ai] === b[bi]) {
        result.push(a[ai]);
      }
    }
  }

  return result;
}
```

a 배열에 포함된 요소의 개수를 N, b 배열에 포함된 요소의 개수를 M이라고 할 경우,
a 배열에 포함된 요소를 모두 순회하면서 해당 요소가 b 배열에 포함된 요소인지를 b 배열을 모두 순회하면서 비교하여야 합니다.

a 배열에 포함된 요소의 개수가 10개에서 20개로 2배가 된다면, 순회횟수도 2배 증가합니다.
N과 M 각각에 선형적으로 비례하여 증가하므로,
`O(NxM)`

#### 예시3) 주어진 수가 짝수인지 확인하는 함수

```js
function isEven(n: number): boolean;
```

```js
isEven(1); // false
isEven(2); // true
isEven(3); // false
isEven(100); // true
```

```js
function isEven(n) {
  if (n % 2 === 0) return true;
  else return false;
}
```

n이 1에서 10000이 되더라도 나누어서 나머지가 0인지 확인하는 단계수는 증가하지 않습니다.

즉, n이 증가하더라도 단계수가 증가하지 않으므로 `O(0)` 이라고 표현해야 할 거 같은데, 일반적으로 n^0 에 비례한다고 하여 `O(n^0) = O(1)` 이라고 표현합니다.

### 1-2. 빅 오 표기법의 특징

#### a) 최대차수의 항만 고려하며 상수계수는 무시한다

#### b) 같은 O(N) 이라고 해서 동일하게 빠른게 아니다

#### c) 항상 O(N) < O(N^2) 이 아니다

#### d) 빅 오 표기법의 정의는 최악의 상황의 성능을 나타내지만, 관행적으로 최선과 평균을 나타낼 때도 사용한다

### 1-3. 코딩테스트에서 빅 오 표기법을 어떻게 사용해야 하는가

제한시간이 주어지는 문제가 있다. 구체적인 제한시간이 주어지지 않더라도 매우 많은 시간을 사용한다면 채점사이트에서 이를 무작정 기다릴 수 없으므로 일정 시간이 지나면 오답으로 처리한다.

일반적으로 아래와 같다. 하지만 1-2. 빅 오 표기법의 특징에서 말했듯이 N의 크기가 작으면 반드시 아래가 성립하지 않는다. 하지만 N이 충분히 커진다면 아래의 관계가 성립한다.

`O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(2^N) < O(N!)`

O(1)은 상수형 알고리즘...
O(logN)은 로그형 알고리즘 ..
(각각의 알고리즘 글로 한 번더 소개)

Node.js 로 1초에 대략 4000만번의 연산을 수행할 수 있다고 가정할 때, 1초내 수행할 수 있는 연산 수는 아래와 같다.

내가 떠올린 알고리즘의 빅오표기법이 O(N^2) 이고 최대 N이 10000이라면, 제한시간이 1초라면은 내가 아무리 알고리즘을 잘 구현하더라도 제한시간내에 되지 않겠구나 라고 추측할 수 있다. 그러나 빅오표기법에서 상수항은 무시하므로 정확하게 일치하는 것은 아니다. 대략적인 느낌만 잡아가면 된다.

## 2. 공간복잡도

공간복잡도란 알고리즘이 문제를 해결할 때 점유하는 컴퓨터의 메모리 공간을 뜻합니다.

공간복잡도에서도 빅 오 표기법의 개념을 가져와서 사용할 수 있습니다.

공간복잡도에서 빅 오 표기법은 주어진 입력값 N이 증가할 때 해당 알고리즘을 수행할 때 필요한 메모리가 어떻게 증가하는지를 N을 사용하여 나타냅니다.

### 예제) 문자열 배열을 받아 모두 대문자로 바꾼 배열을 반환하는 함수

```js
function makeUpperCase(arr: string[]): string[];
```

```js
makeUpperCase(["apple", "banana", "cinnamon"]); // ["APPLE", "BANANA", "CINNAMON"]
```

```js
function makeUpperCase(arr) {
  return arr.map((str) => str.toUpperCase());
}
```

이 함수를 공간복잡도 관점에서 분석하면 원소 N개를 포함하는 새로운 배열을 생성합니다. 즉, 원래 주어진 배열 이외에 메모리를 더 소모합니다.

함수가 데이터 원소 N개 증가하면 N개의 메모리를 추가로 소모하므로 이 함수의 공간 복잡도는 O(N) 입니다.

메모리 효율적인 함수로 변경해보겠습니다.

```js
function makeUpperCase(arr) {
  for (let i = 0; i < arr.length; i++) {
    arr[i] = arr[i].toUpperCase();
  }

  return arr;
}
```

새 배열을 생성하지 않고 원래 배열을 수정하고, 수정된 배열을 반환합니다.
어떤 메모리도 추가로 소모하지 않으니 메모리 소모 관점에서는 엄청난 성능 향상입니다.

빅 오 표기법에 따르면 주어진 입력값이 증가하더라도 추가적으로 전혀 메모리를 소모하지 않으므로 O(N^0) = O(1) 입니다.

공간복잡도를 빅 오 표기법으로 나타낼 때에는 알고리즘에서 새로 생성한 데이터만 고려합니다. 원래 배열은 언제든 존재하고 알고리즘에서 추가로 소모하는 공간이 중요하니 원래 데이터 원소 N개는 빅 오로 나타낼 때 감안하지 않습니다.

버젼1과 버젼2의 시간 복잡도와 공간 복잡도를 모두 비교해보면 다음과 같습니다.

| 버전  | 시간 복잡도 | 공간 복잡도 |
| ----- | ----------- | ----------- |
| 버전1 | O(N)        | O(N)        |
| 버전2 | O(N)        | O(1)        |

버젼1과 버젼2 을 비교하였을 때 시간 복잡도는 동일하나 버전2가 공간 복잡도가 더 낮아졌으니 효율성 측면에서는 버젼2가 더 유리하다고 판단할 수 있습니다.

그러나 공간 복잡도와 시간 복잡도의 관계가 항상 이러한 것만은 아닙니다.

### 시간과 공간의 트레이드 오프

#### 두 수의 합 문제

숫자 배열을 입력받아 합해서 10(또는 주어진 다른 수)이 되는 두 수가 배열에 있는지를 true나 false로 반환하는 함수를 작성하면 된다. 단순하게 풀기 위해 배열에 중복은 없다고 가정합니다.

버젼1 시간복잡도: O(N^2) 공간복잡도: O(1)

버젼2 시간복잡도: O(N) 공간복잡도: O(N)

#### 또다른 예시로는 정렬도 있다.

선택 정렬
머지 소트
퀵 소트

자세히 설명하지는 않겠다. 일반적으로 코딩테스트에서 정렬

#### 일반적으로는 시간 복잡도를 더 중요시 여긴다

특히 자바스크립트에서는 함수형 프로그래밍의 개념을 많이 차용하여 사용되는데, 공간복잡도를 희생해서 더 빠른 시간복잡도를 얻는 것을 좋게 여긴다. 버젼2의 경우, 입력값을 변경시키는데 이는 함수형 프로그래밍에서 강조하는 순수 함수의 정의에 어긋난다.
이 입력값을 다른 곳에서 또 쓴다면, 버젼2를 통과한 입력값은 값이 변경되어있어 의도치 않은 버그를 일으킬 수 있다. 버젼2와 같이 실제 함수에 전달된 원본 배열을 수정하는 것을 제자리(in-place) 수정이라고 불린다.

의도적으로 메모리 제한을 적게 주는 문제가 BOJ에는 있다. 그러나 일반적인 코딩테스트에서는 잘 나오지 않는다. 다만, 굉장히 큰 자료구조를 여러번 생성하거나 하면... 굉장히 속도가 느려져서 오히려 통과가 안되는 경우가 있다. 또 넉넉한 메모리를 통해서 손쉽게 풀 수 있는 알고리즘이 있다. 카운팅 소트 등...

또 재귀에서는 호출 스택이라는 숨겨진 공간복잡도가 있는데 이 부분에 대해서는 재귀 챕터에서 자세히 다루겠다.

#### 문제를 풀 때 시간 복잡도와 공간 복잡도를 잘 고려하자.

각 상황마다 주어진 최소 허용 속도와 메모리 한도를 알아야 한다. 제약을 이해하고 다양한 알고리즘 중에서 고르고 선택할 수 있고 속도와 메모리 요구사항에 맞게 효율성을 유지할 수 있다.

- 자바스크립트에서는 순수 함수의 개념을 이용하여 새로운 변수를 매번 정의하는 것을 선호하는 패턴이 현업에서도 일반적이므로 이러한 패턴을 적용하는 컨벤션을 익히는 것이 실제 알고리즘 문제 풀이에 미치는 영향을 알고 있어야 한다. 그래서 공간복잡도 때문에 초과되면 빠르게 이러한 패턴을 포기할 줄도 알아야 한다.

## 3. 숫자를 다룰 때 주의할 점: 부동소수점

### 3-1. 0.3 - 0.2 === 0.1

console.log(0.3 - 0.2 === 0.1) 을 자바스크립트로 실행시키면 true가 출력될까요 false가 출력될까요??

웬 뜬금없는 질문이냐고 생각하실 수 있는데요, 정답은 false 입니다.

당황하신 분도 계실 것 같아요. 이때까지 내가 배워온 수학이 뭔가 잘못되었던 걸까?

하지만 그렇지 않습니다. 이론적으로는 0.3 - 0.2 === 0.1 은 true가 맞습니다. 우리가 사용하는 일상생활에서 사용하고 있는 숫자 체계는 10진법이죠.
0 ~ 9 까지의 숫자를 사용하고, 한 자리수를 추가할 때마다 10이 곱해집니다.

```
235 = 2 * 10 ^ 2 + 3 * 10 ^ 1 + 5 * 10 ^ 0
```

소숫점도 동일합니다.

```
38.746 = 3 * 10 ^ 1 + 8 * 10 ^ 0 + 7 * 10 ^ (-1) + 4 * 10 ^ (-2) + 6 * 10 ^ (-3)

0.3 = 3 * 10 ^ (-1)
```

그러나 컴퓨터는 내부적으로 0 과 1의 숫자만을 사용해서 한 자리수를 추가할 때마다 2가 곱해지는 2진법을 사용하고 있죠.

```
38.746 = 100110.10111110111110011101101100100010110100001110011
0.3 = 0.010011001100110011001100110011001100110011001100110011
0.2 = 0.001100110011001100110011001100110011001100110011001101
0.1 = 0.0001100110011001100110011001100110011001100110011001101

```

0.3은 10진법으로 표기할 때는 딱 떨어지는 깔끔한 숫자입니다

그런데 2진법으로 표기하면 딱 떨어지지 않습니다.

1/3 을 예시로 들어볼까요?

1/3 을 소수로 나타내면 `0.3333333333333333` 이고 3을 무한대로 계속해서 적어야 합니다. 이론적으로는 3을 무한대로 적으면 되는데 실생활에서는 이를 무한대로 적을 수가 없죠. 그래서 과학이라는 분야에서는 유효범위라는 걸 정해서 몇자리수까지는 유효하다 이렇게 표현하기도 합니다.

0.3은 2진법으로 표기하면 마치 10진법의 1/3 처럼 딱 떨어지지가 않습니다.
`0.010011001100110011001100110011001100110011001100110011`
1100 이 계속해서 반복되죠. 컴퓨터는 유한한 메모리 내에서 이 수를 표현해야 하기 때문에 이 또한 정확하지가 않습니다.
0.2, 0.1 또한 마찬가지입니다.

따라서 정확하게 일치하지 않는 것입니다.

반대로 정확하게 표시되는 수가 무엇이 있을까요?
바로 0.5, 0.25 와 같은 수가 있습니다.

```
0.5 = 1 * 2 ^ (-1)
0.25 = 0 * 2 ^ (-1) + 1 * 2 ^ (-2)
```

그렇기 때문에 0.5 - 0.25 === 0.25 는 true가 됩니다.

### 3-2. double-precision 64-bit binary format IEEE 754

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number

자바스크립트에서 숫자를 나타내는 원시자료형(primitive type)은 두가지가 있습니다. number와 bigint 입니다.

bigint는 ES2020에 추가된 스펙인데, 여기서는 일단 number에 대해서만 알아보도록 하겠습니다.

유한한 메모리 구조 내에서 number를 나타내기 위해서 사용되는 여러가지 표준이 있는데, 그 중에서 자바스크립트는 double-precision 64-bit binary format IEEE 754 로 숫자를 표현하는데, 간단히 설명드리자면

0 또는 1의 값을 가지는 64개의 비트로 숫자를 나타내며,

```
가수부 x 2 ^ (지수부)
```

부호(sign) 1비트, 지수(exponent) 11비트, 가수(fraction) 52비트로 나타냅니다.

![](https://wikimedia.org/api/rest_v1/media/math/render/svg/61345d47f069d645947b9c0ab676c75551f1b188)

![](https://wikimedia.org/api/rest_v1/media/math/render/svg/300577464b37b5769a97e85aa67c56200e1011df)

```
0.3 = 0 01111111110 0100110011001100110011001100110011001100110011001100

0.3 = (-1)^0 * (1.0100110011001100110011001100110011001100110011001100) * 2 ^ (01111111110 - 01111111111)

```

#### 가장 큰 수

https://en.wikipedia.org/wiki/Double-precision_floating-point_format

따라서 이러한 정의에 따라 표현할 수 있는 가장 큰 숫자는 아래와 같고, 이는 Number.MAX_VALUE 로 접근 가능.

```
0 11111111110 1111111111111111111111111111111111111111111111111111
≙ 7FEF FFFF FFFF FFFF16
≙ +2 ^ 1023 × (1 + (1 − 2^ (−52))
≈ 1.7976931348623157 × 10 ^ 308
```

#### 가장 작은 수

`Number.MIN_VALUE === 5e-324`

#### 그래서 연산시에 주의할 점

소수간의 비교를 할 때 정확하게 일치하는지로 구분하면 안된다. 소수 자체가 정확하게 표현되어 있지 않기 때문에 무조건 오차가 발생하기 때문에.
그래서 실제값과 기대값의 차이가 일정 범위 안에 있는지를 확인하는게 좋다.

```
(0.3 - 0.2) - 0.1 < Number.EPSILON
```

#### EPSILON 이란...

Number.EPSILON
The value of Number.EPSILON is the Number value for the magnitude of the difference between 1 and the smallest value greater than 1 that is representable as a Number value, which is approximately 2.2204460492503130808472633361816 × 10-16.

#### 가장 큰 양의 정수

https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-properties-of-the-number-constructor

The value of Number.MAX_SAFE_INTEGER is 9007199254740991𝔽 (𝔽(2\*\*53 - 1)).

#### 가장 작은 음의 정수

The value of Number.MIN_SAFE_INTEGER is -9007199254740991𝔽 (𝔽(-(2\*\*53 - 1))).

### 3-3. Infinity

무한대의 숫자를 나타낼 때 Infinity를 사용한다.
음의 무한대는 -Infinity

Infinity 는 어떠한 연산을 사용하더라도 절대 도달할 수 없는 값이므로 최초값을 할당할 때 많이 쓴다

예를 들어서 배열의 가장 작은 값을 찾는 함수

`funtion min(arr: number[]):number` 가 있다고 가정해보자.

```min

function min(arr) {
  let min = Infinity;

  for(const num of arr) {
    if (min > num) {
      min = num;
    }
  }

  return min;
}
```

min의 초기값으로 Infinity를 할당하면 for - of 루프의 첫번째 패스스루에서 항상 min 이 num 보다 크게 되어 min = num 이 실행된다.

## 4. 자료형변환

### 4-1. 암시적 형변환

서로 다른 자료형간의 연산을 수행하면 자바스크립트에서는 암시적 형변환이 일어난다. 예를들어 다음과 같다

```js

"1" + 1 === "11"
"1" - 1 === 0

true + 1 === 2
[] + 2 === "2"
```

명시적으로 자료형을 변환해서 쓰자. 암시적을 몰라도 된다는건 아니지만 명시적 형변환이 더욱 의도를 명확하게 한다.

특히 변수 선언시에 자료형을 기재하지 않는 자바스크립트의 경우, 이를 습관화 하지 않으면 나중에 디버깅을 굉장히 어렵게 한다.

#### 동등 연산자(`==`)보다 일치 연산자(`===`)를 우선시 하자

### 4-1. string => number

#### Number vs parseInt(parseFloat) vs new Number

##### Number vs new Number

`Number` 는 function으로서 작용하여 primitive type을 반환하지만, `new Number`는 constructor로서 작용하여 Object를 반환합니다.

큰 차이가 없어 보이지만, 차이는 있습니다.

1. `Object`는 boolean context에서 항상 `true`입니다. 따라서 이를 의식하지 않고 코딩을 하다보면 일반적으로 생각하는 것과 다른 움직임을 보일 수 있습니다.

```javascript
const a = Number("0");
const b = new Number("0");

if (a) {   // false 이므로 조건문 내부는 실행되지 아니함
...
}

if (b) { // `Object([Number: 0])`는 boolean context에서 `true`이므로 조건문 내부가 실행됨
...
}
```

2. Object와 primitive type 의 === 비교시 false가 반환됩니다.

```javascript
const a = new Number("123");
console.log(a === 123); // false

const b = Number("123");
console.log(b === 123); // true

console.log(a instanceof Number); // true
console.log(b instanceof Number); // false
```

혼란을 피하기 위하여 ** new Number는 사용하지 않습니다.**

##### Number vs parseInt

Number 는 문자열 전체를 숫자로 반환하는 한편, parseInt는 문자열을 처음부터 읽어나가다가 최대로 숫자로서의 의미를 가지는 부분까지를 변환합니다.

```javascript
const str = "10x";
console.log(parseInt(str, 10)); // 10
console.log(Number(str)); // NaN
```

또한 parseInt의 시그니쳐는 다음과 같습니다.

`function parseInt(str: string; radix?: number):number`

`parseInt`는 두번째 인자로 어떤 진법으로 문자열을 파싱할지를 전달받습니다. 만약에 생략되면 일반적으로 10진법으로 파싱되나 브라우저에 따라 상이할 수도 있다고 합니다.

이에 반해 Number의 시그니쳐는 다음과 같습니다.

`function Number(str: string):number`

이렇게 인자의 개수가 몇개인지에 따라서 동작이 달라지는 경우가 있습니다.

```js
const arr = ["1", "2", "3"];

arr.map((str) => Number(str)); // [1,2,3]
arr.map((str) => parseInt(str)); // [1,2,3]
```

배열의 map 메서드는 콜백함수를 전달받은 다음에 배열을 순회하면서 요소마다 콜백함수를 실행시키죠

parseInt 도, Number 도 함수이므로, 이를 map의 콜백함수로 전달할 수 있습니다.

```js
const arr = ["1", "2", "3"];

arr.map(Number); // [1,2,3]
arr.map(parseInt); // [ 1, NaN, NaN ]
```

예상하신 결과인가요?

map 함수는 el, index, this 값을 차례로 콜백함수에게 인자로 전달합니다.

따라서 "1"을 순회할 때에 ("1", 0, arr)이 parseInt의 인자로 전달되므로 parseInt(1,0, arr) 이 호출되는 것과 같습니다. 자바스크립트에서는 함수선언시의 매개변수의 개수와 실제 전달한 인자의 개수가 일치하지 않아도 함수 실행에 문제가 없습니다.

위와 같이 parseInt 함수 선언시에 2개의 인자를 받으나 3개를 넘기면 마지막 세번째 인자는 무시됩니다. 반대로 1개의 인자만을 넘기면 2번째 인자는 undefined 가 됩니다. (이를 제어하기 위해서 default parameter 라는 문법이 있죠 ^^)

세번째 인자인 arr은 무시됩니다.

parseInt는 두번째 인자인 radix로 0이 전달되면 이를 무시합니다. 따라서 1로 파싱이 됩니다.

다음 "2"를 순회할 때에는 ("2", 1, arr)이 전달되며 parseInt("2", 1, arr)이 호출되는 것과 같습니다.

parseInt의 radix는 [2,36] 사이의 값만 가질 수 있습니다. radix가 이 범위를 벗어나면 parseInt는 NaN을 반환합니다.

다음 "3"를 순회할 때에는 ("3", 2, arr)이 전달되며 parseInt("3", 2, arr)이 호출되는 것과 같습니다.

2진법에서 각 자리수는 0 또는 1이어야 하죠. 따라서 "3" 은 2진법에서는 절대 존재할 수 없는 숫자입니다. 따라서 NaN을 반환합니다.

또한 "1e6" 과 같이 지수표기법으로 나타낸 문자열도 Number 는 잘 변환합니다.

리터럴으로 a = 1e6; 또한 유효한 숫자 리터럴이기 때문이죠. 하지만 parseInt를 쓰면 e는 숫자 digit이 아니기 때문에 e 앞까지인 1만 숫자로 변환됩니다.

주저리주저리 설명하였지만... Number 를 쓰시는게 속이 편합니다.
경험적으로 `parseInt`와 `Number`의 실행속도차이는 미미한 것 같습니다.
저는 개인적으로 `Number`를 사용합니다. radix를 기재하는게 귀찮기도 하고, 그냥 익숙해서요.
코딩테스트에서는 입력값의 정확성은 보장되므로 어떤 것을 쓰더라도 문제 없을 것 같습니다.

반드시 parseInt를 써야하는 경우는 문자열이 10진수가 아닌 경우 뿐입니다.

#### parseFloat

parseFloat는 parseInt 와 다르게 하나의 인자만을 받습니다. 따라서 parseFloat로는 10진수가 아닌 다른 진법으로 기재된 소수를 파싱할 수 없다. 다른 진법으로 기재된 소수 문자열을 숫자로 변환하기 위해서는 별도의 함수를 만들어야 한다.

일반적으로 parseFloat를 쓸 일도 없다. 10진법이면 그냥 Number 를 쓰면 되기 때문이다.

#### NaN

NaN은 숫자가 아님을 나타내는 숫자자료형이다. NaN은 Not a Number 의 앞글자를 딴 것이다. NaN은 의미론적으로는 숫자가 아님을 나타내지만, 타입은 number이기 때문에 생각보다 골치아픈일이 발생한다.

```js
const a = NaN;

console.log(typeof a); // number;
```

임의로 NaN을 할당하는 경우는 잘 없기 때문에, 대부분 발생하는 경우는 암묵적 자료형변환에 의해서 발생한다.

Number 함수는 어떤 값이던지 매개변수로 받아서 숫자를 반환한다. 스펙에 따르면 절대 에러를 내지 않는다.
이를 함수 시그니쳐로 나타내면

`function Number(a: any): number`

any는 어떤 자료형이던지 올 수 있다는 뜻으로 나타내었다.

Number("abcd") 는 무엇을 반환할 것인가? 라고 하면 바로 NaN을 반환한다.

NaN은 숫자이기 때문에 숫자 관련 연산을 모두 수행할 수 있다. 더하기, 곱하기, 제곱, 나누기 ... 등. 연산의 결과는 모두 NaN이다.

그렇기 때문에 어떤 연산의 결과가 NaN 이라면 자료형변환을 제대로 하였는지 다시 한 번 확인해보자.

NaN인지 확인하는 방법으로 Window.isNaN과 Number.isNaN이 있는데 Number.isNaN을 쓰면 된다. Window.isNaN 에는 여러 문제점이 있어서 추가된 문법이 Number.isNaN 이다.
또는 매우 간단하게 체크하는 방법이 있는데, NaN은 유일하게 자기 자신과 비교하였을 때 false를 반환하는 성질이 있다.

```js
const a = NaN;

a === a; // false

function isNaN(a) {
  return a !== a;
}
```

### 4-2. number => string

#### String vs toString vs new String

어떠한 값이 number 라는 것이 확실하다면, 사용법측면에서 String이나 toString이나 동일하다

```js
const a = 3;

String(a); // "3"

a.toString(); // "3"
```

그런데 a는 3이라는 원시 자료형인데 어떻게 toString 이라는 메서드를 가질 수가 있는거지?

자바스크립트에는 원시자료형에 대한 래퍼객체가 존재한다.
숫자 자료형의 래퍼 객체는 Number 인데 원시자료형에서 래퍼 객체의 메소드를 호출하면 자바스크립트는 해당 값을 래퍼 객체로 감싼 다음에 래퍼 객체의 메서드를 호출하고 값을 반환한다. 래퍼 객체는 바로 제거된다.
그렇기 때문에 원시자료형도 각 래퍼 객체의 메소드를 자유롭게 호출할 수 있다.

참고로 리터럴에서도 사용할 수 있다.

```js
(3).toString();
(3).toString();
(3.5).toString();
```

첫번째의 .. 은 오타가 아니다. 그냥 . 은 소숫점 표기로 인식되기 때문에 정수의 경우에는 ..으로 해야한다. 아니면은 괄호로 감싸야 한다.

그런데 어떠한 값이 숫자일수도 있고 null 일 수도 있고 undefined 일 수도 있다. null이나 undefined는 래퍼객체가 존재하지 않고 따라서 toString 메서드가 존재하지 않기 때문에 에러가 발생한다.

```js
const a = null;

String(a); // "null"

a.toString(); // Uncaught TypeError: Cannot read property 'toString' of null
```

에러 핸들링은 현업에서 매우 깊게 다룰 주제이나, 알고리즘 문제 풀이시에는 에러를 빨리 내는게 디버깅을 편하게 한다. 계산을 다 하고 나서 "null"이 출력되면 이게 어디서부터 발생하는지 찾으러 가는게 더 어려워질 수 있다. 빠르게 에러를 발생시키자.
어떤 걸 쓸지는 취향차이지만, 어떠한 차이가 있을 수 있는지 알아두면 좋다.

#### 0, -0

자바스크립트에는 0이 두가지가 있다. 양의 0과 음의 0. 이 둘을 구분해서 쓰는 경우는 현실적으로 없다.

```js
0 === -0; // true
```

그런데 주의해야할 때가 있다. 바로 문자열로 변환할 때이다.
-0 을 문자열으로 변환하면 "-0" 이 된다.

-0 을 임의로 할당하는 경우는 거의 없다. 주로 나오는 경우는 음수를 Infinity 로 나눈 값을 할당한 경우다. 상당히 디버깅이 까다로운 케이스중 하나인데, 왜냐하면 이론적으로는 다 맞기 때문이다. 테스트 케이스중에 이런 경우가 존재하는지 잘 판단해야 한다. 아니면 Infinity 로 나눌 때에는 명시적으로 Math.abs() 로 감싸는 것도 하나의 방법이다.

### bigint

큰 수를 다룰 때에 bigint 자료형을 쓴다.

BigInt 함수로 변환

number 와 bigint 자료형은 암시적으로 형변환이 되지 않는다.

리터럴 기재할 때 끝에 n을 쓰면 된다.

```js
0n;

1n;

1038428n;
```

bigint를 그냥 console.log로 찍어보면 끝에 n이 기재되어 출력되지만, 문자열로 바꾸면 끝에 'n' 이 없다. 따라서 이 부분은 신경쓰지 않아도 된다.

bigint => string 도 number => string 과 동일하다. toString, String 쓰면 된다.

## 5. 파일입출력

## 6. 문제풀이 예시
