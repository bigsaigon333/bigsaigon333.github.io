---
title: 실무에서 바로 써먹는 정규표현식(1)
date: "2022-05-07"
summary: 실무에서 바로 써먹는 정규표현식
---

※ 이 글은 정규표현식을 사용해본 적은 있지만 정규표현식에 자신이 없는 개발자들을 대상으로 하고 있습니다.

※ 이 글을 읽고 나면 내가 원하는 정규표현식을 자유자재로 작성하여 사용할 수 있게 됩니다.

※ 이 글에서 정규표현식은 자바스크립트 정규표현식 리터럴의 형태로 기술합니다. 즉, `a(b|c)`는 `/a(b|c)/` 로 기술합니다.

## I. 정규표현식이란

정규표현식이란 **문자열의 패턴을 표현하기 위한 작성법**입니다.

예를 들어 `0부터 9 사이에 있는 하나의 숫자` 라는 패턴을 정규표현식에서는 `/0|1|2|3|4|5|6|7|8|9/` , `/[0-9]/` 또는 `/\d/`로 나타낼 수 있습니다.

또한 `apple, tomato, pineapple이 순서와 상관없이 모두 포함된 문자열`은 `/(?=.*apple)(?=.*tomato)(?=.*pineapple)/` 으로, `tomato가 3번 이상 존재하는 문자열` 은 `/(.*\btomato\b.*){3}/` 으로 나타낼 수 있습니다.

즉, 문자열의 패턴을 컴퓨터가 이해할 수 있게끔 명확하게 표현하는 방법이 정규표현식입니다.

주어진 문자열에 정규표현식으로 기술한 문자열의 패턴이 포함되어 있는 경우, 주어진 문자열이 정규표현식에 일치한다 라고 합니다.

예를 들어, `a` 는 숫자가 아니므로 `/0|1|2|3|4|5|6|7|8|9/` 에 일치하지 않지만 `3`은 `/0|1|2|3|4|5|6|7|8|9/`에 일치합니다.

또한, `1bc`, `a2c`, `ab3` 모두 정규표현식 `/0|1|2|3|4|5|6|7|8|9/`에 일치합니다. 왜냐하면 정규표현식이 의미하는 `0부터 9 사이에 있는 하나의 숫자`라는 패턴이 각 문자열에 모두 존재하기 때문입니다. `1bc`는 첫번째 문자인 `1`이, `a2c`는 두번째 문자인 `2`가, `ab3`의 경우 세번째 문자인 `3`이 `0부터 9 사이에 있는 하나의 숫자`에 해당하여 주어진 정규표현식에 일치합니다.

## II. 정규표현식이 사용되는 상황

자바스크립트에서 정규표현식의 가장 기본적인 사용법은 주어진 문자열에서 정규표현식으로 기술되는 문자열의 패턴을 검색하는 것입니다.

검색한 결과가 있다면 주어진 문자열이 정규표현식에 일치하는 것을 알 수 있습니다.
검색한 결과가 없다면 주어진 문자열에 정규표현식으로 표현되는 패턴에 존재하지 않는다, 즉 주어진 문자열이 정규표현식에 일치하지 않는 것을 알 수 있습니다.

이를 응용하면 정규표현식에 일치하는 부분 문자열이 무엇이었는지 특정하거나, 해당 부분 문자열을 다른 문자열로 치환하거나, 빈문자열로 치환하여 삭제하는 것도 가능해집니다.

또한, 정규표현식의 문자열 처음, 문자열 끝을 나타내는 메타문자를 활용한다면 문자열 전체를 대상으로 한 패턴을 기술할 수도 있습니다. 이를 이용하여 주어진 문자열 그 자체가 정규표현식에 일치하는지를 검색하여, 전체 문자열을 검증할 수도 있습니다.

<!-- 문자열 검증 -->

<!-- 부분 문자열 검색 -> 전체 문자열 검증
부분 문자열 추출
부분 문자열 치환
부분 문자열 삭제

문자열을 검증하는 역할 - 완전 일치
문자열 중에 정규표현식에 일치하는 부분 문자열이 있는가 - 부분 일치
응용1) 일치하는 부분 문자열을 추출
응용2) 일치하는 문자열을 다른 문자열로 치환 -->

## III. 정규표현식 기본 연산자

정규표현식의 기본 연산자로 3가지가 있습니다. 이 3가지만 안다면 왠만한 정규표현식은 다 이해할 수 있으며 기술할 수 있게 됩니다.

### 1. 접합 연산자

주어진 문자열에 "a"가 존재하는지 알고 싶다 → /a/
주어진 문자열에 "b"가 존재하는지 알고 싶다 → /b/
주어진 문자열에 "a"와 "b"가 접합된 "ab"가 존재하는지 알고 싶다 → /ab/

접합 연산자는 별도의 기호가 없습니다.

### 2. 선택 연산자: |

주어진 문자열에 "a" 또는 "b"가 존재하는지 알고 싶다 → /a|b/

#### 우선순위

/a(b|c)/

여기서 괄호(`()`)는 사칙연산에서 사용되는 것과 동일하게 우선순위를 나타내기 위하여 사용하였습니다.

괄호가 가지는 캡쳐의 의미는 추후에 다루도록 하겠습니다.

괄호를 사용한 이유는 접합 연산자가 선택 연산자보다 우선순위가 높기 때문입니다.

`/ab|c/` 는 "ab" 또는 "c" 라는 문자열 패턴을 나타내지만

`/a(b|c)/`는 `/ab|ac/`와 동일한 의미로, "ab" 또는 "ac"라는 문자열 패턴을 나타냅니다.

#### `/a(b|cd)/` 와 같이 선택 연산자 전후의 길이가 같을 필요는 없습니다

선택 연산자를 여러개 사용하는 것도 가능합니다

`/ab|cd|ef/`, `/a(b|c(d|e|f))/` 도 모두 유효한 정규표현식입니다.

`/a(b|c(d|e|f))/` == /a(b|cd|ce|cf)/ == /ab|acd|ace|acf/ 와 같은 의미이지만, 실제로 정규표현식을 이해하기 위해 하나씩 풀어헤칠 필요가 없습니다.
그보다, 첫번째 문자로 a가 오고 그 다음에 b 또는 c(d|e|f) 가 온다 와 같이 읽는 것이 일반적입니다. 이러한 예시는 임의로 만들어 낸 것이므로 아무런 의미가 없기에 난해하게 느껴지지만, 경우에 따라서 이러한 패턴이 당연한 경우가 있습니다.

#### 선택연산자에서 빈 문자열을 나타내고 싶은 경우가 있습니다

그럴때는 선택연산자의 operand에 아무것도 기술하지 않으면 됩니다.

예를 들어 banana 또는 bananas 라는 문자열 패턴을 정규표현식으로 기술하고 싶습니다.

/banana(|s)/ 와 같이 기술할 수 있습니다. (이는 나중에 언급될 ? 를 사용하면 /bananas?/ 와 같이 작성할 수도 있습니다. )

### 3. 반복 연산자: \*

연산자 앞의 문자가 0번 이상 반복됨을 나타냅니다.

`/a*/` === //, /a/, /aa/, /aaa/, ...

### 4. 우선순위

반복 연산자 > 접합 연산자 > 선택 연산자

예를 들어 `/ab|c*/`는 어떤 문자열 패턴을 의미할까요?

우선순위를 명확히 보여주기 위해 괄호를 추가해보겠습니다

`/(ab)|(c*)/` 즉, ab 또는 c가 0번 이상 반복되는 문자열을 의미합니다.

연산자 간의 우선순위를 바꾸고 싶다면 괄호를 추가하면 됩니다.

`/a(b|c*)/` 는 이제 `/ab|c*/` 와 다르게 `ab` 또는 `ac*` 를 의미합니다.

### 5. Syntax Sugar

선택 연산자를 이용해서 `0부터 9사이에 있는 하나의 숫자`를 나타낸다면 `/0|1|2|3|4|5|6|7|8|9/` 가 됩니다. 하지만 이는 너무 번거롭습니다. `0부터 9사이에 있는 하나의 숫자`가 연속된 문자열, 즉 00, 01, 24, 35, 99 등을 나타내려면

`/(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)/` 와 같이 나타내야 합니다.

이를 간단하기 기술하기 위한 문법적 설탕, Syntax Sugar가 여러가지 있습니다.

#### []

`[]`는 선택 연산자를 간단하게 기술하기 위한 방법입니다. `/[0123456789]/`는 `/0|1|2|3|4|5|6|7|8|9/`와 동일합니다. 즉, 여러개의 문자 중 하나만을 의미하게 하고 싶을 때에는 꺽쇠 괄호([]) 안에 여러개의 문자를 기술하면 됩니다.
`[]`는 하나의 문자만을 의미하기 때문에 `/ab|c/` 와 같은 경우는 []를 이용해서 나타낼 수 없습니다.

또한 `[]` 내에서 `-` 를 사용하여 범위를 나타낼 수 있습니다. `/[0123456789]/`는 `/[0-9]/` 와 같이 나타낼 수 있습니다. `-`의 정확한 의미는 아스키 코드(또는 유니코드)로 나타낸 문자의 범위를 의미합니다. 0은 `0x30` 이며 1은 `0x31`, 2는 `0x32` 입니다. 9는 `0x39`이므로, `/[0-9]/`는 `0x30` 부터 `0x39`까지의 모든 문자를 나타내며 `0x30`과 `0x39`도 포함됩니다.

`-` 를 사용할 때 주의점은 반드시 앞 뒤에 문자가 와야한다는 점입니다. `/[-9]/` 은 "-" 또는 "3"을 나타내며, `0x00` 부터 `0x39` 사이의 하나의 문자를 의미하지 않습니다. 또한 `/[9-0]/`과 같은 표현은 유효한 정규표현식이 아니기 때문에 에러를 방출합니다.

#### 문자열 클래스

`0부터 9사이에 있는 하나의 숫자`, 공백문자, 알파벳 대소문자와 숫자 및 언더바(\_) 등 자주 사용되는 문자들의 집합은 이미 정규표현식에 정의가 되어 있습니다.

예를 들어 `0부터 9사이에 있는 하나의 숫자`, 즉 `[0-9]`는 `\d` 로 사용할 수 있습니다.
스페이스, 탭, 뉴라인, 캐리지 리턴 등 각종 공백문자, 즉 `/[f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]/`는 `\s`로 사용할 수 있습니다.
알파벳 대소문자와 숫자 및 언더바(\_) , 즉 `/[0-9a-zA-Z_]/`는 `\w`로 사용할 수 있습니다.

#### ?, +, {3, 4}

`?` 는 0개 또는 1개를 나타냅니다.

banana 또는 bananas를 나타내고 싶을 때 `/banana(|s)/` 로 나타낼 수도 있지만 `/bananas?/`로 기술할 수도 있습니다.

`+` 는 1개 이상을 의미합니다.

`/a+/` 는 `/aa*/` 과 동일합니다.

`{}`를 이용하면 특정한 수량의 반복을 나타낼 수 있습니다.
예를 들어

"banana" 를 나타내기 위해 `/ba(na){2}/` 와 같이 기술할 수 있습니다.
nana 는 na가 2번 반복되므로 반복되는 횟수를 `{2}`와 같이 적어서 표현하였습니다.

"aaa" 또는 "aaaa" 즉, a가 3번 이상 4번 이하 반복되는 문자열 패턴을 나타내기 위해서는 `/a{3,4}/` 와 같이 기술할 수 있습니다.

a가 3번 이상 반복되는 문자열은 `/a{3,}`로 나타낼 수 있습니다.

?, +, {}는 반복 연산자와 동일한 우선순위를 갖습니다. 따라서 접합연산자보다 우선순위가 높습니다.

## IV. 예시

### 1) 주문하기시 라이더님께 요청사항에 금지된 단어가 포함되어 있는지 확인

배달의 민족 어플에서 주문하기 페이지에는에 보면 가게 사장님께 요청사항과 라이더님께 요청사항 기재란이 있습니다.

예를 들어 라이더님께 요청사항에 "빨리" "빠르게" "퀵" "스피드"라는 단어는 포함할 수 없다고 가정해보겠습니다.

요청사항에 해당 문자열이 포함되어 있는지 어떻게 알 수 있을까요?

선택 연산자를 이용하면 "빨리" "빠르게" 또는 "퀵" 또는 "스피디" 라는 문자열 패턴을 간단하게 나타낼 수 있습니다.

`/빨리|빠르게|퀵|스피디/`

따라서 요청사항이 해당 정규표현식에 일치한다면 요청사항에 빨리, 빠르게, 퀵, 스피디 라는 단어가 포함된 것임을 알 수 있습니다.

이를 다른 문자열로 치환하거나 삭제하는 건 다음 편에서 다루어보도록 하겠습니다.

자바스크립트로 나타내면 다음과 같습니다.

```js
function hasBannedWords(requestMessage) {
  return `/빨리|빠르게|퀵|스피디/`.test(requestMessage);
}

console.log(hasBannedWords("빠르게 와주세요")); // true
console.log(hasBannedWords("초인종 누르지 말아주세요")); // false
```

`RegExp.prototype.test`는 인자로 주어진 문자열이 정규표현식에 일치하면 true를 일치하지 않으면 false를 반환합니다.

### 2) 생년월일 검증

생년월일이 YYYY-MM-DD 형식으로 주어진다고 하겠습니다. 문제를 간단히 하기 위해 윤년은 고려하지 않겠습니다.

유효한 생년월일인지 정규표현식을 이용해서 검증해보겠습니다.

유효한 연도는 1900년부터 2022년을 의미한다고 가정하겠습니다.

1. 유효한 연도는 어떻게 나타낼 수 있을까요?
   선택 연산자를 이용한다면 `/1900|1901|1902| ... 2021|2022/` 와 같이 나타낼 수 있습니다. 하지만 122개를 모두다 기술할 수는 없습니다. 먼저 1900 ~ 2022년을 3가지 구간으로 나누겠습니다.

   - 1900 ~ 1999
   - 2000 ~ 2019
   - 2020 ~ 2022

   1900 ~ 1999은 앞의 19가 고정임을 알 수 있습니다. 뒤의 두자리숫자는 00 ~ 99 까지 다 변화하죠. 따라서 /19[0-9][0-9]/ -> /19\d\d/ -> /19\d{2}/ 로 나타낼 수 있습니다.

   \d\d 보다 \d{2}가 글자수가 많으므로 /19\d\d/로 하겠습니다.

   2000 ~ 2019 는 앞의 20이 고정이며 뒤에서 두번째 숫자는 0 또는 1이며 마지막 자리수는 0~9 입니다. 따라서
   /20[01][0-9]/ -> /20[01]\d/ 로 나타낼 수 있습니다.

   2020 ~ 2022는 앞의 202가 고정이며 마지막 자리수가 0~2 입니다. 따라서 /202[0-2]/ 로 나타낼 수 있습니다.

   이 3가지 패턴을 선택 연산자로 나타내 보겠습니다 `/19\d\d|20[01]\d|202[0-2]/`로 나타낼 수 있습니다. 조금 더 축약을 해보자면 `/19\d\d|20([01]\d|2[0-2])/` 로도 할 수 있겠네요.

2. 유효한 월일

1,3,5,7,8,10,12 월은 31일까지 있고
4,6,9,11월은 30일까지 있고
2월은 28일까지 있습니다.

따라서 3가지 구간으로 나눠서 생각해보겠습니다.

- 1,3,5,6,7,10,12월은 01일부터 31일까지 유효한 일입니다.

`/(0[13578]|1[02])-(0[1-9]|[12]\d|3[01])/`

- 4,6,9,11월은 01일부터 30일까지가 유효한 일입니다.
  `/(0[469]|11)-(0[1-9]|[12]\d|30)/`

- 2월은 01부터 28일까지가 유효한 일입니다.

`/02-(0[1-9]|1\d|2[0-8])/`

3가지 구간을 합치면 다음과 같습니다.

`/(0[13578]|1[02])-(0[1-9]|[12]\d|3[01])|(0[469]|11)-(0[1-9]|[12]\d|30)|02-(0[1-9]|1\d|2[0-8])/`

3. 유효한 연도와 유효한 월일을 합치면 다음과 같습니다.

`/(19\d\d|20([01]\d|2[0-2]))-(0[13578]|1[02])-(0[1-9]|[12]\d|3[01])|(0[469]|11)-(0[1-9]|[12]\d|30)|02-(0[1-9]|1\d|2[0-8])/`

```js
const re =
  /(19\d\d|20([01]\d|2[0-2]))-((0[13578]|1[02])-(0[1-9]|[12]\d|3[01])|(0[469]|11)-(0[1-9]|[12]\d|30)|02-(0[1-9]|1\d|2[0-8]))/;

function isValidBirthday(birthday) {
  return re.test(birthday);
}

console.log(isValidBirthday("2999-08-28")); // false
console.log(isValidBirthday("1999-35-31")); // false
console.log(isValidBirthday("1999-03-02")); // true
console.log(isValidBirthday("1999-08-28")); // true
console.log(isValidBirthday("1999-08-32")); // false
console.log(isValidBirthday("1999-11-30")); // true
console.log(isValidBirthday("1999-11-31")); // false
console.log(isValidBirthday("1999-02-28")); // true
console.log(isValidBirthday("1939-04-28")); // true
console.log(isValidBirthday("1999-02-29")); // fa;se
console.log(isValidBirthday("1999-00-31")); // false
console.log(isValidBirthday("2023-00-31")); // false
console.log(isValidBirthday("2023-01-31")); // false
console.log(isValidBirthday("2022-01-31")); // true
console.log(isValidBirthday("1822-01-31")); // false
console.log(isValidBirthday("1922-01-31")); // true
```

하지만 위의 식에는 치명적인 문제점이 있습니다.

```js
console.log(isValidBirthday("1999-08-281")); // true
console.log(isValidBirthday("11999-08-28")); // true
```

이게 어찌된 영문일까요? 정규표현식은 문자열의 패턴을 표현하는 방법입니다.

"1999-08-281" 이라는 주어진 문자열의 부분 문자열 "1999-08-28" 은 정규표현식에서 표현하고자하는 문자열의 패턴과 일치합니다. 따라서 "1999-08-281"는 해당 정규표현식에 일치합니다.

우리는 주어진 문자열의 부분 문자열이 아닌 전체 문자열과 일치하는지 확인하고 싶습니다. 그럴 때에 `^`, `$` 를 이용해서 해결할 수 있습니다.

`^`는 문자열의 처음 위치를 나타내며 `$`은 문자열의 마지막 위치를 나타냅니다. `^`과 `$`이 주어진 문자열의 첫번째 문자, 마지막 문자가 아닌 위치임을 주의깊게 봐주세요. 위치 개념은 다음 편의 탐색에서 자세히 다룰 개념입니다. 위치는 문자를 소비하지 않는다는 특징이 있습니다.

정규표현식의 처음과 끝에 `^`과 `$`를 추가해보겠습니다.

`/^(19\d\d|20([01]\d|2[0-2]))-(0[13578]|1[02])-(0[1-9]|[12]\d|3[01])|(0[469]|11)-(0[1-9]|[12]\d|30)|02-(0[1-9]|1\d|2[0-8])$/`

```js
const re =
  /^(19\d\d|20([01]\d|2[0-2]))-((0[13578]|1[02])-(0[1-9]|[12]\d|3[01])|(0[469]|11)-(0[1-9]|[12]\d|30)|02-(0[1-9]|1\d|2[0-8]))$/;

function isValidBirthday(birthday) {
  return re.test(birthday);
}

console.log(isValidBirthday("1999-08-28")); // true
console.log(isValidBirthday("1999-08-281")); // false
console.log(isValidBirthday("11999-08-28")); // false
```

## V. 마무리

정규표현식 기본 연산자 3개만으로도 많은 걸 할 수 있습니다. 아마 전보다는 자신있게 기본 연산자를 조합할 수 있게 되었을거라 생각합니다. 하지만, 뭔가 부족함도 느끼셨겠죠. 정교하게 내가 원하는 부분만을 알아내기 위해서는 기본 연산자 외에 탐색, 캡쳐와 같은 기능을 필요로 합니다. 이 부분은 다음 편에서 알아보도록 하겠습니다.

또한, 예제2 에서 보다시피 정규표현식을 사용하면 오히려 굉장히 복잡해질 수도 있습니다.
생년월일 유효성 검증의 경우 "-" 으로 split 한다음에 배열의 길이를 비교하고, 각 요소가 숫자인지 검증하고, 숫자로 변경한 다음에 숫자 비교로 할 수도 있습니다. 정규표현식은 주어진 문자열을 문자열 자체로 보고 문자열로서의 패턴에 해당하는지를 파악하는 한편, 자바스크립트는 이를 파싱해서 의미를 부여한 다음에 계산을 해냅니다. 따라서 보는 관점이 다른 것입니다.
처음 정규표현식을 쓰면 뭐든지 정규표현식으로 다 작성하고 싶은 욕구가 생깁니다. 하지만 유지보수성, 가독성 등을 고려하면 정규표현식이 항상 최선의 방법인 것은 아닙니다. 이를 잘 고려한 다음에 정규표현식을 현업에도 적용해보시기 바랍니다.

다음 편에서는 탐색, 캡쳐와 같은 기능을 알아보고 정규표현식에 일치하는 문자열에서 일치하는 부분을 추출하고 치환하는 방법에 대해서 알아보겠습니다.
